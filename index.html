<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Builder</title>
  <style>
    :root{
      color-scheme: dark;
      /* Theme variables (default: dark) */
      --bg:#0b0f17; --bgGlow:#17213a;
      --panel:#121a27; --panel2:#0f1622;
      --text:#e8eefc; --muted:#9fb0d0;
      --border:#22314b; --accent:#7aa2ff; --danger:#ff6b6b; --ok:#4cd97b; --warn:#ffd166;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      /* Alpha surfaces (use vars so Light mode looks right) */
      --panelA: rgba(18,26,39,.7);
      --panelB: rgba(18,26,39,.72);
      --panelC: rgba(15,22,34,.75);
      --panelD: rgba(18,26,39,.55);
      --borderA: rgba(34,49,75,.85);
      --borderB: rgba(34,49,75,.9);
      --divider: rgba(34,49,75,.8);
      --accentA: rgba(122,162,255,.55);
      --accentB: rgba(122,162,255,.10);
      --overlay: rgba(0,0,0,.55);
      --modalHeaderBg: rgba(18,26,39,.92);
      --btnHoverBorder: rgba(122,162,255,.55);
      --btnPrimaryBg: rgba(122,162,255,.18);
      --btnPrimaryBorder: rgba(122,162,255,.45);
      --btnDangerBg: rgba(255,107,107,.12);
      --btnDangerBorder: rgba(255,107,107,.35);
      --pillOkBorder: rgba(76,217,123,.35);
      --pillOkBg: rgba(76,217,123,.10);
      --pillWarnBorder: rgba(255,209,102,.35);
      --pillWarnBg: rgba(255,209,102,.08);
      --calloutBorder: rgba(34,49,75,.85);
      --calloutBg: rgba(15,22,34,.75);
      --blockquoteBorder: rgba(122,162,255,.55);
      --blockquoteBg: rgba(122,162,255,.07);

      --inputBg: rgba(15,22,34,.9);
      --inputOptionBg: #0f1622;

      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    :root[data-theme="light"]{
      color-scheme: light;
      --bg:#edf3ff; --bgGlow:#d8e6ff;
      --panel:#ffffff; --panel2:#f2f6ff;
      --text:#0b1220; --muted:#4b5b7a;
      --border:#d4deef; --accent:#2b6cff;
      --danger:#d63c3c; --ok:#1c9b4a; --warn:#b8860b;
      --shadow: 0 10px 30px rgba(10,30,70,.12);

      --panelA: rgba(255,255,255,.86);
      --panelB: rgba(255,255,255,.92);
      --panelC: rgba(242,246,255,.92);
      --panelD: rgba(255,255,255,.70);
      --borderA: rgba(212,222,239,.95);
      --borderB: rgba(212,222,239,.95);
      --divider: rgba(212,222,239,.9);
      --accentA: rgba(43,108,255,.45);
      --accentB: rgba(43,108,255,.10);
      --overlay: rgba(0,0,0,.35);
      --modalHeaderBg: rgba(255,255,255,.92);
      --btnHoverBorder: rgba(43,108,255,.45);
      --btnPrimaryBg: rgba(43,108,255,.10);
      --btnPrimaryBorder: rgba(43,108,255,.28);
      --btnDangerBg: rgba(214,60,60,.10);
      --btnDangerBorder: rgba(214,60,60,.28);
      --pillOkBorder: rgba(28,155,74,.28);
      --pillOkBg: rgba(28,155,74,.10);
      --pillWarnBorder: rgba(184,134,11,.28);
      --pillWarnBg: rgba(184,134,11,.10);
      --calloutBorder: rgba(212,222,239,.95);
      --calloutBg: rgba(242,246,255,.9);
      --blockquoteBorder: rgba(43,108,255,.35);
      --blockquoteBg: rgba(43,108,255,.07);

      --inputBg: #ffffff;
      --inputOptionBg: #ffffff;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0; font-family:var(--sans); color:var(--text);
      background: radial-gradient(1200px 900px at 18% 6%, var(--bgGlow) 0%, var(--bg) 62%), linear-gradient(180deg, var(--accentB) 0%, rgba(0,0,0,0) 60%);
      }
    .app{ max-width: 1180px; margin: 26px auto; padding: 0 18px 34px; }
    header{ display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom: 14px; }
    .title{ display:flex; flex-direction:column; gap:4px; }
    .title h1{ margin:0; font-size:18px; letter-spacing:.2px;}
    .titleRow{ display:flex; align-items:center; gap:10px; }
    .modeChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: var(--panelB);
      color: var(--text);
      font-size:12px;
      cursor:pointer;
      user-select:none;
      line-height:1;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .modeChip:hover{ background: rgba(255,255,255,.06); }
    [data-theme="light"] .modeChip:hover{ background: rgba(0,0,0,.04); }
    .modeChip:active{ transform: translateY(1px); }
    .modeChip .dot{
      width:9px;
      height:9px;
      border-radius:50%;
      background: var(--muted);
      box-shadow: 0 0 0 2px rgba(0,0,0,.15) inset;
    }
    .modeChip[data-provider="local"] .dot{ background: #6EE7B7; }
    .modeChip[data-provider="github"] .dot{ background: #60A5FA; }


.modeGroup{ display:inline-flex; align-items:center; gap:8px; }
.modeChip.iconOnly{ padding:6px 10px; min-width:30px; justify-content:center; }
.modeChip.iconOnly .label{ font-size:14px; }
.modeChip.needsSetup{ border-color: rgba(214, 60, 60, .55); box-shadow: 0 0 0 3px rgba(214, 60, 60, .12); }

    .title .sub{ color:var(--muted); font-size:13px; }
    .tabs{
      display:flex; gap:10px; background: var(--panelA);
      border:1px solid var(--border); border-radius: 999px; padding:6px; box-shadow: var(--shadow);
    }
    .tab{
      border:0; background: transparent; color: var(--muted);
      padding: 10px 14px; border-radius: 999px; cursor:pointer; font-weight:600;
    }
    .tab.active{ background: var(--btnPrimaryBg); color: var(--text); }
    .topbar{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin: 14px 0 18px; }
    .chip{
      display:flex; align-items:center; gap:10px;
      background: var(--panelA); border:1px solid var(--border);
      border-radius: 999px; padding: 10px 12px;
      box-shadow: var(--shadow);
    }
    .chip label{ color: var(--muted); font-size:12px; }
    select, input[type="text"], textarea{
      background: var(--inputBg); color: var(--text);
      border: 1px solid var(--border); border-radius: 10px;
      padding: 10px 10px; font-size: 14px; outline: none;
    }
    select{ padding: 9px 10px; }
    select option{ background: var(--inputOptionBg); color: var(--text); }
    textarea{
      width:100%;
      min-height: 140px;
      height: 240px;
      max-height: 45vh;
      resize: vertical;
      font-family: var(--mono);
      line-height:1.35;
    }

    .btn{
      border: 1px solid var(--border);
      background: var(--panelA);
      color: var(--text); border-radius: 10px;
      padding: 10px 12px; cursor:pointer; font-weight:600;
    }
    .btn:hover{ border-color: var(--btnHoverBorder); }
    .btn.primary{ background: var(--btnPrimaryBg); border-color: var(--btnPrimaryBorder); }
    .btn.danger{ background: var(--btnDangerBg); border-color: var(--btnDangerBorder); }
    .btn.ghost{ background: transparent; }
    .mini{ font-size: 12px; padding: 8px 10px; border-radius: 10px; }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }
    .card{
      background: var(--panelB);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .card h2{
      margin: 0 0 10px; font-size: 14px; letter-spacing:.2px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .muted{ color: var(--muted); font-size: 12px; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    /* Form rows (used in edit popups) */
    .formRow{
      display:grid;
      grid-template-columns: 110px 1fr;
      gap: 12px;
      align-items: center;
    }
    .formRow.top{ align-items: start; }
    .formLabel{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.2;
      padding-top: 2px;
      user-select: none;
      white-space: nowrap;
    }
    .formRow > *:nth-child(2){
      min-width: 0;
    }
    .fieldBlock{ display:flex; flex-direction:column; gap:6px; }
    .fieldBlock textarea{ width:100%; }
    .outConfig{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .outConfig .muted{ font-size: 12px; }
    .outConfig select{ min-width: 260px; }
    .list{ display:flex; flex-direction:column; gap:8px; }
    .item{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      padding: 10px 10px; border:1px solid var(--borderA);
      border-radius: 12px; background: var(--panelC);
    }
    .item .meta{ display:flex; flex-direction:column; gap:3px; min-width: 0; }
    .item .meta .name{
      font-weight:700; font-size: 13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width: 520px;
    }
    .item .meta .small{ font-size: 12px; color: var(--muted); }
    .item .actions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
.outCtrl{ display:flex; align-items:center; gap:6px; padding:2px 8px; border:1px solid var(--line); border-radius:999px; background:var(--panel); }
.outCtrl label{ font-size:12px; color:var(--muted); user-select:none; }
.outCtrl select{ font-size:12px; padding:4px 8px; border-radius:10px; border:1px solid var(--line); background:transparent; color:inherit; }
.outCtrl input[type="checkbox"]{ transform: translateY(1px); }

    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding: 2px 8px; border-radius:999px;
      border:1px solid var(--borderB);
      background: var(--panelD);
      color: var(--muted); font-size: 11px;
    }
    .divider{ height:1px; background: var(--divider); margin: 10px 0; }
    .hint{
      border: 1px dashed var(--accentA);
      background: var(--accentB);
      padding: 10px 12px; border-radius: 12px;
      color: var(--muted); font-size: 12px;
    }

    /* Modal */
    .modalOverlay{
      position:fixed; inset:0;
      background: var(--overlay);
      display:none; align-items:center; justify-content:center;
      padding: 18px;
      overflow-y: auto;
      overflow-x: hidden; /* critical */
    }
    .modalOverlay.open{ display:flex; }
    .modal{
  width: min(1020px, 100%);
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: 14px;
  max-height: calc(100vh - 40px);
  display: flex;
  flex-direction: column;
  overflow: hidden; /* body scrolls, header stays fixed */
}

    /* Fullscreen modal (used by Output reader) */
    .modalOverlay.fullscreen{
      padding: 0;
      align-items: stretch;
      justify-content: stretch;
    }
    .modalOverlay.fullscreen .modal{
      width: 100%;
      height: 100vh;
      max-height: 100vh;
      border-radius: 0;
      padding: 0;
    }
    .modalOverlay.fullscreen .modalHeader{
      margin: 0;
      padding: 14px 16px;
    }
    .modalOverlay.fullscreen #modalBody{
      padding: 14px 16px;
      padding-right: 16px;
    }
    .modalOverlay.fullscreen #modalFooter{
      margin-top: 0 !important;
      padding: 12px 16px;
    }
    .mdPreview.outputReader{
      font-size: 15px;
      line-height: 1.7;
      max-width: 920px;
      margin: 0 auto;
      padding: 18px 20px;
      background: var(--panel2);
      border: 1px solid var(--calloutBorder);
      border-radius: 14px;
      box-sizing: border-box;
    }

.split{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 980px){ .split{ grid-template-columns: 1fr; } }
    .split > div{ min-width:0; }

    .badgeOk{
      color: var(--ok);
      border-color: var(--pillOkBorder);
      background: var(--pillOkBg);
    }
    .badgeWarn{
      color: var(--warn);
      border-color: var(--pillWarnBorder);
      background: var(--pillWarnBg);
    }

    .dupTimes{
      display:flex;
      flex-direction:column;
      gap:2px;
      text-align:right;
      width:100%;
    }
    .dupTimes .dupLine{
      font-size: 11px;
      color: var(--muted);
      white-space: normal;
      overflow-wrap: anywhere;
      line-height: 1.2;
    }
    .dupTimes b{ color: var(--text); font-weight:700; }

    .importItemTitle{
      font-weight: 700;
      white-space: normal;
      overflow-wrap: break-word;
      word-break: normal;
      hyphens: auto;
      line-height: 1.25;
      max-width: none;
    }
    .newerTag{ margin-left:6px; }

    /* Import snapshot wizard (clean layout) */
    .importGrid{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 980px){ .importGrid{ grid-template-columns: 1fr; } }
    .importFooterFull{ grid-column: 1 / -1; }

    .importGroup{
      background: var(--panelB);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      overflow: hidden;
    }
    .importGroupHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .importGroupTitle{
      font-weight: 800;
      font-size: 13px;
      letter-spacing: .2px;
      color: var(--text);
      min-width: 0;
    }
    .importGroupControls{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }
    .importRows{ display:flex; flex-direction:column; gap:8px; }

    .importRow{
      display:grid;
      grid-template-columns: 18px 1fr;
      gap:10px;
      align-items:flex-start;
      padding: 10px;
      border: 1px solid var(--borderA);
      border-radius: 12px;
      background: var(--panelC);
    }
    .importRow.auto{ outline: 1px dashed var(--accentA); }
    .importMain{ min-width:0; }
    .importTitleLine{ display:flex; align-items:flex-start; gap:8px; min-width:0; }
    .importMeta{
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
      overflow-wrap: break-word;
    }
    .importBadges{
      margin-top: 6px;
      display:flex;
      align-items:center;
      gap:6px;
      flex-wrap:wrap;
    }

    .importMeta:empty{ display:none; }
    .importBadges:empty{ display:none; }
    /* Import accordions (Users/Careers grouped) */
    .importAccordion{ display:flex; flex-direction:column; gap:10px; }
    .importAccordion details{
      border: 1px solid var(--borderA);
      border-radius: 12px;
      background: var(--panelC);
      overflow: hidden;
    }
    .importAccordion summary{
      list-style: none;
      cursor: pointer;
      padding: 10px;
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .importAccordion summary::-webkit-details-marker{ display:none; }
    .importAccSummaryLeft{ display:flex; align-items:flex-start; gap:10px; min-width:0; flex:1; }
    .importAccName{ font-weight:800; min-width:0; overflow-wrap: break-word; word-break: normal; }
    .importAccCounts{ font-size:11px; color: var(--muted); margin-left:auto; white-space:nowrap; }
    .importAccBody{
      padding: 10px;
      border-top: 1px solid var(--borderA);
      background: var(--panelB);
    }
    .importAccTools{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .importAccTools .muted{ font-size:11px; }




    /* Markdown preview */
    .mdPreview{
      border: 1px solid var(--calloutBorder);
      background: var(--panelC);
      border-radius: 12px;
      padding: 10px;
      max-height: 80vh;
      min-width: 0;
      overflow-y: auto;
      overflow-x: hidden;
      color: var(--text);
    }
    .mdPreview h1,.mdPreview h2,.mdPreview h3,.mdPreview h4,.mdPreview h5,.mdPreview h6{ margin: 10px 0 6px; }
    .mdPreview p{ margin: 8px 0; }
    .mdPreview code{ font-family: var(--mono); background: rgba(255,255,255,.06); padding: 1px 6px; border-radius: 8px; }
    .mdPreview pre{
      background: var(--panel2);
      padding: 10px;
      border-radius: 12px;
      overflow-y:auto; overflow-x:hidden; white-space: pre-wrap; word-break: break-word;
      max-height: 80vh;
      border: 1px solid var(--calloutBorder);
    }
    .mdPreview pre code{ background: transparent; padding: 0; }
    .mdPreview blockquote{
      border-left: 3px solid var(--blockquoteBorder);
      margin: 8px 0;
      padding: 6px 10px;
      color: var(--muted);
      background: var(--blockquoteBg);
      border-radius: 10px;
    }

    .sectionTitle{
      margin-top:10px;
      font-weight:800;
      color: var(--text);
      font-size: 13px;
      letter-spacing: .2px;
    }
    .readonlyBox{
      width:100%;
      min-height: 140px;
      height: 240px;
      max-height: 45vh;
      font-family: var(--mono);
    }
  

    /* Prevent horizontal scrolling from long markdown/code/URLs */
    html, body { overflow-x: hidden; }
    .app, main, section, .card { overflow-x: hidden; }
    .modal { overflow-x: hidden; }
    #modalBody { overflow-x: hidden; }
    textarea { white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; overflow-x: hidden; }
    .mdPreview { overflow-x: hidden; max-width: 100%; overflow-wrap: anywhere; word-break: break-word; }
    .mdPreview pre { white-space: pre-wrap; overflow-x: hidden; max-width: 100%; }
    .mdPreview code { white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; }

    /* Modal header (title + close) */
.modalHeader{
  position: relative;
  z-index: 50;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin: 0 0 10px;
  padding: 2px 0 10px;
  background: var(--panel);
  border-bottom: 1px solid var(--border);
}


    .modalHeaderLeft{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    #modalHeaderActions{ flex-wrap: wrap; }

/* Scrollable modal content area */
#modalBody{
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 2px;
}

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin: 0 0 10px;
    }
    .field label{
      display:block;
      color: var(--muted);
      font-size: 12px;
    }
    .field input[type="text"]{ width:100%; }

    .pill.warn{

      border-color: rgba(255, 205, 76, .45);
      background: rgba(255, 205, 76, .12);
      color: rgba(255, 223, 160, 1);
    }


    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      z-index: 9999;
      display: none;
      max-width: min(680px, calc(100vw - 24px));
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--calloutBorder);
      background: var(--modalHeaderBg);
      color: var(--text);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .toast.show{ display:block; }

    
.mdTableWrap{
  width:100%;
  max-width:100%;
  min-width:0;
  overflow-x:auto;
  overflow-y:hidden;
  -webkit-overflow-scrolling: touch;
  border-radius: 12px;
  border: 1px solid var(--calloutBorder);
  background: var(--panelC);
  margin: 10px 0;
  padding-bottom: 6px; /* make room for horizontal scrollbar */
}
.mdPreview table{
  width: max-content;
  min-width: 100%;
  table-layout: auto;
  border-collapse: collapse;
  margin: 0;
}
.mdPreview th, .mdPreview td{
  border: 1px solid var(--calloutBorder);
  padding: 10px 12px;
  vertical-align: top;
  white-space: normal;
  word-break: normal;
  overflow-wrap: break-word;
  min-width: 180px;
  max-width: 560px;
}
.mdPreview th{ background: var(--panelB); font-weight: 800; }
.mdPreview tr:nth-child(even) td{ background: rgba(255,255,255,.03); }
:root[data-theme="light"] .mdPreview tr:nth-child(even) td{ background: rgba(20,40,80,.04); }
/* v7.7.2: cleaner tile header layouts (User/Career) */
    .tileSubHeader{ display:flex; flex-wrap:nowrap; gap:8px; align-items:center; justify-content:flex-start; margin: 0 0 10px; overflow-x:auto; -webkit-overflow-scrolling: touch; }

    .headerActions{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-end; }
    .actionGroup{ display:flex; flex-wrap:nowrap; gap:8px; align-items:center; padding:6px 8px; border:1px solid var(--border); border-radius:12px; background: var(--panelB); overflow-x:auto; -webkit-overflow-scrolling: touch; }
    .actionLabel{ font-size:12px; color: var(--muted); margin-right:2px; }
    .headerActions select{ min-width: 220px; max-width: 320px; }
    .actionGroup select{ min-width: 190px; max-width: 280px; }
    .fieldRow{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-top:10px; padding:10px 12px; border:1px solid var(--border); border-radius:12px; background: var(--panelB); }
    .fieldRow label{ font-size:12px; color: var(--muted); }


    /* v7.7.4: keep User/Career controls on a single row */
    .tileSubHeader::-webkit-scrollbar,
    .actionGroup::-webkit-scrollbar{ height:6px; }
    .tileSubHeader::-webkit-scrollbar-thumb,
    .actionGroup::-webkit-scrollbar-thumb{ background: rgba(120,140,180,.35); border-radius:999px; }
    :root[data-theme="light"] .tileSubHeader::-webkit-scrollbar-thumb,
    :root[data-theme="light"] .actionGroup::-webkit-scrollbar-thumb{ background: rgba(40,60,100,.18); }
    .actionGroup .btn{ white-space:nowrap; }
    


    /* v7.7.11: Drag-and-drop reordering (Setup lists only) */
    .item.sortable{ justify-content:flex-start; }
    .item.sortable .actions{ margin-left:auto; }
    .dragHandle{
      width: 26px;
      min-width: 26px;
      height: 26px;
      margin-top: 2px;
      margin-right: 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--panelB);
      display:flex;
      align-items:center;
      justify-content:center;
      color: var(--muted);
      cursor: grab;
      user-select: none;
    }
    .dragHandle:active{ cursor: grabbing; }
    .item.sortable.dragging{ opacity: .55; }
    
</style>
</head>

<body>
  <div class="app">
    <header>
      <div class="title">
        <div class="titleRow">
          <h1>Prompt Builder</h1>
          <button class="modeChip" id="btnSyncProvider" title="Toggle Offline and Online">
            <span class="dot" aria-hidden="true"></span>
            <span class="label">Offline</span>
          </button>

          <div class="modeGroup" id="onlineModeGroup" style="display:none;">
            <button class="modeChip" id="btnSyncOnlineMode" title="Toggle Auto and Manual">
              <span class="label">Auto</span>
            </button>
            <button class="modeChip iconOnly" id="btnSyncSettings" title="Sync settings">
              <span class="label">⚙</span>
            </button>
          </div>
        </div>
        <div class="sub" id="syncSubText">Offline · Local cache</div>
      </div>
      <div class="tabs" role="tablist" aria-label="Main Tabs">
        <button class="tab active" id="tabSetup" aria-selected="true">Setup</button>
        <button class="tab" id="tabPrompt" aria-selected="false">Prompt</button>
      </div>
    </header>

    <div class="topbar">
<div class="chip">
        <label>Data</label>
        <button class="btn mini" id="btnExportLogs">Export Change Log (CSV)</button>
        <button class="btn mini" id="btnExportSnapshot">Export Snapshot (JSON)</button>
        <button class="btn mini" id="btnImportSnapshot">Import Snapshot (JSON)</button>
        <button class="btn mini danger" id="btnWipeImportSnapshot" title="Delete all local data and replace it with the selected JSON snapshot">Wipe Local and Import JSON</button>
      </div>

      <div class="chip">
        <label>Theme</label>
        <button class="btn mini" id="btnToggleTheme">Light mode</button>
      </div>

      <div class="chip" style="margin-left:auto;">
        <label>About</label>
        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
          <span class="pill" id="appVersionPill" title="App version">v37.2</span>
          <button class="btn mini" id="btnHardRefresh" title="Hard refresh (bypass cache)">↻</button>
        </div>
      </div>

    </div>

    <!-- Setup Page -->
    <main id="pageSetup">
      <div class="grid">
        <section class="card">
          <h2>
            <span>Prompts <span class="pill">Global</span></span>
            <button class="btn primary" id="btnAddPrompt">Add</button>
          </h2>
          <div class="muted">Reusable prompt blocks (Markdown). Shared across all users.</div>
          <div class="divider"></div>
          <div class="list" id="listPrompts"></div>
          <div class="hint" id="hintPrompts" style="display:none;">No items yet. Click Add to create your first prompt block.</div>
        </section>

        <section class="card">
          <h2>
            <span>Personal Info</span>
            <button class="btn primary" id="btnAddPersonal">Add Item</button>
          </h2>
          <div class="tileSubHeader">
            <div class="actionGroup">
              <span class="actionLabel">User</span>
              <select id="userSelect"></select>
              <button class="btn mini" id="btnAddUser">Add</button>
              <button class="btn mini" id="btnRenameUser">Rename</button>
              <button class="btn mini danger" id="btnDeleteUser">Delete</button>
            </div>
          </div>
          <div class="fieldRow" id="personalCareerPickRow">
            <label for="personalCareerPick">User Career</label>
            <select id="personalCareerPick" style="min-width:260px;"></select>
          </div>
          <div class="divider"></div>
          <div class="list" id="listPersonal"></div>
          <div class="hint" id="hintPersonal" style="display:none;">No items for this user yet. Click Add to create.</div>
        </section>

        <section class="card">
          <h2>
            <span>Career Info</span>
            <button class="btn primary" id="btnAddCareerBlock">Add Item</button>
          </h2>
          <div class="tileSubHeader">
            <div class="actionGroup">
              <span class="actionLabel">Career</span>
              <select id="careerFilter"></select>
              <button class="btn mini" id="btnAddCareerTop">Add</button>
              <button class="btn mini" id="btnRenameCareer">Rename</button>
              <button class="btn mini danger" id="btnDeleteCareer">Delete</button>
            </div>
          </div>
          <div class="divider"></div>
          <div style="margin-top:10px;">
            <div class="list" id="listCareerBlocks"></div>
            <div class="hint" id="hintCareerBlocks" style="display:none;">No items for this career yet. Click Add to create.</div>
          </div>
        </section>

        <section class="card">
          <h2>
            <span>Connection <span class="pill">Global</span></span>
            <button class="btn primary" id="btnAddConnection">Add</button>
          </h2>
          <div class="muted">
            Global connections. Each connection can select items from Prompt, Personal Info, and Career Info.
            When you view/copy in the Prompt tab, it compiles using the current user and that user’s selected career.
            If a selected Personal/Career item has no content for the current user/career, the title is kept and the content is empty (you’ll see an “Empty” warning).
          </div>
          <div class="divider"></div>
          <div class="list" id="listConnections"></div>
          <div class="hint" id="hintConnections" style="display:none;">No connections yet. Click Add to create.</div>
        </section>
      </div>
    </main>

    <!-- Prompt Page -->
    <main id="pagePrompt" style="display:none;">
      <section class="card">
        <h2 style="margin:0 0 6px;">Prompt</h2>
        <div class="muted">Read only. Choose a user and career above to compile prompts per Connection.</div>
        <div class="divider"></div>

        <div class="row" style="justify-content:space-between; gap:10px; align-items:center; margin: 6px 0 12px; flex-wrap:wrap;">
          <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
            <div class="chip" style="padding:8px 10px; box-shadow:none;">
              <label>Current User</label>
              <select id="promptUserSelect" style="min-width:220px;"></select>
            </div>
            <div class="chip" style="padding:8px 10px; box-shadow:none;">
              <label>User Career</label>
              <select id="promptUserCareerSelect" style="min-width:260px;"></select>
            </div>
            <div class="chip" style="padding:8px 10px; box-shadow:none;">
              <label>Current Career</label>
              <select id="promptCurrentCareerSelect" style="min-width:260px;"></select>
            </div>
          </div>
</div>
        <div id="promptEmpty" class="hint" style="display:none;">
          No Connections found. Create them in Setup.
        </div>
        <div class="list" id="promptConnections"></div>
      </section>
    </main>

    <!-- Modal -->
    <div class="modalOverlay" id="modalOverlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <header class="modalHeader">
          <div class="modalHeaderLeft">
            <h3 id="modalTitle" style="margin:0; font-size: 14px;">Edit</h3>
            <div id="modalHeaderActions" class="row" style="gap:8px;"></div>
          </div>
          <button class="btn ghost mini" id="btnCloseModal" aria-label="Close">✕</button>
        </header>
        <div id="modalBody"></div>
        <div class="footer" id="modalFooter" style="display:flex; justify-content:flex-end; gap:10px; margin-top:12px;"></div>
      </div>
    </div>

    <input type="file" id="fileImportSnapshot" accept="application/json" style="display:none;" />
    <input type="file" id="fileImportSnapshotWipe" accept="application/json" style="display:none;" />
    <div class="toast" id="toast" aria-live="polite"></div>
  </div>

<script src="https://alcdn.msauth.net/browser/2.35.0/js/msal-browser.min.js" crossorigin="anonymous"></script>
<script>
/** ========= Utilities ========= */
const $ = (sel) => document.querySelector(sel);
const nowISO = () => new Date().toISOString();
const formatLocal = (iso) => { try { return new Date(iso).toLocaleString(); } catch { return iso; } };
const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : ('id_' + Math.random().toString(16).slice(2) + '_' + Date.now()));
const escapeCsv = (v) => {
  const s = String(v ?? "");
  if (/[",\n\r]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
  return s;
};
const downloadText = (filename, text, mime='text/plain') => {
  const blob = new Blob([text], { type: mime });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(a.href);
};
const copyToClipboard = async (text) => {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.focus(); ta.select();
    try {
      const ok = document.execCommand('copy');
      ta.remove();
      return ok;
    } catch {
      ta.remove();
      return false;
    }
  }
};


/** ========= Theme ========= */
function setTheme(theme) {
  const t = (theme === 'light') ? 'light' : 'dark';
  document.documentElement.dataset.theme = t;
  localStorage.setItem('mivida_theme', t);
  const btn = $('#btnToggleTheme');
  if (btn) btn.textContent = (t === 'light') ? 'Dark mode' : 'Light mode';
}
function initTheme() {
  const saved = localStorage.getItem('mivida_theme');
  const t = saved ? saved : 'dark';
  setTheme(t);
}

function toast(msg, ms=2200){
  const el = document.getElementById('toast');
  if (!el) { alert(msg); return; }
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toast._t);
  toast._t = setTimeout(() => el.classList.remove('show'), ms);
}

function txComplete(tx){
  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error || new Error('Transaction error'));
    tx.onabort = () => reject(tx.error || new Error('Transaction aborted'));
  });
}

async function safeGetAll(storeName){
  try { return await getAll(storeName); } catch { return []; }
}

/** ========= Minimal safe Markdown renderer (no external libs) ========= */
function escapeHtml(s){
  return String(s ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#039;');
}
function renderMarkdown(md){
  const lines = String(md ?? '').replace(/\r\n/g,'\n').split('\n');

  let html = '';
  let inCode = false;
  let codeBuf = [];
  let paraBuf = [];

  // Nested list stack: [{type:'ul'|'ol', indent:number, liOpen:boolean}]
  let listStack = [];

  const BR_TOKEN = '%%__BR__%%';

  const inlineFmt = (raw) => {
    let s = String(raw ?? '');

    // Allow <br> tags inside markdown (especially for tables)
    s = s.replace(/<br\s*\/?>/gi, BR_TOKEN);

    // Split by backticks for inline code (GFM-ish)
    const parts = s.split('`');
    let out = '';
    for (let k = 0; k < parts.length; k++){
      const seg = parts[k];
      if (k % 2 === 1){
        out += `<code>${escapeHtml(seg)}</code>`;
        continue;
      }
      let t = escapeHtml(seg);

      // Bold **text**
      t = t.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
      // Italic *text* (avoid **)
      t = t.replace(/\*(?!\*)([^*]+?)\*(?!\*)/g, '<em>$1</em>');

      out += t;
    }

    // Restore <br>
    out = out.split(BR_TOKEN).join('<br>');
    return out;
  };

  const flushPara = () => {
    if (!paraBuf.length) return;
    const text = paraBuf.join(' ').trim();
    if (text) html += `<p>${inlineFmt(text)}</p>`;
    paraBuf = [];
  };

  const closeAllLists = () => {
    while (listStack.length){
      const top = listStack.pop();
      if (top.liOpen) html += `</li>`;
      html += top.type === 'ul' ? `</ul>` : `</ol>`;
    }
  };

  const closeListsToIndent = (indent) => {
    while (listStack.length && indent < listStack[listStack.length - 1].indent){
      const top = listStack.pop();
      if (top.liOpen) html += `</li>`;
      html += top.type === 'ul' ? `</ul>` : `</ol>`;
    }
  };

  const ensureList = (type, indent) => {
    // Close deeper lists if needed
    closeListsToIndent(indent);

    if (!listStack.length){
      html += type === 'ul' ? `<ul>` : `<ol>`;
      listStack.push({ type, indent, liOpen: false });
      return;
    }

    const top = listStack[listStack.length - 1];

    // Nested list
    if (indent > top.indent){
      // Must be inside an open <li> of the parent list
      if (!top.liOpen){
        // If no open li, open an empty one to nest under (rare edge case)
        html += `<li>`;
        top.liOpen = true;
      }
      html += type === 'ul' ? `<ul>` : `<ol>`;
      listStack.push({ type, indent, liOpen: false });
      return;
    }

    // Same indent: switch list type if needed
    if (top.indent === indent && top.type !== type){
      if (top.liOpen) html += `</li>`;
      html += top.type === 'ul' ? `</ul>` : `</ol>`;
      listStack.pop();

      html += type === 'ul' ? `<ul>` : `<ol>`;
      listStack.push({ type, indent, liOpen: false });
      return;
    }

    // Same type, same indent: nothing to do
  };

  const startListItem = (type, indent, content) => {
    flushPara();
    ensureList(type, indent);

    const top = listStack[listStack.length - 1];

    // Close previous <li> in the same list
    if (top.liOpen) html += `</li>`;
    html += `<li>${inlineFmt(content)}`;
    top.liOpen = true;
  };

  const splitTableRow = (rowRaw) => {
    const s0 = String(rowRaw ?? '').trim();
    const leadingPipe = s0.startsWith('|');
    const trailingPipe = s0.endsWith('|');

    const cells = [];
    let cur = '';
    for (let i = 0; i < s0.length; i++){
      const ch = s0[i];
      if (ch === '\\' && s0[i+1] === '|'){
        cur += '|';
        i++;
        continue;
      }
      if (ch === '|'){
        cells.push(cur.trim());
        cur = '';
        continue;
      }
      cur += ch;
    }
    cells.push(cur.trim());

    if (leadingPipe) cells.shift();
    if (trailingPipe) cells.pop();

    return cells.map(c => c.trim());
  };

  const parseTableAlign = (sepLine, colCount) => {
    const parts = splitTableRow(sepLine);
    const aligns = [];
    for (let i = 0; i < colCount; i++){
      const cell = (parts[i] ?? '').trim().replace(/\s+/g,'');
      const plain = cell.replace(/:/g,'');
      const ok = /^-{2,}$/.test(plain);
      if (!ok) return null;

      const left = cell.startsWith(':');
      const right = cell.endsWith(':');
      if (left && right) aligns.push('center');
      else if (right) aligns.push('right');
      else aligns.push('left');
    }
    return aligns;
  };

  const isPotentialTableHeader = (line) => {
    const t = String(line ?? '').trim();
    return t.includes('|');
  };

  const normalizeRow = (cells, count) => {
    const out = cells.slice(0, count);
    while (out.length < count) out.push('');
    return out;
  };

  let i = 0;
  while (i < lines.length){
    const raw = lines[i];

    // Code fence
    if (raw.trim().startsWith('```')) {
      if (!inCode) {
        flushPara(); closeAllLists();
        inCode = true; codeBuf = [];
      } else {
        const code = escapeHtml(codeBuf.join('\n'));
        html += `<pre><code>${code}</code></pre>`;
        inCode = false; codeBuf = [];
      }
      i++;
      continue;
    }
    if (inCode) { codeBuf.push(raw); i++; continue; }

    const rawRight = raw.trimRight();
    const lead = rawRight.match(/^\s*/)?.[0] ?? '';
    const indent = lead.length;
    const line = rawRight; // keep leading spaces for list nesting decisions

    // Blank line
    if (!line.trim()){
      flushPara();
      // Keep list contexts open across blank lines so ordered lists don't restart.
      // (Markdown allows blank lines between list items and between a parent item and its nested list.)
      i++;
      continue;
    }

    // Table (GFM-ish): header line + separator line
    if (isPotentialTableHeader(line) && i + 1 < lines.length){
      const sep = lines[i+1].trimRight();
      const headerCells = splitTableRow(line);
      const aligns = parseTableAlign(sep, headerCells.length);
      if (aligns) {
        flushPara(); closeAllLists();

        const rows = [];
        let j = i + 2;
        while (j < lines.length){
          const rowLine = lines[j].trimRight();
          if (!rowLine.trim()) break;
          if (!rowLine.includes('|')) break;
          if (parseTableAlign(rowLine, headerCells.length)) break;

          rows.push(normalizeRow(splitTableRow(rowLine), headerCells.length));
          j++;
        }

        html += `<div class="mdTableWrap"><table class="mdTable"><thead><tr>`;
        for (let c = 0; c < headerCells.length; c++){
          const a = aligns[c] || 'left';
          html += `<th style="text-align:${a}">${inlineFmt(headerCells[c])}</th>`;
        }
        html += `</tr></thead>`;

        if (rows.length){
          html += `<tbody>`;
          for (const r of rows){
            html += `<tr>`;
            for (let c = 0; c < headerCells.length; c++){
              const a = aligns[c] || 'left';
              html += `<td style="text-align:${a}">${inlineFmt(r[c])}</td>`;
            }
            html += `</tr>`;
          }
          html += `</tbody>`;
        }

        html += `</table></div>`;
        i = j;
        continue;
      }
    }

    // Blockquote
    if (line.trim().startsWith('> ')) {
      flushPara(); closeAllLists();
      html += `<blockquote>${inlineFmt(line.trim().slice(2))}</blockquote>`;
      i++;
      continue;
    }

    // Headings
    const mH = line.match(/^\s*(#{1,6})\s+(.+)$/);
    if (mH) {
      flushPara(); closeAllLists();
      const level = mH[1].length;
      html += `<h${level}>${inlineFmt(mH[2])}</h${level}>`;
      i++;
      continue;
    }

    // Unordered list item (supports indentation and •)
    const mUl = line.match(/^\s*[-*+•]\s+(.+)$/);
    if (mUl) {
      startListItem('ul', indent, mUl[1]);
      i++;
      continue;
    }

    // Ordered list item (supports indentation)
    const mOl = line.match(/^\s*\d+\.\s+(.+)$/);
    if (mOl) {
      startListItem('ol', indent, mOl[1]);
      i++;
      continue;
    }

    // Non-list content
    if (listStack.length){
      // If this line is indented more than the current list level, treat as continuation inside <li>
      const top = listStack[listStack.length - 1];
      if (indent > top.indent){
        // add as a line inside current li
        html += `<div class="mdLiCont">${inlineFmt(line.trim())}</div>`;
        i++;
        continue;
      }
      // otherwise, end lists and treat as paragraph
      closeAllLists();
    }

    paraBuf.push(line.trim());
    i++;
  }

  // finalize
  if (inCode) {
    const code = escapeHtml(codeBuf.join('\n'));
    html += `<pre><code>${code}</code></pre>`;
  }
  closeAllLists();
  flushPara();
  return html;
}


/** ========= IndexedDB ========= */
const DB_NAME = 'mivida_prompt_builder_offline';
const DB_VERSION = 3;

let dbPromise = null;

function openDB() {
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);

    req.onupgradeneeded = (e) => {
      const db = req.result;
      const tx = req.transaction;
      const oldVersion = e.oldVersion || 0;

      // v1 stores
      if (oldVersion < 1) {
        const users = db.createObjectStore('users', { keyPath: 'id' });
        users.createIndex('by_name', 'name', { unique: false });

        const prompts = db.createObjectStore('promptItems', { keyPath: 'id' });
        prompts.createIndex('by_updatedAt', 'updatedAt', { unique: false });

        const personal = db.createObjectStore('personalItems', { keyPath: 'id' });
        personal.createIndex('by_userId', 'userId', { unique: false });

        db.createObjectStore('userCareer', { keyPath: 'userId' });

        const connections = db.createObjectStore('connections', { keyPath: 'id' });
        connections.createIndex('by_updatedAt', 'updatedAt', { unique: false });

        const logs = db.createObjectStore('changeLogs', { keyPath: 'id' });
        logs.createIndex('by_timestamp', 'timestamp', { unique: false });
      } else {
        // ensure missing indexes for safety
        if (!db.objectStoreNames.contains('changeLogs')) {
          const logs = db.createObjectStore('changeLogs', { keyPath: 'id' });
          logs.createIndex('by_timestamp', 'timestamp', { unique: false });
        }
      }

      // v2: careers + careerBlocks
      if (!db.objectStoreNames.contains('careers')) {
        const careers = db.createObjectStore('careers', { keyPath: 'id' });
        careers.createIndex('by_title', 'title', { unique: false });
        careers.createIndex('by_updatedAt', 'updatedAt', { unique: false });
      }
      if (!db.objectStoreNames.contains('careerBlocks')) {
        const blocks = db.createObjectStore('careerBlocks', { keyPath: 'id' });
        blocks.createIndex('by_careerId', 'careerId', { unique: false });
        blocks.createIndex('by_careerId_updatedAt', ['careerId', 'updatedAt'], { unique: false });
      }

      // Migration (best effort): old 'careerItems' -> careers + careerBlocks(Main)
      if (oldVersion < 2) {
        if (db.objectStoreNames.contains('careerItems')) {
          const oldStore = tx.objectStore('careerItems');
          const getAllReq = oldStore.getAll();
          getAllReq.onsuccess = () => {
            const oldRows = getAllReq.result || [];
            const careersStore = tx.objectStore('careers');
            const blocksStore = tx.objectStore('careerBlocks');

            oldRows.forEach((c) => {
              const career = {
                id: c.id,
                title: c.title || '(Career)',
                createdAt: c.createdAt || nowISO(),
                updatedAt: c.updatedAt || c.createdAt || nowISO()
              };
              careersStore.put(career);

              const block = {
                id: uid(),
                careerId: c.id,
                title: 'Main',
                content: c.content || '',
                createdAt: career.createdAt,
                updatedAt: career.updatedAt
              };
              blocksStore.add(block);
            });
          };
        }

        // Migration: old per-user connections -> global: keep promptItemIds, drop personal selection/userId
        if (db.objectStoreNames.contains('connections')) {
          const connStore = tx.objectStore('connections');
          const reqAll = connStore.getAll();
          reqAll.onsuccess = () => {
            const rows = reqAll.result || [];
            rows.forEach((r) => {
              const migrated = {
                id: r.id,
                title: r.title || '',
                promptItemIds: r.promptItemIds || [],
                createdAt: r.createdAt || nowISO(),
                updatedAt: r.updatedAt || r.createdAt || nowISO()
              };
              connStore.put(migrated);
            });
          };
        }
      }
      // v3: Templates for Personal & Career items + per-user/per-career content
      if (oldVersion < 3) {
        const now = new Date().toISOString();
        const mkId = () => (self.crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2));

        if (!db.objectStoreNames.contains('personalTemplates')) {
          const st = db.createObjectStore('personalTemplates', { keyPath: 'id' });
          st.createIndex('by_title', 'title', { unique: false });
          st.createIndex('by_updatedAt', 'updatedAt', { unique: false });
        }
        if (!db.objectStoreNames.contains('personalContent')) {
          const sc = db.createObjectStore('personalContent', { keyPath: ['userId', 'templateId'] });
          sc.createIndex('by_userId', 'userId', { unique: false });
          sc.createIndex('by_templateId', 'templateId', { unique: false });
          sc.createIndex('by_userId_updatedAt', ['userId', 'updatedAt'], { unique: false });
        }

        if (!db.objectStoreNames.contains('careerTemplates')) {
          const ct = db.createObjectStore('careerTemplates', { keyPath: 'id' });
          ct.createIndex('by_title', 'title', { unique: false });
          ct.createIndex('by_updatedAt', 'updatedAt', { unique: false });
        }
        if (!db.objectStoreNames.contains('careerContent')) {
          const cc = db.createObjectStore('careerContent', { keyPath: ['careerId', 'templateId'] });
          cc.createIndex('by_careerId', 'careerId', { unique: false });
          cc.createIndex('by_templateId', 'templateId', { unique: false });
          cc.createIndex('by_careerId_updatedAt', ['careerId', 'updatedAt'], { unique: false });
        }

        // Migration: personalItems (per-user) -> personalTemplates (global) + personalContent (per-user)
        try {
          if (db.objectStoreNames.contains('personalItems')) {
            const oldStore = tx.objectStore('personalItems');
            const tplStore = tx.objectStore('personalTemplates');
            const contentStore = tx.objectStore('personalContent');

            const reqAll = oldStore.getAll();
            reqAll.onsuccess = () => {
              const rows = reqAll.result || [];
              const titleToTpl = new Map();

              // create templates (unique by title)
              rows.forEach(r => {
                const title = (r.title || '').trim();
                if (!title) return;
                if (!titleToTpl.has(title)) {
                  titleToTpl.set(title, {
                    id: mkId(),
                    title,
                    createdAt: r.createdAt || now,
                    updatedAt: r.updatedAt || r.createdAt || now
                  });
                } else {
                  // keep latest updatedAt
                  const tpl = titleToTpl.get(title);
                  const u = r.updatedAt || r.createdAt || now;
                  if ((tpl.updatedAt || '') < u) tpl.updatedAt = u;
                }
              });

              titleToTpl.forEach(tpl => tplStore.put(tpl));

              // create content rows
              rows.forEach(r => {
                const title = (r.title || '').trim();
                const tpl = titleToTpl.get(title);
                if (!tpl) return;
                contentStore.put({
                  userId: r.userId,
                  templateId: tpl.id,
                  content: r.content || '',
                  createdAt: r.createdAt || now,
                  updatedAt: r.updatedAt || r.createdAt || now
                });
              });
            };
          }
        } catch (err) { /* best effort */ }

        // Migration: careerBlocks (per-career) -> careerTemplates (global) + careerContent (per-career)
        try {
          if (db.objectStoreNames.contains('careerBlocks')) {
            const oldStore = tx.objectStore('careerBlocks');
            const tplStore = tx.objectStore('careerTemplates');
            const contentStore = tx.objectStore('careerContent');

            const reqAll = oldStore.getAll();
            reqAll.onsuccess = () => {
              const rows = reqAll.result || [];
              const titleToTpl = new Map();

              rows.forEach(r => {
                const title = (r.title || '').trim();
                if (!title) return;
                if (!titleToTpl.has(title)) {
                  titleToTpl.set(title, {
                    id: mkId(),
                    title,
                    createdAt: r.createdAt || now,
                    updatedAt: r.updatedAt || r.createdAt || now
                  });
                } else {
                  const tpl = titleToTpl.get(title);
                  const u = r.updatedAt || r.createdAt || now;
                  if ((tpl.updatedAt || '') < u) tpl.updatedAt = u;
                }
              });

              titleToTpl.forEach(tpl => tplStore.put(tpl));

              rows.forEach(r => {
                const title = (r.title || '').trim();
                const tpl = titleToTpl.get(title);
                if (!tpl) return;
                contentStore.put({
                  careerId: r.careerId,
                  templateId: tpl.id,
                  content: r.content || '',
                  createdAt: r.createdAt || now,
                  updatedAt: r.updatedAt || r.createdAt || now
                });
              });
            };
          }
        } catch (err) { /* best effort */ }

        // Normalize: ensure connections have arrays for all categories
        try {
          if (db.objectStoreNames.contains('connections')) {
            const connStore = tx.objectStore('connections');
            const reqAll = connStore.getAll();
            reqAll.onsuccess = () => {
              const rows = reqAll.result || [];
              rows.forEach(r => {
                const patched = {
                  ...r,
                  promptItemIds: r.promptItemIds || [],
                  personalTemplateIds: r.personalTemplateIds || [],
                  careerTemplateIds: r.careerTemplateIds || [],
                  updatedAt: r.updatedAt || r.createdAt || now
                };
                connStore.put(patched);
              });
            };
          }
        } catch (err) { /* best effort */ }
      }

    };

    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return dbPromise;
}

async function withStore(storeName, mode, fn) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, mode);
    const store = tx.objectStore(storeName);
    const res = fn(store, tx);
    tx.oncomplete = () => resolve(res);
    tx.onerror = () => reject(tx.error);
    tx.onabort = () => reject(tx.error);
  });
}
async function getAll(storeName) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const req = store.getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
async function getOne(storeName, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result ?? null);
    req.onerror = () => reject(req.error);
  });
}
async function putOne(storeName, value) { return withStore(storeName, 'readwrite', (s) => s.put(value)); }
async function addOne(storeName, value) { return withStore(storeName, 'readwrite', (s) => s.add(value)); }
async function deleteOne(storeName, key) { return withStore(storeName, 'readwrite', (s) => s.delete(key)); }

async function getByIndex(storeName, indexName, query) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const idx = store.index(indexName);
    const req = idx.getAll(query);
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

/** ========= Change Log ========= */
async function logChange({ entityType, entityId, action, after, before=null }) {
  const row = { id: uid(), timestamp: nowISO(), entityType, entityId, action, after, before };
  await addOne('changeLogs', row);
}

/** ========= State ========= */
const state = { currentUserId: null, currentCareerId: null, promptCareerId: '', activeTab: 'setup' };
// NOTE: promptCareerId is kept for backward compatibility, but is always synced to currentCareerId.

/** ========= UI Sort (local-only, affects Setup lists only) ========= */
const UI_SORT_STORAGE_KEY = 'mivida_uiSort_v1';
let uiSort = (() => {
  try {
    const raw = localStorage.getItem(UI_SORT_STORAGE_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    return (obj && typeof obj === 'object') ? obj : {};
  } catch {
    return {};
  }
})();
function saveUiSort(){
  try { localStorage.setItem(UI_SORT_STORAGE_KEY, JSON.stringify(uiSort || {})); } catch {}
}
function getUiOrder(sortKey){
  const v = uiSort?.[sortKey];
  return Array.isArray(v) ? v : null;
}
function setUiOrder(sortKey, ids){
  uiSort = uiSort || {};
  uiSort[sortKey] = Array.isArray(ids) ? ids : [];
  saveUiSort();
}
function applyUiOrder(items, sortKey, getId, fallbackSortFn){
  const arr = [...(items || [])];
  const order = getUiOrder(sortKey);
  if (!order || order.length === 0){
    if (fallbackSortFn) arr.sort(fallbackSortFn);
    return arr;
  }
  const idx = new Map(order.map((id,i) => [id, i]));
  arr.sort((a,b) => {
    const ia = idx.has(getId(a)) ? idx.get(getId(a)) : 1e9;
    const ib = idx.has(getId(b)) ? idx.get(getId(b)) : 1e9;
    if (ia !== ib) return ia - ib;
    return fallbackSortFn ? fallbackSortFn(a,b) : 0;
  });

  // keep order list healthy: remove deleted ids, append new ids
  const ids = arr.map(getId).filter(Boolean);
  const set = new Set(ids);
  const cleaned = order.filter(id => set.has(id));
  const cleanedSet = new Set(cleaned);
  for (const id of ids){
    if (!cleanedSet.has(id)) cleaned.push(id);
  }
  if (cleaned.length !== order.length || cleaned.some((v,i) => v !== order[i])){
    setUiOrder(sortKey, cleaned);
  }

  return arr;
}

function applyUiSortFromSnapshot(sortObj, mode='merge'){
  if (!sortObj || typeof sortObj !== 'object') return;
  if (mode === 'replace') uiSort = {};
  uiSort = uiSort || {};
  for (const k of Object.keys(sortObj)){
    const arr = sortObj[k];
    if (Array.isArray(arr)) uiSort[k] = arr;
  }
  saveUiSort();
}

let dragCtx = null; // { sortKey, el }
function initSortableList(listEl, sortKey){
  if (!listEl || listEl.dataset.sortInit === '1') return;
  listEl.dataset.sortInit = '1';
  listEl.dataset.sortKey = sortKey;

  listEl.addEventListener('dragover', (e) => {
    if (!dragCtx || dragCtx.sortKey !== sortKey) return;
    e.preventDefault();
    const after = getDragAfterElement(listEl, e.clientY);
    if (!after) listEl.appendChild(dragCtx.el);
    else listEl.insertBefore(dragCtx.el, after);
  });

  listEl.addEventListener('drop', (e) => {
    if (!dragCtx || dragCtx.sortKey !== sortKey) return;
    e.preventDefault();
    finalizeSort(listEl, sortKey);
  });

  listEl.addEventListener('dragend', () => {
    if (dragCtx && dragCtx.sortKey === sortKey) cleanupDrag();
  });
}
function getDragAfterElement(container, y){
  const items = [...container.querySelectorAll('.item.sortable:not(.dragging)')];
  let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
  for (const child of items){
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height/2;
    if (offset < 0 && offset > closest.offset){
      closest = { offset, element: child };
    }
  }
  return closest.element;
}
function cleanupDrag(){
  if (dragCtx?.el) dragCtx.el.classList.remove('dragging');
  dragCtx = null;
}
function finalizeSort(listEl, sortKey){
  const ids = [...listEl.querySelectorAll('.item.sortable')]
    .map(el => el.dataset.sortId)
    .filter(Boolean);
  setUiOrder(sortKey, ids);
  cleanupDrag();
  toast('Order saved');
}
function makeRowSortable(rowEl, { sortKey, id }){
  if (!rowEl) return rowEl;
  rowEl.classList.add('sortable');
  rowEl.dataset.sortId = id;

  const handle = document.createElement('div');
  handle.className = 'dragHandle';
  handle.textContent = '⠿';
  handle.title = 'Drag to reorder';
  handle.setAttribute('draggable', 'true');

  handle.addEventListener('dragstart', (e) => {
    dragCtx = { sortKey, el: rowEl };
    rowEl.classList.add('dragging');
    try {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', String(id || ''));
    } catch {}
  });
  handle.addEventListener('dragend', () => cleanupDrag());

  rowEl.insertBefore(handle, rowEl.firstChild);
  return rowEl;
}



function setTab(tab){
  state.activeTab = tab;
  const isSetup = (tab === 'setup');
  const pageSetup = $('#pageSetup');
  const pagePrompt = $('#pagePrompt');
  if (pageSetup) pageSetup.style.display = isSetup ? '' : 'none';
  if (pagePrompt) pagePrompt.style.display = isSetup ? 'none' : '';

  const tSetup = $('#tabSetup');
  const tPrompt = $('#tabPrompt');
  if (tSetup) {
    tSetup.classList.toggle('active', isSetup);
    tSetup.setAttribute('aria-selected', isSetup ? 'true' : 'false');
  }
  if (tPrompt) {
    tPrompt.classList.toggle('active', !isSetup);
    tPrompt.setAttribute('aria-selected', !isSetup ? 'true' : 'false');
  }

  // When entering Prompt tab, ensure it renders latest compiled output.
  if (!isSetup) {
    Promise.resolve(renderPromptPickers()).then(() => renderPromptPage()).catch((e) => { console.error(e); toast('Failed to render Prompt tab'); });
  }
}
/** ========= Modal helpers ========= */
function openModal(title, bodyEl, footerButtons=[], headerButtons=[], opts={}) {
  const overlay = $('#modalOverlay');
  const modalBox = overlay ? overlay.querySelector('.modal') : null;

  // Reset modal mode
  if (overlay) overlay.classList.remove('fullscreen');
  if (modalBox) modalBox.classList.remove('fullscreen');

  // Apply mode
  if (opts && opts.fullscreen) {
    if (overlay) overlay.classList.add('fullscreen');
    if (modalBox) modalBox.classList.add('fullscreen');
  }

  $('#modalTitle').textContent = title;

  const headerAct = $('#modalHeaderActions');
  if (headerAct) {
    headerAct.innerHTML = '';
    headerButtons.forEach(b => headerAct.appendChild(b));
  }

  const body = $('#modalBody');
  body.innerHTML = '';
  body.appendChild(bodyEl);

  const footer = $('#modalFooter');
  footer.innerHTML = '';
  footerButtons.forEach(b => footer.appendChild(b));
  footer.style.display = footerButtons.length ? 'flex' : 'none';

  if (overlay) {
    overlay.classList.add('open');
    overlay.setAttribute('aria-hidden', 'false');
  }
}
function closeModal() {
  const overlay = $('#modalOverlay');
  const modalBox = overlay ? overlay.querySelector('.modal') : null;

  if (overlay) {
    overlay.classList.remove('open');
    overlay.classList.remove('fullscreen');
    overlay.setAttribute('aria-hidden', 'true');
  }
  if (modalBox) modalBox.classList.remove('fullscreen');

  const headerAct = $('#modalHeaderActions');
  if (headerAct) headerAct.innerHTML = '';

  const footer = $('#modalFooter');
  if (footer) footer.style.display = 'flex';
}
function btn(text, opts={}) {
  const b = document.createElement('button');
  b.className = 'btn' + (opts.primary ? ' primary' : '') + (opts.danger ? ' danger' : '') + (opts.ghost ? ' ghost' : '') + (opts.mini ? ' mini' : '');
  b.textContent = text;
  if (opts.onClick) b.addEventListener('click', opts.onClick);
  return b;
}

function makeOutputControl({ tpl, storeName, entityType, connections }) {
  const wrap = document.createElement('div');
  wrap.className = 'outCtrl';

  const cb = document.createElement('input');
  cb.type = 'checkbox';
  // Default behavior: output is ON unless explicitly set to false
  const currentOn = (tpl?.isOutput !== false);
  cb.checked = currentOn;

  const lbl = document.createElement('label');
  lbl.textContent = 'Output';

  const sel = document.createElement('select');
  sel.style.display = cb.checked ? '' : 'none';

  function setOptions(conns) {
    sel.innerHTML = '';

    const opAny = document.createElement('option');
    opAny.value = '';
    opAny.textContent = 'All connections';
    sel.appendChild(opAny);

    (conns || []).forEach(c => {
      const op = document.createElement('option');
      op.value = c.id;
      op.textContent = c.title || '(Untitled)';
      sel.appendChild(op);
    });

    const current = (tpl?.outputConnectionId || '');
    // If a previously selected connection no longer exists, keep it visible.
    if (current && !Array.from(sel.options).some(o => o.value === current)) {
      const op = document.createElement('option');
      op.value = current;
      op.textContent = '(Missing connection)';
      sel.appendChild(op);
    }
    sel.value = current;
  }

  // Initial populate
  if (Array.isArray(connections)) {
    setOptions(connections);
  } else {
    setOptions([], outputMeta.assignments || null);
    (async () => {
      try {
        let conns = await getAll('connections');
        conns = applyUiOrder(conns, 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
        setOptions(conns, outputMeta.assignments || null);
      } catch(e) { /* ignore */ }
    })();
  }

  async function persist() {
    const before = await getOne(storeName, tpl.id);
    const after = {
      ...(before || tpl),
      isOutput: cb.checked,
      outputConnectionId: (sel.value || ''),
      updatedAt: nowISO()
    };
    await putOne(storeName, after);
    // best-effort change log
    try {
      await logChange({ entityType, entityId: tpl.id, action: 'update', after, before });
    } catch(e) { /* ignore */ }
    await refreshAll();
  }

  cb.addEventListener('change', async () => {
    sel.style.display = cb.checked ? '' : 'none';
    await persist();
  });
  sel.addEventListener('change', async () => {
    if (!cb.checked) return;
    await persist();
  });

  wrap.appendChild(cb);
  wrap.appendChild(lbl);
  wrap.appendChild(sel);
  return wrap;
}



function makeItemRow({ title, subtitle, pills=[] }, actions=[]) {
  const wrap = document.createElement('div');
  wrap.className = 'item';
  const meta = document.createElement('div');
  meta.className = 'meta';

  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = title || '(Untitled)';

  const small = document.createElement('div');
  small.className = 'small';
  small.textContent = subtitle || '';

  meta.appendChild(name);
  meta.appendChild(small);

  if (pills.length) {
    const pillRow = document.createElement('div');
    pillRow.className = 'row';
    pills.forEach(p => {
      const sp = document.createElement('span');
      if (typeof p === 'string') {
        sp.className = 'pill';
        sp.textContent = p;
      } else {
        sp.className = 'pill' + (p?.className ? (' ' + p.className) : '');
        sp.textContent = p?.text ?? '';
      }
      pillRow.appendChild(sp);
    });
    meta.appendChild(pillRow);
  }

  const act = document.createElement('div');
  act.className = 'actions';
  actions.forEach(a => act.appendChild(a));

  wrap.appendChild(meta);
  wrap.appendChild(act);
  return wrap;
}
function inputRow(labelText, inputEl) {
  const row = document.createElement('div');
  row.className = 'formRow';
  const label = document.createElement('div');
  label.className = 'formLabel';
  label.textContent = labelText;
  row.appendChild(label);
  row.appendChild(inputEl);

  // Better alignment for multi-line controls
  if (String(inputEl?.tagName || '').toUpperCase() === 'TEXTAREA') {
    row.classList.add('top');
  }
  return row;
}

/** ========= Bootstrap ========= */
async function ensureSeed() {
  const users = await getAll('users');
  if (!users.length) {
    const me = { id: uid(), name: 'Me', createdAt: nowISO(), updatedAt: nowISO() };
    await addOne('users', me);
    await logChange({ entityType: 'user', entityId: me.id, action: 'create', after: me });
  }
}

/** ========= Users ========= */
async function loadUsersIntoSelect() {
  const users = await getAll('users');
  users.sort((a,b) => (a.name || '').localeCompare(b.name || ''));

  const sel = $('#userSelect');
  sel.innerHTML = '';
  users.forEach(u => {
    const opt = document.createElement('option');
    opt.value = u.id;
    opt.textContent = u.name || '(Unnamed)';
    sel.appendChild(opt);
  });

  const remembered = localStorage.getItem('mivida_current_user_id');
  const pick = (remembered && users.some(u => u.id === remembered)) ? remembered : (users[0]?.id || null);
  state.currentUserId = pick;
  sel.value = pick;

  sel.onchange = async () => {
    state.currentUserId = sel.value;
    localStorage.setItem('mivida_current_user_id', state.currentUserId);
    await refreshAll();
  };
}
async function addUserFlow() {
  const name = prompt('User name?');
  if (!name) return;
  const t = nowISO();
  const row = { id: uid(), name: name.trim(), createdAt: t, updatedAt: t };
  await addOne('users', row);
  await logChange({ entityType: 'user', entityId: row.id, action: 'create', after: row });
  state.currentUserId = row.id;
  localStorage.setItem('mivida_current_user_id', row.id);
  await refreshAll();
}
async function renameUserFlow() {
  const userId = state.currentUserId;
  if (!userId) { alert('Select a user first.'); return; }
  const u = await getOne('users', userId);
  const name = prompt('New user name?', u?.name || '');
  if (!name) return;
  const before = u;
  const after = { ...u, name: name.trim(), updatedAt: nowISO() };
  await putOne('users', after);
  await logChange({ entityType: 'user', entityId: userId, action: 'update', after, before });
  await refreshAll();
}
async function deleteUserFlow() {
  const userId = state.currentUserId;
  if (!userId) { alert('Select a user first.'); return; }
  const u = await getOne('users', userId);
  const ok = confirm(`Delete user "${u?.name || ''}"?\nThis removes their Personal Info and selected career mapping.`);
  if (!ok) return;

  // delete per-user content rows (v3)
  const pc = await getByIndex('personalContent', 'by_userId', userId);
  for (const r of (pc || [])) {
    await deleteOne('personalContent', [r.userId, r.templateId]);
    await logChange({ entityType: 'personalContent', entityId: `${r.userId}:${r.templateId}`, action: 'delete', after: null, before: r });
  }

  // delete legacy per-user items too (if any exist from older versions)
  const personalsLegacy = await getByIndex('personalItems', 'by_userId', userId);
  for (const p of (personalsLegacy || [])) {
    await deleteOne('personalItems', p.id);
    await logChange({ entityType: 'personalItem', entityId: p.id, action: 'delete', after: null, before: p });
  }

  const uc = await getOne('userCareer', userId);
  if (uc) {
    await deleteOne('userCareer', userId);
    await logChange({ entityType: 'userCareer', entityId: userId, action: 'delete', after: null, before: uc });
  }

  await deleteOne('users', userId);
  await logChange({ entityType: 'user', entityId: userId, action: 'delete', after: null, before: u });

  localStorage.removeItem('mivida_current_user_id');
  state.currentUserId = null;
  await refreshAll();
}


async function setCurrentCareer(careerId) {
  state.currentCareerId = careerId || '';
  // Keep Prompt tab career in lockstep with Setup's current career
  state.promptCareerId = state.currentCareerId || '';

  try { localStorage.setItem('mivida_current_career_id', state.currentCareerId); } catch {}
  // Clear any legacy prompt-only override so it never diverges
  try { localStorage.removeItem('mivida_prompt_career_id'); } catch {}

  const sel = $('#careerFilter');
  if (sel) sel.value = state.currentCareerId;

  const pSel = $('#promptCurrentCareerSelect');
  if (pSel) pSel.value = state.currentCareerId;

  await renderCareerBlocks();

  // Keep Prompt tab in sync (safe even if the tab is currently hidden)
  try {
    await renderPromptPickers();
    await renderPromptPage();
  } catch (e) { /* ignore */ }
}

async function addCareerFlow() {
  const title = prompt('Career name?');
  if (!title) return;
  const t = nowISO();
  const row = { id: uid(), title: title.trim(), createdAt: t, updatedAt: t };
  await addOne('careers', row);
  await logChange({ entityType: 'career', entityId: row.id, action: 'create', after: row });

  // refresh the top career dropdown options, then select the new one
  await loadCareerFilterSelect();
  await setCurrentCareer(row.id);

  await renderPersonalCareerPick(); // so user career dropdown includes the new career
}

async function renameCareerFlow() {
  const careerId = state.currentCareerId;
  if (!careerId) { alert('Select a career first.'); return; }
  const c = await getOne('careers', careerId);
  const name = prompt('New career name?', c?.title || '');
  if (!name) return;

  const before = c;
  const after = { ...c, title: name.trim(), updatedAt: nowISO() };
  await putOne('careers', after);
  await logChange({ entityType: 'career', entityId: careerId, action: 'update', after, before });

  await refreshAll();
}

async function deleteCareerFlow() {
  const careerId = state.currentCareerId;
  if (!careerId) { alert('Select a career first.'); return; }
  const c = await getOne('careers', careerId);
  const ok = confirm(`Delete career "${c?.title || ''}"?\nThis will also delete all its career items and remove it from any users.`);
  if (!ok) return;

  await deleteCareer(c);

  // pick next available career (if any)
  const careers = await getAll('careers');
  careers.sort((a,b) => (a.title || '').localeCompare(b.title || ''));
  const next = careers[0]?.id || '';
  await setCurrentCareer(next);
  await renderPersonalCareerPick();
}

/** ========= Career (Edit only) ========= */
async function loadCareerFilterSelect() {
  const careers = await getAll('careers');
  careers.sort((a,b) => (a.title || '').localeCompare(b.title || ''));

  const sel = $('#careerFilter');
  sel.innerHTML = '';

  const optNone = document.createElement('option');
  optNone.value = '';
  optNone.textContent = '(Choose a career)';
  sel.appendChild(optNone);

  careers.forEach(c => {
    const opt = document.createElement('option');
    opt.value = c.id;
    opt.textContent = c.title || '(Career)';
    sel.appendChild(opt);
  });

  const remembered = localStorage.getItem('mivida_current_career_id');
  const pick = (remembered && careers.some(c => c.id === remembered)) ? remembered : (careers[0]?.id || '');
  state.currentCareerId = pick || '';
  sel.value = state.currentCareerId;

  sel.onchange = async () => {
    await setCurrentCareer(sel.value || '');
  };
}


/** ========= Output assignment helpers ========= */
async function getOutputAssignments() {
  // Map: connectionId -> { key: templateId, store: 'personalTemplates'|'careerTemplates', title }
  const [pTemps, cTemps] = await Promise.all([getAll('personalTemplates'), getAll('careerTemplates')]);
  const out = Object.create(null);

  (pTemps || []).forEach(t => {
    const cid = (t.outputConnectionId || '');
    if (cid && (t.isOutput !== false) && !out[cid]) {
      out[cid] = { key: t.id, store: 'personalTemplates', title: t.title || '(Personal Item)' };
    }
  });

  (cTemps || []).forEach(t => {
    const cid = (t.outputConnectionId || '');
    if (cid && (t.isOutput !== false) && !out[cid]) {
      out[cid] = { key: t.id, store: 'careerTemplates', title: t.title || '(Career Item)' };
    }
  });

  return out;
}

async function enforceSingleOutputPerConnection({ currentKey, connId }) {
  // Returns: { ok: boolean, conflict?: { store, row, title }, connTitle?: string }
  if (!connId) return { ok: true };

  const [pTemps, cTemps, connRow] = await Promise.all([
    getAll('personalTemplates'),
    getAll('careerTemplates'),
    getOne('connections', connId)
  ]);

  const connTitle = connRow?.title || 'this connection';

  // Find any other output item already bound to this connection
  const pHit = (pTemps || []).find(t => (t.isOutput !== false) && (t.outputConnectionId || '') === connId && t.id !== currentKey);
  if (pHit) return { ok: false, conflict: { store: 'personalTemplates', row: pHit, title: pHit.title || '(Personal Item)' }, connTitle };

  const cHit = (cTemps || []).find(t => (t.isOutput !== false) && (t.outputConnectionId || '') === connId && t.id !== currentKey);
  if (cHit) return { ok: false, conflict: { store: 'careerTemplates', row: cHit, title: cHit.title || '(Career Item)' }, connTitle };

  return { ok: true };
}

async function clearOutputLink(conflictRow, storeName) {
  const t = nowISO();
  const before = await getOne(storeName, conflictRow.id);
  const after = { ...before, isOutput: false, outputConnectionId: '', updatedAt: t };
  await putOne(storeName, after);
  await logChange({ entityType: storeName === 'personalTemplates' ? 'personalTemplate' : 'careerTemplate', entityId: after.id, action: 'update', after, before });
  return after;
}

/** ========= Generic Item Modal (Edit only) ========= */
function openEditItemModal({ title, initial, onSave, onDelete, previewLabel='Preview (rendered markdown)', outputMeta=null, contentOnly=false }) {
  const container = document.createElement('div');
  container.className = 'split';

  const left = document.createElement('div');
  const right = document.createElement('div');

  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.placeholder = 'Title';
  titleInput.value = initial?.title || '';

  if (contentOnly) {
    titleInput.readOnly = true;
    titleInput.classList.add('readOnly');
  }

  left.appendChild(inputRow('Title', titleInput));

  // Optional: Output config (only for Personal/Career items)
  let outputCb = null;
  let outputSel = null;

  if (outputMeta) {
    const outWrap = document.createElement('div');
    outWrap.className = 'outConfig';

    outputCb = document.createElement('input');
    outputCb.type = 'checkbox';
    // Default: output is ON unless explicitly set to false
    outputCb.checked = (initial?.isOutput !== false);

    const outLbl = document.createElement('span');
    outLbl.className = 'muted';
    outLbl.style.userSelect = 'none';
    outLbl.textContent = 'Mark as output';

    outputSel = document.createElement('select');
    outputSel.style.minWidth = '240px';
    outputSel.style.display = outputCb.checked ? '' : 'none';

    function setOptions(conns, assignments) {
      outputSel.innerHTML = '';

      const opAny = document.createElement('option');
      opAny.value = '';
      opAny.textContent = 'All connections';
      outputSel.appendChild(opAny);

      const myKey = (initial?.templateId || initial?.id || '');

      (conns || []).forEach(c => {
        const op = document.createElement('option');
        op.value = c.id;
        op.textContent = c.title || '(Untitled)';

        // If this connection is already used as an output by another item, tint it.
        const used = assignments && assignments[c.id] && (assignments[c.id].key !== myKey);
        if (used) {
          op.style.color = '#b42318';      // muted red
          op.style.fontWeight = '600';
        }

        outputSel.appendChild(op);
      });

      const current = (initial?.outputConnectionId || '');
      if (current && !Array.from(outputSel.options).some(o => o.value === current)) {
        const op = document.createElement('option');
        op.value = current;
        op.textContent = '(Missing connection)';
        outputSel.appendChild(op);
      }
      outputSel.value = current;
    }

    // Initial populate
    if (Array.isArray(outputMeta.connections)) {
      setOptions(outputMeta.connections, outputMeta.assignments || null);
    } else {
      setOptions([], outputMeta.assignments || null);
      (async () => {
        try {
          let conns = await getAll('connections');
          conns = applyUiOrder(conns, 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
          setOptions(conns, outputMeta.assignments || null);
        } catch(e) { /* ignore */ }
      })();
    }

    outputCb.addEventListener('change', () => {
      outputSel.style.display = outputCb.checked ? '' : 'none';
    });

    outWrap.appendChild(outputCb);
    outWrap.appendChild(outLbl);
    outWrap.appendChild(outputSel);

    left.appendChild(inputRow('Output', outWrap));
  }

  left.appendChild(document.createElement('div')).className = 'divider';

  const content = document.createElement('textarea');
  content.placeholder = 'Markdown content...';
  content.value = initial?.content || '';

  const preview = document.createElement('div');
  preview.className = 'mdPreview';
  preview.innerHTML = renderMarkdown(content.value);

  content.addEventListener('input', () => {
    preview.innerHTML = renderMarkdown(content.value);
  });


  // Content (label on its own line for better readability)
  const contentBlock = document.createElement('div');
  contentBlock.className = 'fieldBlock';

  const contentLabel = document.createElement('div');
  contentLabel.className = 'formLabel';
  contentLabel.textContent = 'Content';

  contentBlock.appendChild(contentLabel);
  contentBlock.appendChild(content);

  left.appendChild(contentBlock);

  const label = document.createElement('div');
  label.className = 'muted';
  label.textContent = previewLabel;

  right.appendChild(label);
  right.appendChild(document.createElement('div')).className = 'divider';
  right.appendChild(preview);

  container.appendChild(left);
  container.appendChild(right);

  const footerButtons = [
    btn('Save', {
      primary: true,
      onClick: async () => {
        const payload = {
          ...initial,
          title: (contentOnly ? (initial?.title || '') : titleInput.value.trim()),
          content: content.value
        };
        if (outputCb && outputSel) {
          payload.isOutput = !!outputCb.checked;
          payload.outputConnectionId = (outputSel.value || '');
        }
        const _ok = await onSave(payload);
        if (_ok === false) return;
        closeModal();
      }
    }),
    // Cancel sits at the far-right of the footer to reduce mis-click risk.
    btn('Cancel', { ghost: true, onClick: closeModal })
  ];

  const headerButtons = [];
  // Delete sits next to the modal title (header actions) to reduce mis-click risk.
  if (!contentOnly && (initial?.id || initial?.templateId)) {
    headerButtons.push(btn('Delete', {
      mini: true,
      danger: true,
      onClick: async () => {
        const ok = confirm('Delete this item?');
        if (!ok) return;
        await onDelete(initial);
        closeModal();
      }
    }));
  }

  openModal(title, container, footerButtons, headerButtons);
}

/** ========= Prompts ========= */
async function renderPrompts() {
  const list = $('#listPrompts');
  initSortableList(list, 'promptItems');
  list.innerHTML = '';

  let items = await getAll('promptItems');
  items = applyUiOrder(
    items,
    'promptItems',
    (x) => x.id,
    (a,b) => (b.updatedAt || b.createdAt).localeCompare(a.updatedAt || a.createdAt)
  );

  $('#hintPrompts').style.display = items.length ? 'none' : 'block';

  items.forEach(it => {
    const actions = [
      btn('Edit', { mini:true, onClick: () => openEditItemModal({
        title: 'Edit · Prompt Item',
        initial: it,
        onSave: savePromptItem,
        onDelete: deletePromptItem
      })})
    ];
    const row = makeItemRow({
      title: it.title,
      subtitle: `Updated: ${formatLocal(it.updatedAt || it.createdAt)}`
    }, actions);
    makeRowSortable(row, { sortKey:'promptItems', id: it.id });
    list.appendChild(row);
  });
}
async function savePromptItem(payload) {
  const t = nowISO();
  if (!payload.id) {
    const row = { id: uid(), title: payload.title || '', content: payload.content || '', createdAt: t, updatedAt: t };
    await addOne('promptItems', row);
    await logChange({ entityType: 'promptItem', entityId: row.id, action: 'create', after: row });
  } else {
    const before = await getOne('promptItems', payload.id);
    const after = { ...before, title: payload.title || '', content: payload.content || '', updatedAt: t };
    await putOne('promptItems', after);
    await logChange({ entityType: 'promptItem', entityId: after.id, action: 'update', after, before });
  }
  await refreshAll();
}
async function deletePromptItem(it) {
  const before = await getOne('promptItems', it.id);
  await deleteOne('promptItems', it.id);
  await logChange({ entityType: 'promptItem', entityId: it.id, action: 'delete', after: null, before });
  await refreshAll();
}

/** ========= Personal ========= */

async function renderPersonal() {
  const userId = state.currentUserId;
  const list = $('#listPersonal');
  initSortableList(list, 'personalTemplates');
  list.innerHTML = '';
  if (!userId) {
    $('#hintPersonal').style.display = 'block';
    return;
  }

  let [templates, contents, conns] = await Promise.all([
    getAll('personalTemplates'),
    getByIndex('personalContent', 'by_userId', userId),
    getAll('connections')
  ]);

  templates = applyUiOrder(templates, 'personalTemplates', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
  conns = applyUiOrder(conns || [], 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
  const assignments = await getOutputAssignments();
  const cMap = new Map((contents || []).map(c => [c.templateId, c]));
  $('#hintPersonal').style.display = templates.length ? 'none' : 'block';

  templates.forEach(tpl => {
    const c = cMap.get(tpl.id);
    const content = c?.content || '';
    const isEmpty = !String(content).trim();
    const updated = c?.updatedAt || tpl.updatedAt || tpl.createdAt || '';

    const actions = [
      btn('Edit', { mini:true, onClick: () => openEditItemModal({
        title: 'Edit · Personal Info Item',
        initial: { templateId: tpl.id, title: tpl.title, content, isOutput: (tpl.isOutput !== false), outputConnectionId: (tpl.outputConnectionId || '') },
        outputMeta: { connections: conns, assignments },
        onSave: savePersonalTemplateAndContent,
        onDelete: deletePersonalTemplate
      })})
    ];

    const pills = [
      ...(isEmpty ? [{ text:'Empty', className:'warn' }] : [])
    ];
    const row = makeItemRow({
      title: tpl.title,
      subtitle: isEmpty ? 'Content: (empty for this user)' : `Updated: ${formatLocal(updated)}`,
      pills
    }, actions);
    makeRowSortable(row, { sortKey:'personalTemplates', id: tpl.id });
    list.appendChild(row);
  });
}

async function savePersonalTemplateAndContent(payload) {
  const userId = state.currentUserId;
  if (!userId) { alert('Select a user first.'); return; }

  const t = nowISO();

  // Enforce: one output item per connection (across Personal + Career items).
  if (payload.isOutput && (payload.outputConnectionId || '')) {
    const currentKey = (payload.templateId || payload.id || '');
    const connId = (payload.outputConnectionId || '');
    const check = await enforceSingleOutputPerConnection({ currentKey, connId });
    if (!check.ok && check.conflict) {
      const msg =
        `This connection is already used as the output for “${check.conflict.title}”.\n\n` +
        `If you continue, the previous item’s output link will be cleared, and this item will become the output for “${check.connTitle}”.\n\n` +
        `Do you want to continue?`;
      const ok = confirm(msg);
      if (!ok) return false;

      // Clear the previous item's output relationship
      await clearOutputLink(check.conflict.row, check.conflict.store);
    }
  }

  const templateId = payload.templateId || payload.id || uid();

  const beforeTpl = await getOne('personalTemplates', templateId);
  const beforeContent = await getOne('personalContent', [userId, templateId]);

  const tpl = {
    id: templateId,
    title: (payload.title || '').trim(),
    isOutput: (payload.isOutput !== undefined ? payload.isOutput : (beforeTpl?.isOutput ?? true)),
    outputConnectionId: (payload.outputConnectionId !== undefined ? (payload.outputConnectionId || '') : (beforeTpl?.outputConnectionId || '')),
    outputMode: (beforeTpl?.outputMode || 'section'),
    createdAt: beforeTpl?.createdAt || payload.createdAt || t,
    updatedAt: t
  };
  await putOne('personalTemplates', tpl);

  const contentRow = {
    userId,
    templateId,
    content: payload.content || '',
    createdAt: beforeContent?.createdAt || payload.createdAt || t,
    updatedAt: t
  };
  await putOne('personalContent', contentRow);

  await logChange({
    entityType: 'personalTemplate',
    entityId: templateId,
    action: beforeTpl ? 'update' : 'create',
    after: tpl,
    before: beforeTpl || null
  });
  await logChange({
    entityType: 'personalContent',
    entityId: `${userId}:${templateId}`,
    action: beforeContent ? 'update' : 'create',
    after: contentRow,
    before: beforeContent || null
  });

  await renderPersonal();
  await renderPromptPage();
}

async function deletePersonalTemplate(payload) {
  const templateId = payload.templateId || payload.id;
  if (!templateId) return;

  const before = await getOne('personalTemplates', templateId);
  await deleteOne('personalTemplates', templateId);

  const all = await getByIndex('personalContent', 'by_templateId', templateId);
  for (const r of all) {
    await deleteOne('personalContent', [r.userId, r.templateId]);
  }

  await logChange({
    entityType: 'personalTemplate',
    entityId: templateId,
    action: 'delete',
    after: null,
    before: before || null
  });

  await renderPersonal();
  await renderPromptPage();
}

async function renderPersonalCareerPick() {
  const userId = state.currentUserId;
  const row = $('#personalCareerPickRow');
  const sel = $('#personalCareerPick');
  row.style.display = userId ? 'flex' : 'none';
  if (!userId) return;

  const careers = await getAll('careers');
  careers.sort((a,b) => (a.title || '').localeCompare(b.title || ''));

  const uc = await getOne('userCareer', userId);

  sel.innerHTML = '';
  const opt0 = document.createElement('option');
  opt0.value = '';
  opt0.textContent = '(No career selected)';
  sel.appendChild(opt0);

  careers.forEach(c => {
    const opt = document.createElement('option');
    opt.value = c.id;
    opt.textContent = c.title || '(Career)';
    sel.appendChild(opt);
  });

  sel.value = uc?.careerId || '';
  sel.onchange = async () => {
    const v = sel.value || '';
    const t = nowISO();
    const before = await getOne('userCareer', userId);
    const after = { userId, careerId: v || null, updatedAt: t, createdAt: before?.createdAt || t };
    await putOne('userCareer', after);
    await logChange({ entityType:'userCareer', entityId:userId, action: before ? 'update' : 'create', after, before });
    await renderPromptPage(); // Prompt compile uses user's career
  };
}


/** ========= Careers + Career Blocks ========= */
async function renderCareers() {
  // Career library list removed (managed from the top dropdown/buttons)
  return;
}
function openEditCareerModal(career){
  const container = document.createElement('div');
  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.placeholder = 'Career title';
  titleInput.value = career?.title || '';

  container.appendChild(inputRow('Title', titleInput));
  container.appendChild(document.createElement('div')).className = 'divider';
  const note = document.createElement('div');
  note.className = 'muted';
  note.textContent = 'This edits the career name only. Career items are managed on the right list (filtered by the top Career dropdown).';
  container.appendChild(note);

  const footer = [
  btn('Save', { primary:true, onClick: async () => {
    await saveCareer({ ...career, title: titleInput.value.trim() });
    closeModal();
  }})
];

// ✅ 只有已有 career（有 id）才允许删除
if (career?.id) {
  footer.push(btn('Delete', { danger:true, onClick: async () => {
    const ok = confirm('Delete this career?\nThis will also delete all its career items and unselect it for any users.');
    if (!ok) return;
    await deleteCareer(career);
    closeModal();
  }}));
}

  openModal('Edit · Career', container, footer);
}
async function saveCareer(payload) {
  const t = nowISO();
  if (!payload.id) {
    const row = { id: uid(), title: payload.title || '(Career)', createdAt: t, updatedAt: t };
    await addOne('careers', row);
    await logChange({ entityType: 'career', entityId: row.id, action: 'create', after: row });
  } else {
    const before = await getOne('careers', payload.id);
    const after = { ...before, title: payload.title || '(Career)', updatedAt: t };
    await putOne('careers', after);
    await logChange({ entityType: 'career', entityId: after.id, action: 'update', after, before });
  }
  await refreshAll();
}
async function deleteCareer(career) {
  const before = await getOne('careers', career.id);

  // delete blocks
  const blocks = await getByIndex('careerBlocks', 'by_careerId', career.id);
  for (const b of blocks) {
    await deleteOne('careerBlocks', b.id);
    await logChange({ entityType: 'careerBlock', entityId: b.id, action: 'delete', after: null, before: b });
  }

  // remove selections
  const allUserCareer = await getAll('userCareer');
  const impacted = allUserCareer.filter(x => x.careerId === career.id);
  for (const uc of impacted) {
    await deleteOne('userCareer', uc.userId);
    await logChange({ entityType: 'userCareer', entityId: uc.userId, action: 'delete', after: null, before: uc });
  }

  await deleteOne('careers', career.id);
  await logChange({ entityType: 'career', entityId: career.id, action: 'delete', after: null, before });
  await refreshAll();
}

async function renderCareerBlocks() {
  const list = $('#listCareerBlocks');
  initSortableList(list, 'careerTemplates');
  list.innerHTML = '';

  const careerId = state.currentCareerId || '';
  if (!careerId) {
    $('#hintCareerBlocks').style.display = 'block';
    $('#hintCareerBlocks').textContent = 'Choose a career in the top Career filter to view/edit career items.';
    $('#btnAddCareerBlock').disabled = true;
    return;
  }

  $('#btnAddCareerBlock').disabled = false;

  let [templates, contents, conns] = await Promise.all([
    getAll('careerTemplates'),
    getByIndex('careerContent', 'by_careerId', careerId),
    getAll('connections')
  ]);

  templates = applyUiOrder(templates, 'careerTemplates', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
  conns = applyUiOrder(conns || [], 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
  const assignments = await getOutputAssignments();
  const cMap = new Map((contents || []).map(c => [c.templateId, c]));

  $('#hintCareerBlocks').style.display = templates.length ? 'none' : 'block';
  $('#hintCareerBlocks').textContent = templates.length ? '' : 'No career items yet. Click Add to create.';

  templates.forEach(tpl => {
    const c = cMap.get(tpl.id);
    const content = c?.content || '';
    const isEmpty = !String(content).trim();
    const updated = c?.updatedAt || tpl.updatedAt || tpl.createdAt || '';

    const actions = [
      btn('Edit', { mini:true, onClick: () => openEditItemModal({
        title: 'Edit · Career Item',
        initial: { templateId: tpl.id, title: tpl.title, content, isOutput: (tpl.isOutput !== false), outputConnectionId: (tpl.outputConnectionId || '') },
        outputMeta: { connections: conns, assignments },
        onSave: saveCareerTemplateAndContentByFilter,
        onDelete: deleteCareerTemplate
      })})
    ];

    const pills = [
      ...(isEmpty ? [{ text:'Empty', className:'warn' }] : [])
    ];

    const row = makeItemRow({
      title: tpl.title,
      subtitle: isEmpty ? 'Content: (empty for this career)' : `Updated: ${formatLocal(updated)}`,
      pills
    }, actions);
    makeRowSortable(row, { sortKey:'careerTemplates', id: tpl.id });
    list.appendChild(row);
  });
}

async function saveCareerTemplateAndContentByFilter(payload) {
  const careerId = state.currentCareerId || null;
  if (!careerId) { alert('Select a career first.'); return; }

  const t = nowISO();

  // Enforce: one output item per connection (across Personal + Career items).
  if (payload.isOutput && (payload.outputConnectionId || '')) {
    const currentKey = (payload.templateId || payload.id || '');
    const connId = (payload.outputConnectionId || '');
    const check = await enforceSingleOutputPerConnection({ currentKey, connId });
    if (!check.ok && check.conflict) {
      const msg =
        `This connection is already used as the output for “${check.conflict.title}”.\n\n` +
        `If you continue, the previous item’s output link will be cleared, and this item will become the output for “${check.connTitle}”.\n\n` +
        `Do you want to continue?`;
      const ok = confirm(msg);
      if (!ok) return false;

      // Clear the previous item's output relationship
      await clearOutputLink(check.conflict.row, check.conflict.store);
    }
  }

  const templateId = payload.templateId || payload.id || uid();

  const beforeTpl = await getOne('careerTemplates', templateId);
  const beforeContent = await getOne('careerContent', [careerId, templateId]);

  const tpl = {
    id: templateId,
    title: (payload.title || '').trim(),
    isOutput: (payload.isOutput !== undefined ? payload.isOutput : (beforeTpl?.isOutput ?? true)),
    outputConnectionId: (payload.outputConnectionId !== undefined ? (payload.outputConnectionId || '') : (beforeTpl?.outputConnectionId || '')),
    outputMode: (beforeTpl?.outputMode || 'section'),
    createdAt: beforeTpl?.createdAt || payload.createdAt || t,
    updatedAt: t
  };
  await putOne('careerTemplates', tpl);

  const contentRow = {
    careerId,
    templateId,
    content: payload.content || '',
    createdAt: beforeContent?.createdAt || payload.createdAt || t,
    updatedAt: t
  };
  await putOne('careerContent', contentRow);

  await logChange({
    entityType: 'careerTemplate',
    entityId: templateId,
    action: beforeTpl ? 'update' : 'create',
    after: tpl,
    before: beforeTpl || null
  });
  await logChange({
    entityType: 'careerContent',
    entityId: `${careerId}:${templateId}`,
    action: beforeContent ? 'update' : 'create',
    after: contentRow,
    before: beforeContent || null
  });

  await renderCareerBlocks();
  await renderPromptPage();
}

async function deleteCareerTemplate(payload) {
  const templateId = payload.templateId || payload.id;
  if (!templateId) return;

  const before = await getOne('careerTemplates', templateId);
  await deleteOne('careerTemplates', templateId);

  const all = await getByIndex('careerContent', 'by_templateId', templateId);
  for (const r of all) {
    await deleteOne('careerContent', [r.careerId, r.templateId]);
  }

  await logChange({
    entityType: 'careerTemplate',
    entityId: templateId,
    action: 'delete',
    after: null,
    before: before || null
  });

  await renderCareerBlocks();
  await renderPromptPage();
}


/** ========= Connections (Global) ========= */
async function compileForUserWithConnection(conn, ctx='setup') {
  const userId = state.currentUserId;

  const promptIds = conn?.promptItemIds || [];
  const personalIds = conn?.personalTemplateIds || [];
  const careerIds = conn?.careerTemplateIds || [];

  const parts = [];

  // Prompt items (global)
  if (promptIds.length) {
    const allPrompts = await getAll('promptItems');
    const pMap = new Map(allPrompts.map(p => [p.id, p]));
    promptIds.forEach(id => {
      const p = pMap.get(id);
      if (!p) return;
      const body = (p.content || '').trim() ? `
${p.content}` : '';
      parts.push(`## ${p.title}${body}`);
    });
  }

  // Personal info (titles are shared, content is per-user)
  if (personalIds.length) {
    const templates = await getAll('personalTemplates');
    const tMap = new Map((templates || []).map(t => [t.id, t]));
    let cMap = new Map();

    if (userId) {
      const contents = await getByIndex('personalContent', 'by_userId', userId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    personalIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = userId ? (cMap.get(tid)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;
      const body = hasBody ? `
${content}` : '';
      parts.push(`## ${tpl.title}${body}`);
    });
  }

  // Career info (titles are shared, content is per-career)
  if (careerIds.length) {
    const templates = await getAll('careerTemplates');
    const tMap = new Map((templates || []).map(t => [t.id, t]));

    let careerId = null;
    let cMap = new Map();

    // Determine which career to compile with
    const source = (conn?.careerSource || 'user');
    if (source === 'current') {
      careerId = state.currentCareerId || null;
    } else if (userId) {
      const uc = await getOne('userCareer', userId);
      careerId = uc?.careerId || null;
    }

    if (careerId) {
      const contents = await getByIndex('careerContent', 'by_careerId', careerId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    careerIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = careerId ? (cMap.get(tid)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;
      const body = hasBody ? `
${content}` : '';
      parts.push(`## ${tpl.title}${body}`);
    });
  }

  return parts.join('\n\n').trim();
}


async function compileExplicitOutputForUserWithConnection(conn, ctx='setup') {
  const userId = state.currentUserId;
  const out = [];
  const connId = conn?.id || '';
  if (!connId) return '';

  // Personal explicit outputs (tied to this connection; independent of whether the item is included in the connection pick-list)
  try {
    let [templates, contents] = await Promise.all([
      getAll('personalTemplates'),
      userId ? getByIndex('personalContent', 'by_userId', userId) : Promise.resolve([])
    ]);
    templates = applyUiOrder(templates || [], 'personalTemplates', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
    const cMap = new Map((contents || []).map(c => [c.templateId, c]));

    (templates || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      const oc = (tpl.outputConnectionId || '');
      if (oc !== connId) return;

      const mode = (tpl.outputMode || 'section');
      const content = userId ? (cMap.get(tpl.id)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;

      if (mode === 'content') {
        if (hasBody) out.push(String(content).trim());
        return;
      }
      if (mode === 'title') {
        out.push(`## ${tpl.title}`);
        return;
      }
      out.push(`## ${tpl.title}`);
      if (hasBody) out.push(content);
    });
  } catch(e) { /* ignore */ }

  // Career explicit outputs (tied to this connection; independent of whether the item is included in the connection pick-list)
  try {
    let templates = await getAll('careerTemplates');
    templates = applyUiOrder(templates || [], 'careerTemplates', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));

    let careerId = null;

    const source = (conn?.careerSource || 'user');
    if (source === 'current') {
      careerId = state.currentCareerId || null;
    } else if (userId) {
      const uc = await getOne('userCareer', userId);
      careerId = uc?.careerId || null;
    }

    let cMap = new Map();
    if (careerId) {
      const contents = await getByIndex('careerContent', 'by_careerId', careerId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    (templates || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      const oc = (tpl.outputConnectionId || '');
      if (oc !== connId) return;

      const mode = (tpl.outputMode || 'section');
      const content = careerId ? (cMap.get(tpl.id)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;

      if (mode === 'content') {
        if (hasBody) out.push(String(content).trim());
        return;
      }
      if (mode === 'title') {
        out.push(`## ${tpl.title}`);
        return;
      }
      out.push(`## ${tpl.title}`);
      if (hasBody) out.push(content);
    });
  } catch(e) { /* ignore */ }

  return out.join('\n\n').trim();
}

async function openOutputModal(conn) {
  const outText = await compileExplicitOutputForUserWithConnection(conn, 'prompt');

  const preview = document.createElement('div');
  preview.className = 'mdPreview outputReader';
  preview.innerHTML = renderMarkdown(outText || '');

  const headerButtons = [
    btn('Copy', { mini:true, onClick: async () => {
      await navigator.clipboard.writeText(outText || '');
      toast('Copied to clipboard');
    }})
  ];

  openModal(`Output · ${conn?.title || '(Untitled Connection)'}`, preview, [], headerButtons);
}

async function openPromptModal(conn) {
  const text = await compileForUserWithConnection(conn, 'prompt');

  const preview = document.createElement('div');
  preview.className = 'mdPreview outputReader';
  preview.innerHTML = renderMarkdown(text || '');

  const headerButtons = [
    btn('Copy', { mini:true, onClick: async () => {
      await navigator.clipboard.writeText(text || '');
      toast('Copied to clipboard');
    }})
  ];

  openModal(`Prompt · ${conn?.title || '(Untitled Connection)'}`, preview, [], headerButtons);
}


async function analyzeConnectionForCurrentUser(conn, ctx='setup') {
  const userId = state.currentUserId;

  const emptyPersonal = [];
  const emptyCareer = [];
  let missingCareer = false;
  let explicitOutputCount = 0;

  const personalIds = conn?.personalTemplateIds || [];
  const careerIds = conn?.careerTemplateIds || [];

  // Count explicit outputs (independent of whether the item is included in the connection pick-list)
  try {
    const [pTemps, cTemps] = await Promise.all([getAll('personalTemplates'), getAll('careerTemplates')]);
    (pTemps || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      if ((tpl.outputConnectionId || '') === (conn?.id || '')) explicitOutputCount += 1;
    });
    (cTemps || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      if ((tpl.outputConnectionId || '') === (conn?.id || '')) explicitOutputCount += 1;
    });
  } catch(e) { /* ignore */ }

  // Personal empties based on connection selection (content may be empty, but we still warn)
  if (personalIds.length) {
    const [templates, contents] = await Promise.all([
      getAll('personalTemplates'),
      userId ? getByIndex('personalContent', 'by_userId', userId) : Promise.resolve([])
    ]);
    const tMap = new Map((templates || []).map(t => [t.id, t]));
    const cMap = new Map((contents || []).map(c => [c.templateId, c]));

    personalIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = userId ? (cMap.get(tid)?.content || '') : '';
      if (!String(content).trim()) emptyPersonal.push(tpl.title);
    });
  }

  // Resolve career for this compile context (used for missingCareer + emptyCareer)
  let careerId = null;
  if (careerIds.length) {
    const source = (conn?.careerSource || 'user');
    if (source === 'current') {
      careerId = state.currentCareerId || null;
    } else if (userId) {
      const uc = await getOne('userCareer', userId);
      careerId = uc?.careerId || null;
    }
    if (!careerId) missingCareer = true;
  }

  if (careerIds.length) {
    const templates = await getAll('careerTemplates');
    const tMap = new Map((templates || []).map(t => [t.id, t]));

    let cMap = new Map();
    if (careerId) {
      const contents = await getByIndex('careerContent', 'by_careerId', careerId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    careerIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = careerId ? (cMap.get(tid)?.content || '') : '';
      if (!String(content).trim()) emptyCareer.push(tpl.title);
    });
  }

  const compiled = await compileForUserWithConnection(conn, ctx);
  return { compiled, emptyPersonal, emptyCareer, missingCareer, hasExplicitOutput: (explicitOutputCount > 0) };
}



async function renderConnections() {
  const list = $('#listConnections');
  initSortableList(list, 'connections');
  list.innerHTML = '';

  let conns = await getAll('connections');
  conns = applyUiOrder(conns, 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));

  $('#hintConnections').style.display = conns.length ? 'none' : 'block';

  conns.forEach(c => {
    const actions = [
      btn('Edit', { mini:true, onClick: () => openConnectionModal({ mode:'edit', initial: c }) })
    ];

    const pills = [
      `Prompts: ${(c.promptItemIds || []).length}`,
      `Personal: ${(c.personalTemplateIds || []).length}`,
      `Career: ${(c.careerTemplateIds || []).length}`
    ];
    const row = makeItemRow({
      title: c.title,
      subtitle: `Updated: ${formatLocal(c.updatedAt)}` ,
      pills
    }, actions);
    makeRowSortable(row, { sortKey:'connections', id: c.id });
    list.appendChild(row);
  });
}


async function openConnectionModal({ mode, initial }) {
  const prompts = await getAll('promptItems');
  const personalTemplates = await getAll('personalTemplates');
  const careerTemplates = await getAll('careerTemplates');

  prompts.sort((a,b) => (a.title || '').localeCompare(b.title || ''));
  personalTemplates.sort((a,b) => (a.title || '').localeCompare(b.title || ''));
  careerTemplates.sort((a,b) => (a.title || '').localeCompare(b.title || ''));

  const selectedPrompt = new Set(initial?.promptItemIds || []);
  const selectedPersonal = new Set(initial?.personalTemplateIds || []);
  const selectedCareer = new Set(initial?.careerTemplateIds || []);

  let careerSource = (initial?.careerSource || 'user');


  // Preload emptiness status for current user, for both "user career" and "current career"
  const userId = state.currentUserId;

  const personalContent = userId ? await getByIndex('personalContent', 'by_userId', userId) : [];
  const personalContentMap = new Map((personalContent || []).map(r => [r.templateId, r]));

  // User career mapping (per-user fixed career)
  let userCareerId = null;
  if (userId) {
    const uc = await getOne('userCareer', userId);
    userCareerId = uc?.careerId || null;
  }
  const careerContent_user = userCareerId ? await getByIndex('careerContent', 'by_careerId', userCareerId) : [];
  const careerContentMap_user = new Map((careerContent_user || []).map(r => [r.templateId, r]));

  // Current career (from Career Info dropdown)
  const currentCareerId = state.currentCareerId || null;
  const careerContent_current = currentCareerId ? await getByIndex('careerContent', 'by_careerId', currentCareerId) : [];
  const careerContentMap_current = new Map((careerContent_current || []).map(r => [r.templateId, r]));

  const getCareerMapForSource = () => (careerSource === 'current' ? careerContentMap_current : careerContentMap_user);
  const getCareerIdForSource = () => (careerSource === 'current' ? currentCareerId : userCareerId);

  const wrap = document.createElement('div');

  wrap.innerHTML = `
    <div class="split">
      <div>
        <div class="field">
          <label>Connection Title</label>
          <input id="connTitleInput" type="text" placeholder="e.g., Onboarding Prompt Pack"/>
        </div>
        <div class="field">
          <label>Career Source</label>
          <div class="row" style="gap:12px; flex-wrap:wrap; margin-top:6px;">
            <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="radio" name="connCareerSource" id="connCareerSourceCurrent" value="current" />
              <span>Current career (dynamic)</span>
            </label>
            <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="radio" name="connCareerSource" id="connCareerSourceUser" value="user" />
              <span>User career</span>
            </label>
          </div>
          <div class="hint" style="margin-top:6px;">
            Current career uses the Career Info dropdown. User career uses the selected user’s saved “User Career”.
          </div>
        </div>


        <div class="hint" style="margin-top:-6px;">
          Select items across Prompt, Personal Info, and Career Info. Titles are shared; Personal and Career content may be empty for the current user.
        </div>

        <div class="sectionTitle">Prompt Items</div>
        <div id="connPickPrompts" style="margin-top:6px; max-height:18vh; overflow:auto; padding-right:6px;"></div>

        <div class="sectionTitle" style="margin-top:12px;">Personal Info Items</div>
        <div id="connPickPersonal" style="margin-top:6px; max-height:18vh; overflow:auto; padding-right:6px;"></div>

        <div class="sectionTitle" style="margin-top:12px;">Career Info Items</div>
        <div id="connPickCareer" style="margin-top:6px; max-height:18vh; overflow:auto; padding-right:6px;"></div>
      </div>

      <div>
        <div class="hint" style="margin-bottom:6px;">Preview (for current user)</div>
        <div class="mdPreview" id="connPreview" style="max-height:62vh; overflow:auto;"></div>
        <div class="hint" id="connWarn" style="margin-top:8px; display:none;"></div>
      </div>
    </div>
  `;

  const footerButtons = [
    btn('Save', { primary:true, onClick: async () => {
      const title = $('#connTitleInput').value.trim() || '(Untitled Connection)';
      const t = nowISO();

      const row = {
        id: initial?.id || uid(),
        title,
        promptItemIds: [...selectedPrompt],
        personalTemplateIds: [...selectedPersonal],
        careerTemplateIds: [...selectedCareer],
        careerSource,
        createdAt: initial?.createdAt || t,
        updatedAt: t
      };

      const before = initial?.id ? await getOne('connections', initial.id) : null;
      await putOne('connections', row);
      await logChange({ entityType:'connection', entityId: row.id, action: before ? 'update' : 'create', after: row, before });

      closeModal();
      await renderConnections();
      await renderPromptPage();
    }}),
    // Move Cancel to the bottom-right (where Delete used to be)
    btn('Cancel', { ghost:true, onClick: closeModal })
  ];

  const headerButtons = [];
  if (mode === 'edit') {
    headerButtons.push(
      // Move Delete next to the modal title to reduce mis-click risk.
      btn('Delete', { mini:true, danger:true, onClick: async () => {
        const ok = confirm('Delete this connection?');
        if (!ok) return;
        const before = await getOne('connections', initial.id);
        await deleteOne('connections', initial.id);
        await logChange({ entityType:'connection', entityId: initial.id, action:'delete', after:null, before });
        closeModal();
        await renderConnections();
        await renderPromptPage();
      }})
    );
  }

  openModal(mode === 'edit' ? 'Edit Connection' : 'New Connection', wrap, footerButtons, headerButtons);


  $('#connTitleInput').value = initial?.title || '';

  // Career Source radios
  const rCur = $('#connCareerSourceCurrent');
  const rUser = $('#connCareerSourceUser');
  if (rCur && rUser) {
    rCur.checked = (careerSource === 'current');
    rUser.checked = (careerSource !== 'current');
    rCur.onchange = () => { careerSource = 'current'; renderCareerChoices(); refreshPreview(); };
    rUser.onchange = () => { careerSource = 'user'; renderCareerChoices(); refreshPreview(); };
  }


  const pickPrompts = $('#connPickPrompts');
  const pickPersonal = $('#connPickPersonal');
  const pickCareer = $('#connPickCareer');
  const preview = $('#connPreview');
  const warn = $('#connWarn');

  const mkRow = ({ label, checked, onToggle, pill }) => {
    const row = document.createElement('label');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.gap = '10px';
    row.style.padding = '8px 10px';
    row.style.border = '1px solid rgba(34,49,75,.5)';
    row.style.borderRadius = '12px';
    row.style.marginBottom = '8px';
    row.style.cursor = 'pointer';
    row.style.userSelect = 'none';

    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.alignItems = 'center';
    left.style.gap = '10px';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = checked;
    cb.onchange = (e) => onToggle(e.target.checked);

    const text = document.createElement('div');
    text.textContent = label;

    left.appendChild(cb);
    left.appendChild(text);

    row.appendChild(left);

    if (pill) {
      const sp = document.createElement('span');
      sp.className = 'pill ' + pill.className;
      sp.textContent = pill.text;
      row.appendChild(sp);
    }

    return row;
  };

  prompts.forEach(p => {
    pickPrompts.appendChild(mkRow({
      label: p.title,
      checked: selectedPrompt.has(p.id),
      onToggle: (v) => {
        v ? selectedPrompt.add(p.id) : selectedPrompt.delete(p.id);
        refreshPreview();
      }
    }));
  });

  personalTemplates.forEach(tpl => {
    const content = userId ? (personalContentMap.get(tpl.id)?.content || '') : '';
    const isEmpty = !String(content).trim();
    pickPersonal.appendChild(mkRow({
      label: tpl.title,
      checked: selectedPersonal.has(tpl.id),
      pill: isEmpty ? { text: 'Empty', className: 'warn' } : null,
      onToggle: (v) => {
        v ? selectedPersonal.add(tpl.id) : selectedPersonal.delete(tpl.id);
        refreshPreview();
      }
    }));
  });


  function renderCareerChoices() {
    pickCareer.innerHTML = '';
    const cMapActive = getCareerMapForSource();
    const careerIdActive = getCareerIdForSource();
    careerTemplates.forEach(tpl => {
      const content = careerIdActive ? (cMapActive.get(tpl.id)?.content || '') : '';
      const isEmpty = !String(content).trim();
      pickCareer.appendChild(mkRow({
        label: tpl.title,
        checked: selectedCareer.has(tpl.id),
        pill: isEmpty ? { text: 'Empty', className: 'warn' } : null,
        onToggle: (v) => {
          v ? selectedCareer.add(tpl.id) : selectedCareer.delete(tpl.id);
          refreshPreview();
        }
      }));
    });
  }
  renderCareerChoices();

  async function refreshPreview() {
    const conn = {
      promptItemIds: [...selectedPrompt],
      personalTemplateIds: [...selectedPersonal],
      careerTemplateIds: [...selectedCareer],
      careerSource
    };
    const info = await analyzeConnectionForCurrentUser(conn);
    preview.innerHTML = renderMarkdown(info.compiled || '');

    const notes = [];
    if (info.missingCareer && (conn.careerTemplateIds || []).length) {
      notes.push('Career is not selected for this user.');
    }
    if (info.emptyPersonal.length) notes.push(`Empty personal: ${info.emptyPersonal.join(', ')}`);
    if (info.emptyCareer.length) notes.push(`Empty career: ${info.emptyCareer.join(', ')}`);

    if (notes.length) {
      warn.style.display = 'block';
      warn.textContent = '⚠️ ' + notes.join(' ');
    } else {
      warn.style.display = 'none';
      warn.textContent = '';
    }
  }

  await refreshPreview();
}


/** ========= Prompt Page ========= */
async function renderPromptPickers() {
  const uSel = $('#promptUserSelect');
  const ucSel = $('#promptUserCareerSelect');
  const ccSel = $('#promptCurrentCareerSelect');
  if (!uSel || !ucSel || !ccSel) return;

  // Users
  let users = await getAll('users');
  users.sort((a,b) => (a.name || '').localeCompare(b.name || ''));

  uSel.innerHTML = '';
  if (!users.length) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(No users)';
    uSel.appendChild(opt);
    state.currentUserId = '';
    uSel.value = '';
  } else {
    users.forEach(u => {
      const opt = document.createElement('option');
      opt.value = u.id;
      opt.textContent = u.name || '(User)';
      uSel.appendChild(opt);
    });

    const remembered = (() => { try { return localStorage.getItem('mivida_current_user_id'); } catch { return ''; } })();
    const pick = (state.currentUserId && users.some(x => x.id === state.currentUserId))
      ? state.currentUserId
      : ((remembered && users.some(x => x.id === remembered)) ? remembered : (users[0]?.id || ''));

    state.currentUserId = pick || '';
    uSel.value = state.currentUserId || '';
  }

  // Careers (shared option list)
  let careers = await getAll('careers');
  careers.sort((a,b) => (a.title || '').localeCompare(b.title || ''));

  // User Career picker (career saved on the user)
  ucSel.innerHTML = '';
  if (!state.currentUserId) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(Select a user)';
    ucSel.appendChild(opt);
    ucSel.value = '';
    ucSel.disabled = true;
  } else {
    ucSel.disabled = false;
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = '(No career selected)';
    ucSel.appendChild(opt0);

    careers.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.textContent = c.title || '(Career)';
      ucSel.appendChild(opt);
    });

    const uc = await getOne('userCareer', state.currentUserId);
    ucSel.value = uc?.careerId || '';
  }

  // Current Career picker (global, shared with Setup Career dropdown)
  ccSel.innerHTML = '';
  const optNone = document.createElement('option');
  optNone.value = '';
  optNone.textContent = '(Choose a career)';
  ccSel.appendChild(optNone);

  careers.forEach(c => {
    const opt = document.createElement('option');
    opt.value = c.id;
    opt.textContent = c.title || '(Career)';
    ccSel.appendChild(opt);
  });

  let rememberedCareer = '';
  try { rememberedCareer = localStorage.getItem('mivida_current_career_id') || ''; } catch { rememberedCareer = ''; }

  let pickCareer =
    (state.currentCareerId && careers.some(x => x.id === state.currentCareerId)) ? state.currentCareerId :
    ((rememberedCareer && careers.some(x => x.id === rememberedCareer)) ? rememberedCareer :
     (careers[0]?.id || ''));

  state.currentCareerId = pickCareer || '';
  state.promptCareerId = state.currentCareerId || '';
  ccSel.value = state.currentCareerId || '';
}

async function renderPromptPage() {
  const userId = state.currentUserId;
  const user = userId ? await getOne('users', userId) : null;
  const userName = (user?.name || user?.title || (userId ? ('user ' + userId) : '(No user)'));
  const careersAll = await getAll('careers');
  const careerMap = new Map((careersAll || []).map(x => [x.id, x]));
  let userCareerId = null;
  if (userId) {
    try { const uc = await getOne('userCareer', userId); userCareerId = uc?.careerId || null; } catch {}
  }

  let conns = await getAll('connections');
  conns = applyUiOrder(conns, 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));

  const host = $('#promptConnections');
  host.innerHTML = '';

  $('#promptEmpty').style.display = (conns.length === 0) ? 'block' : 'none';

// Precompute explicit output counts across all items (connection output depends on item -> connection linkage, not on connection pick-lists)
let explicitOutCount = new Map();
try {
  const [pTemplates, cTemplates] = await Promise.all([
    getAll('personalTemplates'),
    getAll('careerTemplates')
  ]);
  ([...(pTemplates || []), ...(cTemplates || [])] || []).forEach(t => {
    if (!t) return;
    if (t.isOutput === false) return;
    const oc = (t.outputConnectionId || '');
    if (!oc) return;
    explicitOutCount.set(oc, (explicitOutCount.get(oc) || 0) + 1);
  });
} catch(e) { /* ignore */ }

  for (const c of conns) {
    const info = await analyzeConnectionForCurrentUser(c, 'prompt');
    const hasExplicitOutput = (explicitOutCount.get(c.id) || 0) > 0;

    const card = document.createElement('div');
    card.className = 'card';
    card.style.marginTop = '12px';

    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    header.style.gap = '12px';

    const left = document.createElement('div');

    const h = document.createElement('h3');
    h.style.margin = '0';
    h.textContent = c.title;

    const meta = document.createElement('div');
    meta.className = 'hint';
    meta.style.marginTop = '4px';
    meta.textContent = userId
      ? `Compiled for current user. Updated: ${formatLocal(c.updatedAt)}`
      : `Select a user in Setup → Users to compile. Updated: ${formatLocal(c.updatedAt)}`;

    left.appendChild(h);

    // Tags: show which user/career this connection compiles with
    const needsUser = (c.personalTemplateIds || []).length > 0;
    const needsCareer = (c.careerTemplateIds || []).length > 0;
    const tags = [];
    if (needsUser) tags.push(`user: ${userName}`);
    if (needsCareer) {
      const src = (c.careerSource || 'user');
      const cid = (src === 'current') ? (state.currentCareerId || null) : (userCareerId || null);
      const cObj = cid ? careerMap.get(cid) : null;
      const cTitle = cid ? (cObj?.title || cObj?.name || cid) : '(not selected)';
      tags.push(`career: ${cTitle}`);
    }
    if (tags.length) {
      const tagRow = document.createElement('div');
      tagRow.style.marginTop = '6px';
      tagRow.style.display = 'flex';
      tagRow.style.gap = '6px';
      tags.slice(0,2).forEach(t => {
        const sp = document.createElement('span');
        sp.className = 'pill';
        sp.textContent = t;
        tagRow.appendChild(sp);
      });
      left.appendChild(tagRow);
    }

    left.appendChild(meta);

    const notes = [];
    if (info.missingCareer && (c.careerTemplateIds || []).length) notes.push('Career not selected for this user.');
    if (info.emptyPersonal.length) notes.push(`Empty personal: ${info.emptyPersonal.join(', ')}`);
    if (info.emptyCareer.length) notes.push(`Empty career: ${info.emptyCareer.join(', ')}`);

    if (notes.length) {
      const warn = document.createElement('div');
      warn.className = 'hint';
      warn.style.marginTop = '6px';
      warn.textContent = '⚠️ ' + notes.join(' ');
      left.appendChild(warn);
    }

    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.flexDirection = 'column';
    right.style.alignItems = 'flex-end';
    right.style.gap = '6px';

    const actionRowTop = document.createElement('div');
    actionRowTop.style.display = 'flex';
    actionRowTop.style.gap = '8px';
    actionRowTop.style.justifyContent = 'flex-end';

    const actionRowBottom = document.createElement('div');
    actionRowBottom.style.display = 'flex';
    actionRowBottom.style.gap = '8px';
    actionRowBottom.style.justifyContent = 'flex-end';
    const btnPrompt = btn('Prompt', { mini:true, onClick: async () => {
      await openPromptModal(c);
    }});
const btnCopy = btn('Copy', { mini:true, onClick: async () => {
      await navigator.clipboard.writeText(info.compiled || '');
      toast('Copied to clipboard');
    }});

    const promptId = (c?.promptItemIds && c.promptItemIds.length) ? c.promptItemIds[0] : '';
    if (promptId) {
      const btnEditPrompt = btn('Edit Prompt', { mini:true, onClick: async () => {
        try {
          const it = await getOne('promptItems', promptId);
          if (!it) { toast('Prompt item not found'); return; }
          openEditItemModal({
            title: 'Edit · Prompt Item',
            initial: it,
            onSave: savePromptItem,
            onDelete: null,
            contentOnly: true
          });
        } catch (e) {
          console.error(e);
          toast('Failed to open prompt editor');
        }
      }});
      actionRowTop.appendChild(btnEditPrompt);
    }

    if (hasExplicitOutput) {
      const btnEditOutput = btn('Edit Output', { mini:true, onClick: async () => {
        try {
          const connId = c?.id || '';
          if (!connId) { toast('Connection not found'); return; }

          const [pTemps, cTemps] = await Promise.all([
            getAll('personalTemplates'),
            getAll('careerTemplates')
          ]);

          let outTpl = (pTemps || []).find(t => t && t.isOutput !== false && (t.outputConnectionId || '') === connId) || null;
          let outType = 'personal';
          if (!outTpl) {
            outTpl = (cTemps || []).find(t => t && t.isOutput !== false && (t.outputConnectionId || '') === connId) || null;
            if (outTpl) outType = 'career';
          }

          if (!outTpl) { toast('No output item is linked to this connection'); return; }

          if (outType === 'personal') {
            const userId = state.currentUserId;
            if (!userId) { toast('Select a user first'); return; }

            const row = await getOne('personalContent', [userId, outTpl.id]);
            openEditItemModal({
              title: 'Edit · Output',
              initial: { templateId: outTpl.id, title: outTpl.title, content: (row?.content || '') },
              contentOnly: true,
              onSave: async (payload) => {
                const ok = await savePersonalTemplateAndContent(payload);
                await refreshAll();
                return ok;
              }
            });
            return;
          }

          // Fallback: career output (not expected, but supported)
          let careerId = null;
          const source = (c?.careerSource || 'user');
          if (source === 'current') {
            careerId = state.currentCareerId || null;
          } else if (state.currentUserId) {
            const uc = await getOne('userCareer', state.currentUserId);
            careerId = uc?.careerId || null;
          }
          if (!careerId) { toast('Career is not selected'); return; }

          const row = await getOne('careerContent', [careerId, outTpl.id]);
          openEditItemModal({
            title: 'Edit · Output',
            initial: { templateId: outTpl.id, title: outTpl.title, content: (row?.content || '') },
            contentOnly: true,
            onSave: async (payload) => {
              const t = nowISO();
              const before = await getOne('careerContent', [careerId, outTpl.id]);
              await putOne('careerContent', {
                careerId,
                templateId: outTpl.id,
                content: payload.content || '',
                createdAt: before?.createdAt || t,
                updatedAt: t
              });

              const beforeTpl = await getOne('careerTemplates', outTpl.id);
              if (beforeTpl) await putOne('careerTemplates', { ...beforeTpl, updatedAt: t });

              await refreshAll();
            }
          });
        } catch (e) {
          console.error(e);
          toast('Failed to open output editor');
        }
      }});
      actionRowTop.appendChild(btnEditOutput);

      const btnOut = btn('Output', { mini:true, onClick: async () => {
        await openOutputModal(c);
      }});
      actionRowBottom.appendChild(btnOut);
    }

    actionRowBottom.appendChild(btnPrompt);
    actionRowBottom.appendChild(btnCopy);

    if (actionRowTop.childNodes.length) right.appendChild(actionRowTop);
    right.appendChild(actionRowBottom);

    header.appendChild(left);
    header.appendChild(right);

    card.appendChild(header);
    host.appendChild(card);
}
}


/** ========= Export / Import ========= */
async function exportLogsCsv() {
  const logs = await getAll('changeLogs');
  logs.sort((a,b) => (a.timestamp || '').localeCompare(b.timestamp || ''));

  const header = ['timestamp','entityType','entityId','action','after','before'];
  const rows = logs.map(l => [
    l.timestamp, l.entityType, l.entityId, l.action,
    JSON.stringify(l.after ?? null), JSON.stringify(l.before ?? null)
  ]);

  const csv = [header, ...rows].map(r => r.map(escapeCsv).join(',')).join('\n');
  downloadText(`mivida_change_log_${new Date().toISOString().slice(0,10)}.csv`, csv, 'text/csv');
}

async function exportSnapshotJson(options=null) {
  // Export options are intentionally "section-level" (no title-only exports).
  // Sections:
  // - promptItems
  // - profiles (users + personal titles + personal content)
  // - careers (careers + career titles + career content)
  // - connections (connections + required prompt items + required title templates only; does NOT force profile/career content)
  // - changeLogs
  // - includeOrder (exports UI list order for selected sections)
  const defaults = {
    promptItems: false,
    profiles: false,
    careers: false,
    connections: false,
    changeLogs: false,
    includeOrder: false
  };
  const opts = Object.assign({}, defaults, options || {});

  const exportConnections = !!opts.connections;
  const exportPromptsRequested = !!opts.promptItems;
  const exportProfiles = !!opts.profiles;
  const exportCareers = !!opts.careers;
  const exportLogs = !!opts.changeLogs;

  // Mapping is meaningful only when BOTH profiles + careers are exported.
  const exportUserCareer = (exportProfiles && exportCareers);

  // Optional filters: export only selected Users / Careers / Prompt items (and their related content).
  const userFilter = (exportProfiles && Array.isArray(opts.userIds) && opts.userIds.length)
    ? new Set(opts.userIds)
    : null;
  const careerFilter = (exportCareers && Array.isArray(opts.careerIds) && opts.careerIds.length)
    ? new Set(opts.careerIds)
    : null;

  // Prompt filter applies only to the "Prompt items" section selection.
  // If connections are exported, required prompt items will be included additionally (union).
  const promptFilter = (exportPromptsRequested && Array.isArray(opts.promptItemIds) && opts.promptItemIds.length)
    ? new Set(opts.promptItemIds)
    : null;

  // Pull datasets (only what's needed)
  const users = exportProfiles ? await safeGetAll('users') : [];
  const personalTemplates = (exportProfiles || exportConnections) ? await safeGetAll('personalTemplates') : [];
  const personalContent = exportProfiles ? await safeGetAll('personalContent') : [];

  const careers = exportCareers ? await safeGetAll('careers') : [];
  const careerTemplates = (exportCareers || exportConnections) ? await safeGetAll('careerTemplates') : [];
  const careerContent = exportCareers ? await safeGetAll('careerContent') : [];

  const userCareer = exportUserCareer ? await safeGetAll('userCareer') : [];
  const connections = exportConnections ? await safeGetAll('connections') : [];

  // Prompt items are needed when explicitly exporting prompts OR exporting connections (dependencies).
  const promptItems = (exportPromptsRequested || exportConnections) ? await safeGetAll('promptItems') : [];

  const changeLogs = exportLogs ? await safeGetAll('changeLogs') : [];

  // Apply filters (profiles/careers only)
  const usersOut = userFilter ? (users || []).filter(u => userFilter.has(u.id)) : users;
  const careersOut = careerFilter ? (careers || []).filter(c => careerFilter.has(c.id)) : careers;

  const personalContentOut = userFilter ? (personalContent || []).filter(r => userFilter.has(r.userId)) : personalContent;
  const careerContentOut = careerFilter ? (careerContent || []).filter(r => careerFilter.has(r.careerId)) : careerContent;

  let userCareerOut = userCareer || [];
  if (userFilter) userCareerOut = userCareerOut.filter(r => userFilter.has(r.userId));
  if (careerFilter) userCareerOut = userCareerOut.filter(r => careerFilter.has(r.careerId));

  // Collect dependencies from exported connections:
  // - promptItemIds
  // - personalTemplateIds (titles)
  // - careerTemplateIds (titles)
  const refPromptIds = new Set();
  const refPersonalTplIds = new Set();
  const refCareerTplIds = new Set();

  if (exportConnections) {
    (connections || []).forEach(c => {
      (c.promptItemIds || []).forEach(id => refPromptIds.add(id));
      (c.personalTemplateIds || []).forEach(id => refPersonalTplIds.add(id));
      (c.careerTemplateIds || []).forEach(id => refCareerTplIds.add(id));
    });
  }

  // Determine prompt items to export:
  // - If Prompt items section is requested without a filter => export all promptItems
  // - Else export selected prompt items (if any) union required prompt items for connections
  let promptItemsOut = [];
  if (exportPromptsRequested && !promptFilter) {
    // Export all prompts (and connections will be satisfied implicitly)
    promptItemsOut = promptItems || [];
  } else {
    const outIds = new Set();
    if (exportPromptsRequested) {
      // If no promptFilter, treat "selected" as all (already handled above).
      (promptFilter ? Array.from(promptFilter) : []).forEach(id => outIds.add(id));
    }
    if (exportConnections) {
      refPromptIds.forEach(id => outIds.add(id));
    }
    promptItemsOut = (promptItems || []).filter(p => outIds.has(p.id));
  }

  // Determine templates to export:
  // - Profiles export: export ALL personalTemplates (paired with content)
  // - Connections export only: export ONLY referenced templates (titles)
  const personalTemplatesOut = exportProfiles
    ? (personalTemplates || [])
    : (exportConnections ? (personalTemplates || []).filter(t => refPersonalTplIds.has(t.id)) : []);

  const careerTemplatesOut = exportCareers
    ? (careerTemplates || [])
    : (exportConnections ? (careerTemplates || []).filter(t => refCareerTplIds.has(t.id)) : []);
  // Ensure we export the item↔connection "output" relationship in a stable way.
  // Attach outputConnectionTitle (resolved from local connections by id) to templates.
  const _allConnsForOutputTitle = await safeGetAll('connections');
  const _connTitleById = new Map((_allConnsForOutputTitle || []).map(c => [c.id, c.title || '']));

  const personalTemplatesOutFinal = (personalTemplatesOut || []).map(t => {
    const ocid = (t && t.outputConnectionId) ? String(t.outputConnectionId) : '';
    const oct = (t && t.outputConnectionTitle) ? String(t.outputConnectionTitle) : (ocid ? (_connTitleById.get(ocid) || '') : '');
    return { ...t, outputConnectionTitle: oct };
  });

  const careerTemplatesOutFinal = (careerTemplatesOut || []).map(t => {
    const ocid = (t && t.outputConnectionId) ? String(t.outputConnectionId) : '';
    const oct = (t && t.outputConnectionTitle) ? String(t.outputConnectionTitle) : (ocid ? (_connTitleById.get(ocid) || '') : '');
    return { ...t, outputConnectionTitle: oct };
  });


  // Legacy arrays for backward compatibility: include only when exporting the full paired data.
  let personalItemsLegacy = [];
  if (exportProfiles) {
    const tMap = new Map((personalTemplates || []).map(t => [t.id, t.title]));
    personalItemsLegacy = (personalContentOut || []).map(r => ({
      id: `${r.userId}::${r.templateId}`,
      userId: r.userId,
      title: tMap.get(r.templateId) || '',
      content: r.content || '',
      createdAt: r.createdAt || null,
      updatedAt: r.updatedAt || null
    })).filter(r => r.userId && r.title);
  }

  let careerBlocksLegacy = [];
  if (exportCareers) {
    const tMap = new Map((careerTemplates || []).map(t => [t.id, t.title]));
    careerBlocksLegacy = (careerContentOut || []).map(r => ({
      id: `${r.careerId}::${r.templateId}`,
      careerId: r.careerId,
      title: tMap.get(r.templateId) || '',
      content: r.content || '',
      createdAt: r.createdAt || null,
      updatedAt: r.updatedAt || null
    })).filter(r => r.careerId && r.title);
  }

  // Optional: export UI item order (Setup page list order), scoped to the exported data.
  let uiSortOut = null;
  if (opts.includeOrder) {
    const keys = [];
    // Prompt list order is relevant if promptItems are exported OR connections are exported (dependencies).
    if (exportPromptsRequested || exportConnections) keys.push('promptItems');
    // Template list order is relevant if their corresponding templates are included.
    if (exportProfiles || exportConnections) keys.push('personalTemplates');
    if (exportCareers || exportConnections) keys.push('careerTemplates');
    if (exportConnections) keys.push('connections');

    const out = {};
    const exportedPromptIdSet = new Set((promptItemsOut || []).map(p => p.id));
    const exportedPersonalTplIdSet = new Set((personalTemplatesOutFinal || []).map(t => t.id));
    const exportedCareerTplIdSet = new Set((careerTemplatesOutFinal || []).map(t => t.id));

    keys.forEach(k => {
      const arr = getUiOrder(k);
      if (!Array.isArray(arr)) return;

      if (k === 'promptItems' && exportedPromptIdSet.size && exportedPromptIdSet.size < (promptItems || []).length) {
        out[k] = arr.filter(id => exportedPromptIdSet.has(id));
        return;
      }
      if (k === 'personalTemplates' && exportedPersonalTplIdSet.size && exportedPersonalTplIdSet.size < (personalTemplates || []).length) {
        out[k] = arr.filter(id => exportedPersonalTplIdSet.has(id));
        return;
      }
      if (k === 'careerTemplates' && exportedCareerTplIdSet.size && exportedCareerTplIdSet.size < (careerTemplates || []).length) {
        out[k] = arr.filter(id => exportedCareerTplIdSet.has(id));
        return;
      }

      out[k] = arr;
    });

    uiSortOut = out;
  }

  const snapshot = {
    version: DB_VERSION,
    exportedAt: nowISO(),

    // Sections (always present as arrays for predictable import)
    users: usersOut || [],
    personalTemplates: personalTemplatesOutFinal || [],
    personalContent: exportProfiles ? (personalContentOut || []) : [],

    careers: careersOut || [],
    careerTemplates: careerTemplatesOutFinal || [],
    careerContent: exportCareers ? (careerContentOut || []) : [],

    promptItems: promptItemsOut || [],
    connections: exportConnections ? (connections || []) : [],
    userCareer: exportUserCareer ? (userCareerOut || []) : [],

    changeLogs: exportLogs ? (changeLogs || []) : [],

    // Optional UI ordering
    uiSort: uiSortOut,

    // legacy (generated for backward compatibility)
    personalItems: exportProfiles ? (personalItemsLegacy || []) : [],
    careerBlocks: exportCareers ? (careerBlocksLegacy || []) : []
  };

  const stamp = new Date().toISOString().replace(/[:.]/g,'-');
  const jsonText = JSON.stringify(snapshot, null, 2);

  downloadText(`mivida_snapshot_${stamp}.json`, jsonText, 'application/json');
  toast('Snapshot exported');
  return snapshot;
}

function openExportWizard() {
  // Default: export nothing until the user selects items or other sections.
  const opts = {
    promptItems: false,
    profiles: false,
    careers: false,
    connections: false,
    changeLogs: false,
    includeOrder: false
  };

  // Item pickers (per section)
  let allPromptItems = [];
  let allUsers = [];
  let allCareers = [];

  const selPromptItemIds = new Set();
  const selUserIds = new Set();
  const selCareerIds = new Set();

  const promptChkMap = new Map();
  const userChkMap = new Map();
  const careerChkMap = new Map();

  const body = document.createElement('div');
  body.className = 'modalBody';

  const info = document.createElement('div');
  info.className = 'hint';
  info.textContent = 'Select items to export. Titles and content are always exported together.';
  body.appendChild(info);

  function mkSection(title){
    const s = document.createElement('div');
    s.className = 'importGroup';
    const h = document.createElement('div');
    h.style.fontWeight = '800';
    h.style.marginBottom = '8px';
    h.textContent = title;
    s.appendChild(h);
    return s;
  }

  function mkChk(label, key){
    const wrap = document.createElement('label');
    wrap.className = 'checkRow';
    const c = document.createElement('input');
    c.type = 'checkbox';
    c.checked = false;
    const span = document.createElement('span');
    span.textContent = label;
    wrap.appendChild(c); wrap.appendChild(span);
    return { wrap, c, key };
  }

  function mkPickList(titleText, helperText) {
    const wrap = document.createElement('div');
    wrap.style.display = 'flex';
    wrap.style.flexDirection = 'column';
    wrap.style.gap = '6px';

    const top = document.createElement('div');
    top.style.display = 'flex';
    top.style.alignItems = 'center';
    top.style.gap = '10px';

    const title = document.createElement('div');
    title.className = 'muted';
    title.style.fontSize = '12px';
    title.style.fontWeight = '700';
    title.textContent = titleText;

    const bAll = document.createElement('button');
    bAll.className = 'btn small';
    bAll.textContent = 'Select all';

    const bClr = document.createElement('button');
    bClr.className = 'btn small';
    bClr.textContent = 'Clear';

    top.appendChild(title);
    top.appendChild(bAll);
    top.appendChild(bClr);
    wrap.appendChild(top);

    const hint = document.createElement('div');
    hint.className = 'muted';
    hint.style.fontSize = '12px';
    hint.textContent = helperText || '';
    wrap.appendChild(hint);

    const rows = document.createElement('div');
    rows.style.display = 'flex';
    rows.style.flexDirection = 'column';
    rows.style.gap = '4px';
    wrap.appendChild(rows);

    return { wrap, rows, hint, bAll, bClr };
  }

  function pickHint(setSize, total){
    if (!total) return '';
    if (setSize === 0) return 'None selected';
    if (setSize === total) return `All ${total} selected`;
    return `${setSize} selected`;
  }

  // --- Prompts ---
  const sPrompts = mkSection('Prompts');
  const promptPick = mkPickList('Prompt items', 'Pick which prompt items to export.');
  sPrompts.appendChild(promptPick.wrap);
  body.appendChild(sPrompts);

  // --- Profiles ---
  const sProfiles = mkSection('Profiles');
  const userPick = mkPickList('Users', 'Pick which users to export (includes their Personal Info).');
  sProfiles.appendChild(userPick.wrap);
  body.appendChild(sProfiles);

  // --- Careers ---
  const sCareers = mkSection('Careers');
  const careerPick = mkPickList('Careers', 'Pick which careers to export (includes their Career Info).');
  sCareers.appendChild(careerPick.wrap);
  body.appendChild(sCareers);

  // --- Other toggles ---
  const sOther = mkSection('Other');
  const cConnections = mkChk('Connections', 'connections'); sOther.appendChild(cConnections.wrap);
  const cLogs = mkChk('Change logs', 'changeLogs'); sOther.appendChild(cLogs.wrap);
  const cOrder = mkChk('Include item order (Setup list order)', 'includeOrder'); sOther.appendChild(cOrder.wrap);
  body.appendChild(sOther);

  function syncFromPicks(){
    opts.promptItems = selPromptItemIds.size > 0;
    opts.profiles = selUserIds.size > 0;
    opts.careers = selCareerIds.size > 0;
    sync();
  }

  function renderPromptPick(){
    promptPick.rows.innerHTML = '';
    promptChkMap.clear();
    if (!allPromptItems.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'No prompt items found.';
      promptPick.rows.appendChild(d);
      promptPick.hint.textContent = '';
      return;
    }
    allPromptItems.forEach(p => {
      const wrap = document.createElement('label');
      wrap.className = 'muted';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '8px';
      wrap.style.fontSize = '12px';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selPromptItemIds.has(p.id);
      cb.onchange = () => {
        if (cb.checked) selPromptItemIds.add(p.id);
        else selPromptItemIds.delete(p.id);
        syncFromPicks();
      };

      const name = document.createElement('span');
      name.textContent = p.title || '(Untitled)';

      wrap.appendChild(cb);
      wrap.appendChild(name);
      promptPick.rows.appendChild(wrap);
      promptChkMap.set(p.id, cb);
    });
    promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
  }

  function renderUserPick(){
    userPick.rows.innerHTML = '';
    userChkMap.clear();
    if (!allUsers.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'No users found.';
      userPick.rows.appendChild(d);
      userPick.hint.textContent = '';
      return;
    }
    allUsers.forEach(u => {
      const wrap = document.createElement('label');
      wrap.className = 'muted';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '8px';
      wrap.style.fontSize = '12px';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selUserIds.has(u.id);
      cb.onchange = () => {
        if (cb.checked) selUserIds.add(u.id);
        else selUserIds.delete(u.id);
        syncFromPicks();
      };

      const name = document.createElement('span');
      name.textContent = u.name || '(Unnamed user)';

      wrap.appendChild(cb);
      wrap.appendChild(name);
      userPick.rows.appendChild(wrap);
      userChkMap.set(u.id, cb);
    });
    userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
  }

  function renderCareerPick(){
    careerPick.rows.innerHTML = '';
    careerChkMap.clear();
    if (!allCareers.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'No careers found.';
      careerPick.rows.appendChild(d);
      careerPick.hint.textContent = '';
      return;
    }
    allCareers.forEach(c => {
      const wrap = document.createElement('label');
      wrap.className = 'muted';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '8px';
      wrap.style.fontSize = '12px';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selCareerIds.has(c.id);
      cb.onchange = () => {
        if (cb.checked) selCareerIds.add(c.id);
        else selCareerIds.delete(c.id);
        syncFromPicks();
      };

      const name = document.createElement('span');
      name.textContent = c.title || '(Untitled career)';

      wrap.appendChild(cb);
      wrap.appendChild(name);
      careerPick.rows.appendChild(wrap);
      careerChkMap.set(c.id, cb);
    });
    careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);
  }

  function selectAllPrompts(){
    selPromptItemIds.clear();
    allPromptItems.forEach(p => selPromptItemIds.add(p.id));
    promptChkMap.forEach(cb => { cb.checked = true; });
    promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
    syncFromPicks();
  }
  function clearPrompts(){
    selPromptItemIds.clear();
    promptChkMap.forEach(cb => { cb.checked = false; });
    promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
    syncFromPicks();
  }
  function selectAllUsers(){
    selUserIds.clear();
    allUsers.forEach(u => selUserIds.add(u.id));
    userChkMap.forEach(cb => { cb.checked = true; });
    userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
    syncFromPicks();
  }
  function clearUsers(){
    selUserIds.clear();
    userChkMap.forEach(cb => { cb.checked = false; });
    userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
    syncFromPicks();
  }
  function selectAllCareers(){
    selCareerIds.clear();
    allCareers.forEach(c => selCareerIds.add(c.id));
    careerChkMap.forEach(cb => { cb.checked = true; });
    careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);
    syncFromPicks();
  }
  function clearCareers(){
    selCareerIds.clear();
    careerChkMap.forEach(cb => { cb.checked = false; });
    careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);
    syncFromPicks();
  }

  promptPick.bAll.addEventListener('click', (e) => { e.preventDefault(); selectAllPrompts(); });
  promptPick.bClr.addEventListener('click', (e) => { e.preventDefault(); clearPrompts(); });
  userPick.bAll.addEventListener('click', (e) => { e.preventDefault(); selectAllUsers(); });
  userPick.bClr.addEventListener('click', (e) => { e.preventDefault(); clearUsers(); });
  careerPick.bAll.addEventListener('click', (e) => { e.preventDefault(); selectAllCareers(); });
  careerPick.bClr.addEventListener('click', (e) => { e.preventDefault(); clearCareers(); });

  // Load pick lists (default: nothing selected)
  (async () => {
    try {
      allPromptItems = await safeGetAll('promptItems');
      allPromptItems.sort((a,b) => (a.title||'').localeCompare(b.title||''));
      renderPromptPick();
    } catch (e) {
      promptPick.rows.innerHTML = '';
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'Failed to load prompt items.';
      promptPick.rows.appendChild(d);
    }

    try {
      allUsers = await safeGetAll('users');
      allUsers.sort((a,b) => (a.name||'').localeCompare(b.name||''));
      renderUserPick();
    } catch (e) {
      userPick.rows.innerHTML = '';
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'Failed to load users.';
      userPick.rows.appendChild(d);
    }

    try {
      allCareers = await safeGetAll('careers');
      allCareers.sort((a,b) => (a.title||'').localeCompare(b.title||''));
      renderCareerPick();
    } catch (e) {
      careerPick.rows.innerHTML = '';
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'Failed to load careers.';
      careerPick.rows.appendChild(d);
    }
  })();

  // Connections toggle: exports connections plus required prompt items and required title templates (no profile/career content forced).
  cConnections.c.onchange = () => {
    opts.connections = cConnections.c.checked;
    sync();
  };
  cLogs.c.onchange = () => { opts.changeLogs = cLogs.c.checked; sync(); };
  cOrder.c.onchange = () => { opts.includeOrder = cOrder.c.checked; sync(); };

  // Footer buttons
  const exportBtn = btn('Export', { primary:true, onClick: async () => {
// Attach filters only when a subset is selected.
if (opts.promptItems && allPromptItems.length && selPromptItemIds.size > 0 && selPromptItemIds.size < allPromptItems.length) {
  opts.promptItemIds = Array.from(selPromptItemIds);
} else {
  delete opts.promptItemIds;
}

if (opts.profiles && allUsers.length && selUserIds.size > 0 && selUserIds.size < allUsers.length) {
  opts.userIds = Array.from(selUserIds);
} else {
  delete opts.userIds;
}

if (opts.careers && allCareers.length && selCareerIds.size > 0 && selCareerIds.size < allCareers.length) {
  opts.careerIds = Array.from(selCareerIds);
} else {
  delete opts.careerIds;
}

// If a section is off, its filter should not apply.
if (!opts.promptItems) delete opts.promptItemIds;
if (!opts.profiles) delete opts.userIds;
if (!opts.careers) delete opts.careerIds;


    closeModal();
    await exportSnapshotJson(opts);
  }});

  const footerBtns = [
    exportBtn,
    btn('Cancel', { onClick: closeModal })
  ];

  function lockPickUI(isLocked){
    // Buttons
    promptPick.bAll.disabled = isLocked;
    promptPick.bClr.disabled = isLocked;
    userPick.bAll.disabled = isLocked;
    userPick.bClr.disabled = isLocked;
    careerPick.bAll.disabled = isLocked;
    careerPick.bClr.disabled = isLocked;

    // Checkboxes
    promptChkMap.forEach(cb => cb.disabled = isLocked);
    userChkMap.forEach(cb => cb.disabled = isLocked);
    careerChkMap.forEach(cb => cb.disabled = isLocked);
  }

  function sync(){
  // Derived section switches (no forced dependencies in the UI).
  opts.promptItems = selPromptItemIds.size > 0;
  opts.profiles = selUserIds.size > 0;
  opts.careers = selCareerIds.size > 0;

  cConnections.c.checked = !!opts.connections;
  cLogs.c.checked = !!opts.changeLogs;
  cOrder.c.checked = !!opts.includeOrder;

  // Never lock pickers; connections export has its own dependency rules in exportSnapshotJson().
  lockPickUI(false);

  // Hints
  if (allPromptItems.length) promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
  if (allUsers.length) userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
  if (allCareers.length) careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);

  info.textContent = 'Select items to export. Titles and content are always exported together.';

  // Enable export only when something meaningful is selected.
  const canExport = !!(opts.promptItems || opts.profiles || opts.careers || opts.connections || opts.changeLogs);
  exportBtn.disabled = !canExport;
}
sync();

  const headerBtns = [
    btn('Select all', { mini:true, onClick: () => {
      // Pick lists
      selPromptItemIds.clear(); allPromptItems.forEach(p => selPromptItemIds.add(p.id));
      selUserIds.clear(); allUsers.forEach(u => selUserIds.add(u.id));
      selCareerIds.clear(); allCareers.forEach(c => selCareerIds.add(c.id));

      // Other toggles
      opts.connections = true;
      opts.changeLogs = true;
      opts.includeOrder = true;

      renderPromptPick();
      renderUserPick();
      renderCareerPick();
      sync();
    }}),
    btn('Unselect all', { mini:true, danger:true, onClick: () => {
      selPromptItemIds.clear();
      selUserIds.clear();
      selCareerIds.clear();

      opts.connections = false;
      opts.changeLogs = false;
      opts.includeOrder = false;

      renderPromptPick();
      renderUserPick();
      renderCareerPick();
      sync();
    }})
  ];
  openModal('Export Snapshot', body, footerBtns, headerBtns);
}

async function openImportWizardFromText(rawText) {
  let s;
  try {
    s = JSON.parse(rawText);
  } catch (e) {
    toast('Invalid JSON snapshot');
    return;
  }

  // Allow wrappers: { snapshot: {...} } or { data: {...} }
  if (s && typeof s === 'object' && (s.snapshot || s.data)) {
    s = s.snapshot || s.data;
  }

  const looksLikeSnapshot =
    s && typeof s === 'object' &&
    (Array.isArray(s.users) || Array.isArray(s.promptItems) || Array.isArray(s.connections) ||
     Array.isArray(s.careers) || Array.isArray(s.personalTemplates) || Array.isArray(s.careerTemplates) ||
     Array.isArray(s.personalItems) || Array.isArray(s.careerBlocks));

  if (!looksLikeSnapshot) {
    toast('This JSON does not look like a MiVida snapshot. Import cancelled.');
    return;
  }

  const snap = normalizeSnapshotForImport(s);
  await openImportWizard(snap);
}

// One-click destructive import: wipe all local data, then import the entire snapshot.
// This intentionally bypasses the import wizard selection UI.
async function wipeLocalAndImportAllFromText(rawText) {
  let s;
  try {
    s = JSON.parse(rawText);
  } catch {
    toast('Invalid JSON snapshot');
    return;
  }

  // Allow wrappers: { snapshot: {...} } or { data: {...} }
  if (s && typeof s === 'object' && (s.snapshot || s.data)) {
    s = s.snapshot || s.data;
  }

  const looksLikeSnapshot =
    s && typeof s === 'object' &&
    (Array.isArray(s.users) || Array.isArray(s.promptItems) || Array.isArray(s.connections) ||
     Array.isArray(s.careers) || Array.isArray(s.personalTemplates) || Array.isArray(s.careerTemplates) ||
     Array.isArray(s.personalItems) || Array.isArray(s.careerBlocks));

  if (!looksLikeSnapshot) {
    toast('This JSON does not look like a MiVida snapshot. Import cancelled.');
    return;
  }

  const snap = normalizeSnapshotForImport(s);

  // Select everything in the snapshot (including empty personal/career content rows).
  const sel = {
    users: new Set((snap.users || []).map(x => x.id)),
    careers: new Set((snap.careers || []).map(x => x.id)),
    promptItems: new Set((snap.promptItems || []).map(x => x.id)),
    connections: new Set((snap.connections || []).map(x => x.id)),

    personalTemplates: new Set((snap.personalTemplates || []).map(t => t.id)),
    careerTemplates: new Set((snap.careerTemplates || []).map(t => t.id)),

    personalContentKeys: new Set(),
    careerContentKeys: new Set(),

    includePersonalContent: true,
    includeCareerContent: true,
    includeUserCareer: true,
  };

  for (const r of snap.personalContent || []) {
    if (!r || !r.userId || !r.templateId) continue;
    sel.personalContentKeys.add(`${r.userId}::${r.templateId}`);
  }
  for (const r of snap.careerContent || []) {
    if (!r || !r.careerId || !r.templateId) continue;
    sel.careerContentKeys.add(`${r.careerId}::${r.templateId}`);
  }

  // Wipe UI-only ordering and remembered selections.
  try {
    localStorage.removeItem(UI_SORT_STORAGE_KEY);
    localStorage.removeItem('mivida_current_user_id');
    localStorage.removeItem('mivida_current_career_id');
    localStorage.removeItem('mivida_prompt_career_id');
  } catch {}

  await importSnapshotSelectionReplace(snap, sel);

  // Restore Setup list order if provided by the snapshot.
  if (snap.uiSort && typeof snap.uiSort === 'object') {
    applyUiSortFromSnapshot(snap.uiSort, 'replace');
  }

  toast('Imported. Local data replaced with JSON snapshot.');
  await refreshAll();
}

function normalizeSnapshotForImport(s) {
  const tNow = nowISO();
  const mkId = () => uid();

  // Personal: prefer v3; fall back to legacy personalItems
  let personalTemplates = Array.isArray(s.personalTemplates) ? s.personalTemplates : [];
  let personalContent = Array.isArray(s.personalContent) ? s.personalContent : [];
  const legacyPersonalItems = Array.isArray(s.personalItems) ? s.personalItems : [];

  if ((!personalTemplates || personalTemplates.length === 0) && legacyPersonalItems.length) {
    const titleToTpl = new Map();
    legacyPersonalItems.forEach(r => {
      const title = (r.title || '').trim();
      if (!title) return;
      if (!titleToTpl.has(title)) {
        titleToTpl.set(title, { id: mkId(), title, createdAt: r.createdAt || tNow, updatedAt: r.updatedAt || r.createdAt || tNow });
      }
    });
    personalTemplates = [...titleToTpl.values()];
    personalContent = legacyPersonalItems.map(r => ({
      userId: r.userId,
      templateId: (titleToTpl.get((r.title || '').trim()) || {}).id,
      content: r.content || '',
      createdAt: r.createdAt || tNow,
      updatedAt: r.updatedAt || r.createdAt || tNow
    })).filter(r => r.userId && r.templateId);
  }

  // Career: prefer v3; fall back to legacy careerBlocks
  let careerTemplates = Array.isArray(s.careerTemplates) ? s.careerTemplates : [];
  let careerContent = Array.isArray(s.careerContent) ? s.careerContent : [];
  const legacyCareerBlocks = Array.isArray(s.careerBlocks) ? s.careerBlocks : [];

  if ((!careerTemplates || careerTemplates.length === 0) && legacyCareerBlocks.length) {
    const titleToTpl = new Map();
    legacyCareerBlocks.forEach(r => {
      const title = (r.title || '').trim();
      if (!title) return;
      if (!titleToTpl.has(title)) {
        titleToTpl.set(title, { id: mkId(), title, createdAt: r.createdAt || tNow, updatedAt: r.updatedAt || r.createdAt || tNow });
      }
    });
    careerTemplates = [...titleToTpl.values()];
    careerContent = legacyCareerBlocks.map(r => ({
      careerId: r.careerId,
      templateId: (titleToTpl.get((r.title || '').trim()) || {}).id,
      content: r.content || '',
      createdAt: r.createdAt || tNow,
      updatedAt: r.updatedAt || r.createdAt || tNow
    })).filter(r => r.careerId && r.templateId);
  }

  return {
    version: s.version || null,
    exportedAt: s.exportedAt || null,
    users: Array.isArray(s.users) ? s.users : [],
    careers: Array.isArray(s.careers) ? s.careers : [],
    userCareer: Array.isArray(s.userCareer) ? s.userCareer : [],
    promptItems: Array.isArray(s.promptItems) ? s.promptItems : [],
    personalTemplates,
    personalContent,
    careerTemplates,
    careerContent,
    connections: Array.isArray(s.connections) ? s.connections : [],
    uiSort: (s.uiSort && typeof s.uiSort === 'object') ? s.uiSort : null,
  };
}

function normTitle(t) {
  return (t || '').trim().toLowerCase();
}

async function openImportWizard(snap) {
  // Existing titles for duplicate warnings
  const existing = {
    users: await getAll('users'),
    careers: await getAll('careers'),
    promptItems: await getAll('promptItems'),
    personalTemplates: await getAll('personalTemplates'),
    careerTemplates: await getAll('careerTemplates'),
    connections: await getAll('connections')
  };

  const existTitles = {
    users: new Set(existing.users.map(u => normTitle(u.name))),
    careers: new Set(existing.careers.map(c => normTitle(c.title))),
    promptItems: new Set(existing.promptItems.map(p => normTitle(p.title))),
    personalTemplates: new Map(existing.personalTemplates.map(t => [normTitle(t.title), t.id])),
    careerTemplates: new Map(existing.careerTemplates.map(t => [normTitle(t.title), t.id])),
    connections: new Set(existing.connections.map(c => normTitle(c.title)))
  };

  // Local objects lookup (for duplicate time comparison)
  const localBy = {
    users: new Map(existing.users.map(u => [normTitle(u.name), u])),
    careers: new Map(existing.careers.map(c => [normTitle(c.title), c])),
    promptItems: new Map(existing.promptItems.map(p => [normTitle(p.title), p])),
    personalTemplates: new Map(existing.personalTemplates.map(t => [normTitle(t.title), t])),
    careerTemplates: new Map(existing.careerTemplates.map(t => [normTitle(t.title), t])),
    connections: new Map(existing.connections.map(c => [normTitle(c.title), c]))
  };

  // Initial selection: select nothing (user will pick what to import)
  const sel = {
    users: new Set(),
    careers: new Set(),
    promptItems: new Set(),
    connections: new Set(),

    // These are imported as needed (selected content + selected connections)
    personalTemplates: new Set(),
    careerTemplates: new Set(),

    // Content selection is per (ownerId, templateId)
    personalContentKeys: new Set(), // `${userId}::${templateId}`
    careerContentKeys: new Set(),   // `${careerId}::${templateId}`

    // Kept for backward compatibility with import functions
    includePersonalContent: false,
    includeCareerContent: false,
    includeUserCareer: true
  };

  // Default: do not preselect any content rows (user will pick what to import)
  sel.includePersonalContent = false;
  sel.includeCareerContent = false;

  const auto = {
    promptItems: new Set(),
    personalTemplates: new Set(),
    careerTemplates: new Set()
  };

  const warningsEl = document.createElement('div');
  warningsEl.className = 'hint';
  warningsEl.style.marginTop = '10px';

  function upsertBadge(slot, key, text, variant='warn'){
    if (!slot) return;
    const q = `[data-badge="${key}"]`;
    let el = slot.querySelector(q);
    if (!text) {
      if (el) el.remove();
      return;
    }
    if (!el) {
      el = document.createElement('span');
      el.className = 'pill';
      el.dataset.badge = key;
      slot.appendChild(el);
    }
    el.textContent = text;
    el.classList.remove('badgeWarn','badgeOk');
    if (variant === 'warn') el.classList.add('badgeWarn');
    if (variant === 'ok') el.classList.add('badgeOk');
  }

  function fmtTime(iso) {
    if (!iso) return '—';
    try { return formatLocal(iso); } catch { return String(iso); }
  }

  // Alias for older import UI code paths
  function fmtLocal(iso) { return fmtTime(iso); }

  function setDupTimesForGroup(group, dupIdSet, localMap, getLabel) {
    group.rowById.forEach((cell, id) => {
      if (!cell || !cell.metaSlot) return;

      if (!dupIdSet.has(id)) {
        cell.metaSlot.innerHTML = '';
        cell.row.title = '';
        return;
      }

      const it = cell.it;
      const key = normTitle(getLabel(it));
      const local = localMap.get(key);

      if (!local) {
        cell.metaSlot.innerHTML = '';
        cell.row.title = '';
        return;
      }

      const localUpdated = local.updatedAt || local.createdAt || null;
      const jsonUpdated = it.updatedAt || it.createdAt || null;

      const lu = localUpdated ? Date.parse(localUpdated) : NaN;
      const ju = jsonUpdated ? Date.parse(jsonUpdated) : NaN;

      let newer = 'same';
      if (!Number.isNaN(lu) && !Number.isNaN(ju)) {
        if (lu > ju) newer = 'local';
        else if (ju > lu) newer = 'json';
      } else if (!Number.isNaN(lu) && Number.isNaN(ju)) {
        newer = 'local';
      } else if (Number.isNaN(lu) && !Number.isNaN(ju)) {
        newer = 'json';
      }

      const statusPill = newer === 'same'
        ? '<span class="pill newerTag">Same</span>'
        : `<span class="pill badgeOk newerTag">${newer === 'local' ? 'Local newer' : 'JSON newer'}</span>`;

      cell.metaSlot.innerHTML = `
        <div>
          Updated:
          <b>Local</b> ${escapeHtml(fmtTime(localUpdated))}
          <span class="muted">·</span>
          <b>JSON</b> ${escapeHtml(fmtTime(jsonUpdated))}
          ${statusPill}
        </div>
      `;

      cell.row.title = 'Duplicate title found. Replace selected will overwrite the local item with the same title or name. Add to local selected will create a new item and automatically rename it to Title (Imported), Title (Imported 2), and so on when needed.';
    });
  }

  function makeGroup(title, items, getLabel, setRef, options={}) {
    const group = document.createElement('div');
    group.className = 'importGroup';

    const head = document.createElement('div');
    head.className = 'importGroupHeader';

    const h = document.createElement('div');
    h.className = 'importGroupTitle';
    h.textContent = title;

    const controls = document.createElement('div');
    controls.className = 'importGroupControls';

    const chkAll = document.createElement('input');
    chkAll.type = 'checkbox';
    chkAll.checked = items.length > 0 && setRef.size === items.length;

    const lblAll = document.createElement('label');
    lblAll.className = 'muted';
    lblAll.style.display = 'flex';
    lblAll.style.alignItems = 'center';
    lblAll.style.gap = '8px';
    lblAll.appendChild(chkAll);
    lblAll.appendChild(document.createTextNode(`Select all (${items.length})`));
    controls.appendChild(lblAll);

    let contentToggle = null;
    let contentHint = null;

    if (options.includeContentToggle) {
      contentToggle = document.createElement('input');
      contentToggle.type = 'checkbox';
      contentToggle.checked = options.includeContentToggle.checked;

      contentToggle.onchange = () => {
        options.includeContentToggle.onChange(contentToggle.checked);
        recompute();
      };

      const lblContent = document.createElement('label');
      lblContent.className = 'muted';
      lblContent.style.display = 'flex';
      lblContent.style.alignItems = 'center';
      lblContent.style.gap = '8px';
      lblContent.appendChild(contentToggle);
      lblContent.appendChild(document.createTextNode(options.includeContentToggle.label));

      contentHint = document.createElement('span');
      contentHint.className = 'pill badgeWarn';
      contentHint.style.display = 'none';
      contentHint.textContent = 'Requires Users';
      lblContent.appendChild(contentHint);

      controls.appendChild(lblContent);
    }

    head.appendChild(h);
    head.appendChild(controls);

    const list = document.createElement('div');
    list.className = 'importRows';

    const rowById = new Map();

    if (!items.length) {
      const empty = document.createElement('div');
      empty.className = 'muted';
      empty.style.fontSize = '12px';
      empty.textContent = 'No items in this snapshot.';
      list.appendChild(empty);
    }

    items.forEach(it => {
      const row = document.createElement('div');
      row.className = 'importRow';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = setRef.has(it.id);
      cb.onchange = () => {
        if (cb.checked) setRef.add(it.id); else setRef.delete(it.id);
        recompute();
      };

      const main = document.createElement('div');
      main.className = 'importMain';

      const titleLine = document.createElement('div');
      titleLine.className = 'importTitleLine';

      const titleDiv = document.createElement('div');
      titleDiv.className = 'importItemTitle';
      titleDiv.textContent = getLabel(it);

      titleLine.appendChild(titleDiv);

      const meta = document.createElement('div');
      meta.className = 'importMeta';

      const badges = document.createElement('div');
      badges.className = 'importBadges';

      main.appendChild(titleLine);
      main.appendChild(meta);
      main.appendChild(badges);

      row.appendChild(cb);
      row.appendChild(main);
      list.appendChild(row);

      rowById.set(it.id, { row, cb, badgeSlot: badges, metaSlot: meta, it, titleDiv });
    });

    chkAll.onchange = () => {
      const v = chkAll.checked;
      items.forEach(it => {
        const cell = rowById.get(it.id);
        if (!cell) return;
        // If auto-included, checkbox may be disabled; keep it checked.
        if (cell.cb.disabled) return;
        cell.cb.checked = v;
        if (v) setRef.add(it.id); else setRef.delete(it.id);
      });
      recompute();
    };

    group.appendChild(head);
    group.appendChild(list);

    return { group, rowById, chkAll, contentToggle, contentHint };
  }




  const container = document.createElement('div');
  container.className = 'importGrid';

  // Maps for quick lookups
  const personalTplById = new Map((snap.personalTemplates || []).map(t => [t.id, t]));
  const careerTplById = new Map((snap.careerTemplates || []).map(t => [t.id, t]));

  const personalContentByUser = new Map();
  for (const r of (snap.personalContent || [])) {
    if (!r || !r.userId || !r.templateId) continue;
    if (!String(r.content || '').trim()) continue; // A mode: only rows with content
    if (!personalContentByUser.has(r.userId)) personalContentByUser.set(r.userId, []);
    personalContentByUser.get(r.userId).push(r);
  }

  const careerContentByCareer = new Map();
  for (const r of (snap.careerContent || [])) {
    if (!r || !r.careerId || !r.templateId) continue;
    if (!String(r.content || '').trim()) continue; // A mode: only rows with content
    if (!careerContentByCareer.has(r.careerId)) careerContentByCareer.set(r.careerId, []);
    careerContentByCareer.get(r.careerId).push(r);
  }

  // Prompt + Connection groups keep the existing flat list UI
  const gPrompts = makeGroup('Prompt Items', snap.promptItems, x => x.title || '(Prompt)', sel.promptItems);
  const gConnections = makeGroup('Connections', snap.connections, x => x.title || '(Connection)', sel.connections);

  function makeOwnerAccordionGroup(opts) {
    const {
      title,
      owners,
      ownerLabel,
      ownerSelectedSet,
      contentByOwner,            // Map(ownerId -> contentRows)
      contentKeyOf,              // (ownerId, templateId) => string key
      contentSelectedSet,
      templateById,
      templateSelectedSet,
      dupOwnerTitlesSet,         // Set(normTitle(...)) for owner duplicates
      dupTemplateTitlesSet       // Set(normTitle(...)) for template duplicates
    } = opts;

    const group = document.createElement('div');
    group.className = 'importGroup';

    const head = document.createElement('div');
    head.className = 'importGroupHeader';

    const t = document.createElement('div');
    t.className = 'importGroupTitle';
    t.textContent = title;

    const controls = document.createElement('div');
    controls.className = 'importGroupControls';

    const btnExpand = btn('Expand', { onClick: () => detailsEls.forEach(d => d.open = true) });
    const btnCollapse = btn('Collapse', { onClick: () => detailsEls.forEach(d => d.open = false) });
    const btnAllOwners = btn('Select all', { onClick: () => {
      owners.forEach(o => ownerSelectedSet.add(o.id));
      // Select all content rows that are visible (has content)
      owners.forEach(o => {
        const rows = contentByOwner.get(o.id) || [];
        rows.forEach(r => {
          const k = contentKeyOf(o.id, r.templateId);
          contentSelectedSet.add(k);
          templateSelectedSet.add(r.templateId);
        });
      });
      syncOwnerUI();
      recompute();
    }});
    const btnNoneOwners = btn('Clear', { danger:true, onClick: () => {
      owners.forEach(o => ownerSelectedSet.delete(o.id));
      // Clear only content keys that belong to these owners
      for (const o of owners) {
        const rows = contentByOwner.get(o.id) || [];
        rows.forEach(r => contentSelectedSet.delete(contentKeyOf(o.id, r.templateId)));
      }
      syncOwnerUI();
      recompute();
    }});

    controls.appendChild(btnExpand);
    controls.appendChild(btnCollapse);
    controls.appendChild(btnAllOwners);
    controls.appendChild(btnNoneOwners);

    head.appendChild(t);
    head.appendChild(controls);

    const acc = document.createElement('div');
    acc.className = 'importAccordion';

    const detailsEls = [];
    const ownerUI = new Map(); // ownerId -> {cbOwner, rowCbs: Map(key -> cb)}

    function syncOwnerUI() {
      ownerUI.forEach((ui, ownerId) => {
        ui.cbOwner.checked = ownerSelectedSet.has(ownerId);
        ui.rowCbs.forEach((cb, key) => {
          cb.checked = contentSelectedSet.has(key);
        });
      });
    }

    owners.forEach(o => {
      const det = document.createElement('details');
      detailsEls.push(det);

      const sum = document.createElement('summary');

      const left = document.createElement('div');
      left.className = 'importAccSummaryLeft';

      const cbOwner = document.createElement('input');
      cbOwner.type = 'checkbox';
      cbOwner.checked = ownerSelectedSet.has(o.id);
      cbOwner.onchange = () => {
        if (cbOwner.checked) ownerSelectedSet.add(o.id);
        else {
          ownerSelectedSet.delete(o.id);
          // If owner is unchecked, clear its selected content keys
          const rows = contentByOwner.get(o.id) || [];
          rows.forEach(r => contentSelectedSet.delete(contentKeyOf(o.id, r.templateId)));
        }
        syncOwnerUI();
        recompute();
      };

      const name = document.createElement('div');
      name.className = 'importAccName';
      name.textContent = ownerLabel(o);

      // Inline duplicate badge (owner)
      if (dupOwnerTitlesSet && dupOwnerTitlesSet.has(normTitle(ownerLabel(o)))) {
        const b = document.createElement('span');
        b.className = 'pill warn';
        b.textContent = 'Duplicate';
        name.appendChild(b);
      }

      const rows = contentByOwner.get(o.id) || [];
      const counts = document.createElement('div');
      counts.className = 'importAccCounts';
      counts.textContent = `${rows.length} item${rows.length === 1 ? '' : 's'}`;

      left.appendChild(cbOwner);
      left.appendChild(name);
      left.appendChild(counts);

      sum.appendChild(left);
      det.appendChild(sum);

      const body = document.createElement('div');
      body.className = 'importAccBody';

      const tools = document.createElement('div');
      tools.className = 'importAccTools';

      const hint = document.createElement('div');
      hint.className = 'muted';
      hint.textContent = rows.length ? 'Select the items you want to import for this owner.' : 'No content items found in JSON for this owner.';

      const toolBtns = document.createElement('div');
      toolBtns.style.display = 'flex';
      toolBtns.style.gap = '8px';
      toolBtns.style.flexWrap = 'wrap';

      const btnAll = btn('All', { onClick: () => {
        ownerSelectedSet.add(o.id);
        rows.forEach(r => {
          const k = contentKeyOf(o.id, r.templateId);
          contentSelectedSet.add(k);
          templateSelectedSet.add(r.templateId);
        });
        syncOwnerUI();
        recompute();
      }});
      const btnNone = btn('None', { onClick: () => {
        rows.forEach(r => contentSelectedSet.delete(contentKeyOf(o.id, r.templateId)));
        syncOwnerUI();
        recompute();
      }});
      toolBtns.appendChild(btnAll);
      toolBtns.appendChild(btnNone);

      tools.appendChild(hint);
      tools.appendChild(toolBtns);

      body.appendChild(tools);

      const list = document.createElement('div');
      list.className = 'importRows';

      const rowCbs = new Map();

      // Sort by template title for readability
      rows.slice().sort((a,b) => {
        const at = (templateById.get(a.templateId)?.title || '').toLowerCase();
        const bt = (templateById.get(b.templateId)?.title || '').toLowerCase();
        return at.localeCompare(bt);
      }).forEach(r => {
        const tpl = templateById.get(r.templateId);
        const row = document.createElement('div');
        row.className = 'importRow';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        const key = contentKeyOf(o.id, r.templateId);
        cb.checked = contentSelectedSet.has(key);

        cb.onchange = () => {
          if (cb.checked) {
            ownerSelectedSet.add(o.id);
            contentSelectedSet.add(key);
            templateSelectedSet.add(r.templateId);
          } else {
            contentSelectedSet.delete(key);
          }
          syncOwnerUI();
          recompute();
        };

        const main = document.createElement('div');
        main.className = 'importMain';

        const tl = document.createElement('div');
        tl.className = 'importTitleLine';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'importItemTitle';
        titleDiv.textContent = tpl?.title || '(Item)';

        tl.appendChild(titleDiv);

        // Inline duplicate badge (template title)
        if (dupTemplateTitlesSet && dupTemplateTitlesSet.has(normTitle(tpl?.title || ''))) {
          const bb = document.createElement('span');
          bb.className = 'pill warn';
          bb.textContent = 'Duplicate title';
          tl.appendChild(bb);
        }

        const meta = document.createElement('div');
        meta.className = 'importMeta';
        meta.textContent = `Last updated: ${fmtLocal(r.updatedAt || r.createdAt || '')} · JSON`;

        main.appendChild(tl);
        main.appendChild(meta);

        row.appendChild(cb);
        row.appendChild(main);
        list.appendChild(row);
        rowCbs.set(key, cb);
      });

      body.appendChild(list);
      det.appendChild(body);

      acc.appendChild(det);
      ownerUI.set(o.id, { cbOwner, rowCbs });
    });

    group.appendChild(head);
    group.appendChild(acc);

    // Expose details nodes for controls
    group._detailsEls = detailsEls;

    return { group, detailsEls, syncOwnerUI };
  }

  // Duplicate sets
  const dupUserNames = new Set(snap.users.filter(u => existTitles.users.has(normTitle(u.name))).map(u => normTitle(u.name)));
  const dupCareerTitles = new Set(snap.careers.filter(c => existTitles.careers.has(normTitle(c.title))).map(c => normTitle(c.title)));
  const dupPTitles = new Set((snap.personalTemplates || []).filter(t => existTitles.personalTemplates.has(normTitle(t.title))).map(t => normTitle(t.title)));
  const dupCTitles = new Set((snap.careerTemplates || []).filter(t => existTitles.careerTemplates.has(normTitle(t.title))).map(t => normTitle(t.title)));

  const gUsersAcc = makeOwnerAccordionGroup({
    title: 'Users',
    owners: snap.users,
    ownerLabel: o => o.name || '(Unnamed)',
    ownerSelectedSet: sel.users,
    contentByOwner: personalContentByUser,
    contentKeyOf: (userId, templateId) => `${userId}::${templateId}`,
    contentSelectedSet: sel.personalContentKeys,
    templateById: personalTplById,
    templateSelectedSet: sel.personalTemplates,
    dupOwnerTitlesSet: dupUserNames,
    dupTemplateTitlesSet: dupPTitles
  });

  const gCareersAcc = makeOwnerAccordionGroup({
    title: 'Careers',
    owners: snap.careers,
    ownerLabel: o => o.title || '(Career)',
    ownerSelectedSet: sel.careers,
    contentByOwner: careerContentByCareer,
    contentKeyOf: (careerId, templateId) => `${careerId}::${templateId}`,
    contentSelectedSet: sel.careerContentKeys,
    templateById: careerTplById,
    templateSelectedSet: sel.careerTemplates,
    dupOwnerTitlesSet: dupCareerTitles,
    dupTemplateTitlesSet: dupCTitles
  });

  // Grid order
  container.appendChild(gUsersAcc.group);
  container.appendChild(gPrompts.group);
  container.appendChild(gCareersAcc.group);
  container.appendChild(gConnections.group);

  const footer = document.createElement('div');
  footer.className = 'importFooterFull';

  const note = document.createElement('div');
  note.className = 'hint';
  note.style.marginTop = '0px';
  // Hidden by default: Connection imports only depend on titles; content is optional.
  note.textContent = '';
  note.style.display = 'none';
  footer.appendChild(note);

  const warnWrap = document.createElement('div');
  warnWrap.className = 'importGroup';
  warnWrap.style.marginTop = '12px';
  warnWrap.innerHTML = `<div style="font-weight:700;">Warnings (non-blocking)</div>`;
  warnWrap.appendChild(warningsEl);
  footer.appendChild(warnWrap);

  container.appendChild(footer);

  function recompute() {
    // Reset auto sets
    auto.promptItems.clear();
    auto.personalTemplates.clear();
    auto.careerTemplates.clear();

    // Auto include dependencies for selected connections
    const connById = new Map(snap.connections.map(c => [c.id, c]));
    sel.connections.forEach(cid => {
      const c = connById.get(cid);
      if (!c) return;
      (c.promptItemIds || []).forEach(id => { if (!sel.promptItems.has(id)) auto.promptItems.add(id); });
      // Note: Connection dependencies only auto-include prompt items.
      // Personal/Career *titles* referenced by a Connection are ensured during import; content is optional.
    });

    // Apply auto includes for prompts (UI check + disable)
    function applyAuto(group, setSel, setAuto) {
      group.rowById.forEach((cell, id) => {
        if (setAuto.has(id)) {
          cell.cb.checked = true;
          cell.cb.disabled = true;
          setSel.add(id);
          cell.row.classList.add('auto');
          cell.row.title = 'Auto-included by selected Connection(s)';
          upsertBadge(cell.badgeSlot, 'auto', 'Auto', 'ok');
        } else {
          cell.cb.disabled = false;
          cell.row.classList.remove('auto');
          cell.row.title = '';
          upsertBadge(cell.badgeSlot, 'auto', null);
        }
      });
    }
    applyAuto(gPrompts, sel.promptItems, auto.promptItems);

    // Content flags
    sel.includePersonalContent = (sel.personalContentKeys && sel.personalContentKeys.size > 0);
    sel.includeCareerContent = (sel.careerContentKeys && sel.careerContentKeys.size > 0);

    // User↔Career mapping only makes sense if both are imported
    const usersSelected = sel.users.size > 0;
    const careersSelected = sel.careers.size > 0;
    sel.includeUserCareer = usersSelected && careersSelected;

    // Keep accordion UI synced
    gUsersAcc.syncOwnerUI();
    gCareersAcc.syncOwnerUI();

    // Inline warnings for prompts + connections
    const dupPromptsAll = new Set(snap.promptItems.filter(p => existTitles.promptItems.has(normTitle(p.title))).map(p => p.id));
    const dupConnsAll = new Set(snap.connections.filter(c => existTitles.connections.has(normTitle(c.title))).map(c => c.id));
    function markWarn(group, ids, label, variant='warn'){
      group.rowById.forEach((cell, id) => {
        upsertBadge(cell.badgeSlot, 'warn', ids.has(id) ? label : null, variant);
      });
    }
    markWarn(gPrompts, dupPromptsAll, 'Duplicate title', 'warn');
    markWarn(gConnections, dupConnsAll, 'Duplicate title', 'warn');

    // Duplicate time comparison (Local vs JSON) for duplicates
    setDupTimesForGroup(gPrompts, dupPromptsAll, localBy.promptItems, x => x.title || '');
    setDupTimesForGroup(gConnections, dupConnsAll, localBy.connections, x => x.title || '');

    // Warnings summary (non-blocking)
    const warnings = [];

    // Auto include summary
    const autoMsgs = [];
    if (auto.promptItems.size) autoMsgs.push(`Auto-included prompt items: ${auto.promptItems.size}`);
    if (autoMsgs.length) warnings.push(autoMsgs.join(' · '));

    // Duplicate top-level entities
    const dupUsers = snap.users.filter(u => sel.users.has(u.id) && existTitles.users.has(normTitle(u.name)));
    if (dupUsers.length) warnings.push(`Users with duplicate name: ${dupUsers.map(u => u.name).slice(0,8).join(', ')}${dupUsers.length>8?'…':''}`);

    const dupCareers = snap.careers.filter(c => sel.careers.has(c.id) && existTitles.careers.has(normTitle(c.title)));
    if (dupCareers.length) warnings.push(`Careers with duplicate title: ${dupCareers.map(c => c.title).slice(0,8).join(', ')}${dupCareers.length>8?'…':''}`);

    const dupPrompts = snap.promptItems.filter(p => sel.promptItems.has(p.id) && existTitles.promptItems.has(normTitle(p.title)));
    if (dupPrompts.length) warnings.push(`Prompt items with duplicate title: ${dupPrompts.map(p => p.title).slice(0,8).join(', ')}${dupPrompts.length>8?'…':''}`);

    const dupConns = snap.connections.filter(c => sel.connections.has(c.id) && existTitles.connections.has(normTitle(c.title)));
    if (dupConns.length) warnings.push(`Connections with duplicate title: ${dupConns.map(c => c.title).slice(0,8).join(', ')}${dupConns.length>8?'…':''}`);

    // Template duplicates (selected)
    const dupPT = (snap.personalTemplates || []).filter(t => sel.personalTemplates.has(t.id) && existTitles.personalTemplates.has(normTitle(t.title)));
    if (dupPT.length) warnings.push(`Personal item titles duplicated: ${dupPT.map(t => t.title).slice(0,8).join(', ')}${dupPT.length>8?'…':''}`);

    const dupCT = (snap.careerTemplates || []).filter(t => sel.careerTemplates.has(t.id) && existTitles.careerTemplates.has(normTitle(t.title)));
    if (dupCT.length) warnings.push(`Career item titles duplicated: ${dupCT.map(t => t.title).slice(0,8).join(', ')}${dupCT.length>8?'…':''}`);

    warningsEl.innerHTML = warnings.length ? ('• ' + warnings.join('<br>• ')) : '<span class="muted">No warnings.</span>';
  }

  recompute();

  const headerBtns = [
    btn('Select all', { mini:true, onClick: () => {
      try {
        // Owners
        sel.users.clear(); (snap.users || []).forEach(u => sel.users.add(u.id));
        sel.careers.clear(); (snap.careers || []).forEach(c => sel.careers.add(c.id));

        // Prompts + Connections
        sel.promptItems.clear(); (snap.promptItems || []).forEach(p => sel.promptItems.add(p.id));
        sel.connections.clear(); (snap.connections || []).forEach(c => sel.connections.add(c.id));

        // Templates
        sel.personalTemplates.clear(); (snap.personalTemplates || []).forEach(t => sel.personalTemplates.add(t.id));
        sel.careerTemplates.clear(); (snap.careerTemplates || []).forEach(t => sel.careerTemplates.add(t.id));

        // Content keys
        sel.personalContentKeys.clear();
        personalContentByUser.forEach((rows, ownerId) => {
          (rows || []).forEach(r => {
            sel.personalContentKeys.add(`${ownerId}::${r.templateId}`);
            sel.personalTemplates.add(r.templateId);
          });
        });

        sel.careerContentKeys.clear();
        careerContentByCareer.forEach((rows, ownerId) => {
          (rows || []).forEach(r => {
            sel.careerContentKeys.add(`${ownerId}::${r.templateId}`);
            sel.careerTemplates.add(r.templateId);
          });
        });

        // Sync flat group UI
        gPrompts.rowById.forEach(cell => { cell.cb.checked = true; });
        gPrompts.chkAll.checked = true;
        gConnections.rowById.forEach(cell => { cell.cb.checked = true; });
        gConnections.chkAll.checked = true;

        // Sync accordion UIs
        gUsersAcc.syncOwnerUI();
        gCareersAcc.syncOwnerUI();

        recompute();
      } catch (e) {
        console.error(e);
        toast('Select all failed: ' + (e?.message || String(e)));
      }
    }}),
    btn('Unselect all', { mini:true, danger:true, onClick: () => {
      try {
        sel.users.clear();
        sel.careers.clear();
        sel.promptItems.clear();
        sel.connections.clear();
        sel.personalTemplates.clear();
        sel.careerTemplates.clear();
        sel.personalContentKeys.clear();
        sel.careerContentKeys.clear();

        gPrompts.rowById.forEach(cell => { cell.cb.checked = false; cell.cb.disabled = false; });
        gPrompts.chkAll.checked = false;
        gConnections.rowById.forEach(cell => { cell.cb.checked = false; cell.cb.disabled = false; });
        gConnections.chkAll.checked = false;

        gUsersAcc.syncOwnerUI();
        gCareersAcc.syncOwnerUI();

        recompute();
      } catch (e) {
        console.error(e);
        toast('Unselect all failed: ' + (e?.message || String(e)));
      }
    }})
  ];

  const footerButtons = [

    btn('Replace selected', { danger:true, onClick: async () => {
      const ok = confirm('Replace selected will update only the items you checked. If a local item with the same title or name exists, it will be overwritten with the JSON content. If it does not exist locally, it will be added as a new item. Unselected local items are not changed. Continue?');
      if (!ok) return;
      try {
        await importSnapshotSelectionReplaceOverwrite(snap, sel);
        closeModal();
        toast('Replace import completed');
        await refreshAll();
      } catch (e) {
        console.error(e);
        toast('Replace import failed: ' + (e?.message || String(e)));
      }
    }}),
    btn('Add to local selected', { primary:true, onClick: async () => {
      try {
        await importSnapshotSelectionAddToLocal(snap, sel);
        closeModal();
        toast('Add to local import completed');
        await refreshAll();
      } catch (e) {
        console.error(e);
        toast('Add to local import failed: ' + (e?.message || String(e)));
      }
    }})
  ];

  openModal('Import Snapshot', container, footerButtons, headerBtns);
}



async function importSnapshotSelectionAddToLocal(snap, sel) {
  const now = nowISO();

  // Defensive defaults (older callers)
  sel = sel || {};
  sel.users = sel.users || new Set();
  sel.careers = sel.careers || new Set();
  sel.promptItems = sel.promptItems || new Set();
  sel.connections = sel.connections || new Set();
  sel.personalTemplates = sel.personalTemplates || new Set();
  sel.careerTemplates = sel.careerTemplates || new Set();
  sel.personalContentKeys = sel.personalContentKeys || new Set();
  sel.careerContentKeys = sel.careerContentKeys || new Set();

  // Ensure templates referenced by selected connections are included (so connections can be reconstructed)
  try {
    const needPT = new Set();
    const needCT = new Set();
    for (const c of (snap.connections || [])) {
      if (!sel.connections || !sel.connections.has(c.id)) continue;
      (c.personalTemplateIds || []).forEach(id => needPT.add(id));
      (c.careerTemplateIds || []).forEach(id => needCT.add(id));
    }
    needPT.forEach(id => sel.personalTemplates.add(id));
    needCT.forEach(id => sel.careerTemplates.add(id));
  } catch {}

  // Load local data for merge-by-title/name behavior
  const localUsers = await getAll('users');
  const localCareers = await getAll('careers');
  const localPrompts = await getAll('promptItems');
  const localPT = await getAll('personalTemplates');
  const localCT = await getAll('careerTemplates');
  const localConns = await getAll('connections');

  const by = {
    users: new Map(localUsers.map(u => [normTitle(u.name), u])),
    careers: new Map(localCareers.map(c => [normTitle(c.title), c])),
    promptItems: new Map(localPrompts.map(p => [normTitle(p.title), p])),
    personalTemplates: new Map(localPT.map(t => [normTitle(t.title), t])),
    careerTemplates: new Map(localCT.map(t => [normTitle(t.title), t])),
    connections: new Map(localConns.map(c => [normTitle(c.title), c]))
  };

  // Title sets for unique naming where we intentionally create duplicates (prompts/connections)
  const titleSets = {
    users: new Set(localUsers.map(u => normTitle(u.name))),
    careers: new Set(localCareers.map(c => normTitle(c.title))),
    promptItems: new Set(localPrompts.map(p => normTitle(p.title))),
    personalTemplates: new Set(localPT.map(t => normTitle(t.title))),
    careerTemplates: new Set(localCT.map(t => normTitle(t.title))),
    connections: new Set(localConns.map(c => normTitle(c.title)))
  };

  // Snapshot lookups
  const snapBy = {
    users: new Map((snap.users || []).map(u => [u.id, u])),
    careers: new Map((snap.careers || []).map(c => [c.id, c])),
    personalTemplates: new Map((snap.personalTemplates || []).map(t => [t.id, t])),
    careerTemplates: new Map((snap.careerTemplates || []).map(t => [t.id, t]))
  };

  // Old -> local/new IDs (merge-aware)
  const idMap = {
    users: new Map(),
    careers: new Map(),
    promptItems: new Map(),
    personalTemplates: new Map(),
    careerTemplates: new Map(),
    connections: new Map()
  };

  function makeImportedTitle(raw, set) {
    const base = (raw || '').trim() || 'Untitled';
    let i = 1;
    let cand = `${base} (Imported)`;
    while (set.has(normTitle(cand))) {
      i += 1;
      cand = `${base} (Imported ${i})`;
    }
    set.add(normTitle(cand));
    return cand;
  }

  
  async function ensurePromptItemForConnection(oldPromptId) {
    if (!oldPromptId) return null;
    if (idMap.promptItems.has(oldPromptId)) return idMap.promptItems.get(oldPromptId);

    const p = snapBy.promptItems.get(oldPromptId);
    if (!p) return null;

    const key = normTitle(p.title);
    const existing = by.promptItems.get(key);
    if (existing) {
      idMap.promptItems.set(oldPromptId, existing.id);
      return existing.id;
    }

    // Create only if it truly doesn't exist locally
    const newId = uid();
    const titleRaw = (p.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.promptItems.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.promptItems)
      : (titleSets.promptItems.add(normTitle(titleRaw)), titleRaw);

    const row = { ...p, id: newId, title: finalTitle, createdAt: p.createdAt || now, updatedAt: p.updatedAt || p.createdAt || now };
    await putOne('promptItems', row);
    by.promptItems.set(normTitle(finalTitle), row);
    idMap.promptItems.set(oldPromptId, newId);
    return newId;
  }

async function ensurePersonalTemplate(oldTplId) {
    if (!oldTplId) return null;
    if (idMap.personalTemplates.has(oldTplId)) return idMap.personalTemplates.get(oldTplId);

    const tpl = snapBy.personalTemplates.get(oldTplId);
    if (!tpl) return null;

    const key = normTitle(tpl.title);
    const existing = by.personalTemplates.get(key);
    if (existing) {
      idMap.personalTemplates.set(oldTplId, existing.id);
      return existing.id;
    }

    // Create only if it truly doesn't exist locally
    const newId = uid();
    const titleRaw = (tpl.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.personalTemplates.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.personalTemplates)
      : (titleSets.personalTemplates.add(normTitle(titleRaw)), titleRaw);

    const row = { ...tpl, id: newId, title: finalTitle, createdAt: tpl.createdAt || now, updatedAt: tpl.updatedAt || tpl.createdAt || now };
    await putOne('personalTemplates', row);
    by.personalTemplates.set(normTitle(finalTitle), row);
    idMap.personalTemplates.set(oldTplId, newId);
    return newId;
  }

  async function ensureCareerTemplate(oldTplId) {
    if (!oldTplId) return null;
    if (idMap.careerTemplates.has(oldTplId)) return idMap.careerTemplates.get(oldTplId);

    const tpl = snapBy.careerTemplates.get(oldTplId);
    if (!tpl) return null;

    const key = normTitle(tpl.title);
    const existing = by.careerTemplates.get(key);
    if (existing) {
      idMap.careerTemplates.set(oldTplId, existing.id);
      return existing.id;
    }

    const newId = uid();
    const titleRaw = (tpl.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.careerTemplates.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.careerTemplates)
      : (titleSets.careerTemplates.add(normTitle(titleRaw)), titleRaw);

    const row = { ...tpl, id: newId, title: finalTitle, createdAt: tpl.createdAt || now, updatedAt: tpl.updatedAt || tpl.createdAt || now };
    await putOne('careerTemplates', row);
    by.careerTemplates.set(normTitle(finalTitle), row);
    idMap.careerTemplates.set(oldTplId, newId);
    return newId;
  }

  function mapUserId(oldUserId) {
    if (!oldUserId) return null;
    const m = idMap.users.get(oldUserId);
    if (m) return m;
    const u = snapBy.users.get(oldUserId);
    if (!u) return null;
    const ex = by.users.get(normTitle(u.name));
    return ex ? ex.id : null;
  }

  function mapCareerId(oldCareerId) {
    if (!oldCareerId) return null;
    const m = idMap.careers.get(oldCareerId);
    if (m) return m;
    const c = snapBy.careers.get(oldCareerId);
    if (!c) return null;
    const ex = by.careers.get(normTitle(c.title));
    return ex ? ex.id : null;
  }

  // 1) Users (merge by name; avoid duplicates)
  for (const u of (snap.users || [])) {
    if (!sel.users || !sel.users.has(u.id)) continue;
    const key = normTitle(u.name);
    const existing = by.users.get(key);
    if (existing) {
      idMap.users.set(u.id, existing.id);
      continue;
    }
    const newId = uid();
    idMap.users.set(u.id, newId);
    const nameRaw = (u.name || '').trim() || 'Untitled';
    const finalName = titleSets.users.has(normTitle(nameRaw))
      ? makeImportedTitle(nameRaw, titleSets.users)
      : (titleSets.users.add(normTitle(nameRaw)), nameRaw);
    const row = { ...u, id: newId, name: finalName, createdAt: u.createdAt || now, updatedAt: u.updatedAt || u.createdAt || now };
    await putOne('users', row);
    by.users.set(normTitle(finalName), row);
  }

  // 2) Careers (merge by title; avoid duplicates)
  for (const c of (snap.careers || [])) {
    if (!sel.careers || !sel.careers.has(c.id)) continue;
    const key = normTitle(c.title);
    const existing = by.careers.get(key);
    if (existing) {
      idMap.careers.set(c.id, existing.id);
      continue;
    }
    const newId = uid();
    idMap.careers.set(c.id, newId);
    const titleRaw = (c.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.careers.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.careers)
      : (titleSets.careers.add(normTitle(titleRaw)), titleRaw);
    const row = { ...c, id: newId, title: finalTitle, createdAt: c.createdAt || now, updatedAt: c.updatedAt || c.createdAt || now };
    await putOne('careers', row);
    by.careers.set(normTitle(finalTitle), row);
  }

  // 3) Prompt items (allow duplicates by renaming)
  for (const p of (snap.promptItems || [])) {
    if (!sel.promptItems || !sel.promptItems.has(p.id)) continue;
    const newId = uid();
    idMap.promptItems.set(p.id, newId);
    const title = titleSets.promptItems.has(normTitle(p.title))
      ? makeImportedTitle(p.title, titleSets.promptItems)
      : (titleSets.promptItems.add(normTitle(p.title)), (p.title || '').trim() || 'Untitled');
    await putOne('promptItems', { ...p, id: newId, title, createdAt: p.createdAt || now, updatedAt: p.updatedAt || p.createdAt || now });
  }

  // 4) Personal templates (merge by title; avoid duplicates)
  for (const t of (snap.personalTemplates || [])) {
    if (!sel.personalTemplates || !sel.personalTemplates.has(t.id)) continue;
    await ensurePersonalTemplate(t.id);
  }

  // 5) Career templates (merge by title; avoid duplicates)
  for (const t of (snap.careerTemplates || [])) {
    if (!sel.careerTemplates || !sel.careerTemplates.has(t.id)) continue;
    await ensureCareerTemplate(t.id);
  }

  // 6) Personal content (map to merged users/templates; overwrite same key)
  if (sel.personalContentKeys && sel.personalContentKeys.size) {
    for (const r of (snap.personalContent || [])) {
      const _k = `${r.userId}::${r.templateId}`;
      if (!sel.personalContentKeys.has(_k)) continue;

      const userNew = mapUserId(r.userId);
      if (!userNew) continue;

      const tplNew = await ensurePersonalTemplate(r.templateId);
      if (!tplNew) continue;

      await putOne('personalContent', {
        ...r,
        userId: userNew,
        templateId: tplNew,
        content: r.content || '',
        createdAt: r.createdAt || now,
        updatedAt: r.updatedAt || r.createdAt || now
      });
    }
  }

  // 7) Career content (map to merged careers/templates; overwrite same key)
  if (sel.careerContentKeys && sel.careerContentKeys.size) {
    for (const r of (snap.careerContent || [])) {
      const _k = `${r.careerId}::${r.templateId}`;
      if (!sel.careerContentKeys.has(_k)) continue;

      const careerNew = mapCareerId(r.careerId);
      if (!careerNew) continue;

      const tplNew = await ensureCareerTemplate(r.templateId);
      if (!tplNew) continue;

      await putOne('careerContent', {
        ...r,
        careerId: careerNew,
        templateId: tplNew,
        content: r.content || '',
        createdAt: r.createdAt || now,
        updatedAt: r.updatedAt || r.createdAt || now
      });
    }
  }

  // 8) User -> Career mapping (optional, merge-aware)
  if (sel.includeUserCareer) {
    for (const r of (snap.userCareer || [])) {
      const userNew = mapUserId(r.userId);
      const careerNew = mapCareerId(r.careerId);
      if (!userNew || !careerNew) continue;
      await putOne('userCareer', { ...r, userId: userNew, careerId: careerNew });
    }
  }

  // 9) Connections (allow duplicates by renaming; map referenced IDs)
  for (const c of (snap.connections || [])) {
    if (!sel.connections || !sel.connections.has(c.id)) continue;
    const newId = uid();
    idMap.connections.set(c.id, newId);

    const title = titleSets.connections.has(normTitle(c.title))
      ? makeImportedTitle(c.title, titleSets.connections)
      : (titleSets.connections.add(normTitle(c.title)), (c.title || '').trim() || 'Untitled');

        const promptItemIds = [];
    for (const pid of (c.promptItemIds || [])) {
      const mapped = await ensurePromptItemForConnection(pid);
      if (mapped) promptItemIds.push(mapped);
    }

    const personalTemplateIds = [];
    for (const tid of (c.personalTemplateIds || [])) {
      const mapped = await ensurePersonalTemplate(tid);
      if (mapped) personalTemplateIds.push(mapped);
    }

    const careerTemplateIds = [];
    for (const tid of (c.careerTemplateIds || [])) {
      const mapped = await ensureCareerTemplate(tid);
      if (mapped) careerTemplateIds.push(mapped);
    }

    await putOne('connections', {
      ...c,
      id: newId,
      title,
      promptItemIds,
      personalTemplateIds,
      careerTemplateIds,
      createdAt: c.createdAt || now,
      updatedAt: c.updatedAt || c.createdAt || now
    });
  }
  // Fix template output↔connection links when imported connections get new IDs.
  // We first try id remapping via idMap.connections (best for Add mode), then fall back to title matching.
  const _connsNow = await getAll('connections');
  const _connByTitleNow = new Map((_connsNow || []).map(c => [normTitle(c.title), c]));

  async function _fixTemplateOutputLinks(storeName, snapArr, selSet, tplIdMap) {
    for (const t of (snapArr || [])) {
      if (!selSet || !selSet.has(t.id)) continue;
      const newTplId = tplIdMap.get(t.id);
      if (!newTplId) continue;

      const rec = await getOne(storeName, newTplId);
      if (!rec) continue;
      if (rec.isOutput === false) continue;

      const oldConnId = String(rec.outputConnectionId || '');
      let resolved = '';

      if (oldConnId && idMap.connections && idMap.connections.has(oldConnId)) {
        resolved = idMap.connections.get(oldConnId);
      }

      if (!resolved) {
        const title = String(rec.outputConnectionTitle || t.outputConnectionTitle || '');
        if (title) {
          const hit = _connByTitleNow.get(normTitle(title));
          if (hit) resolved = hit.id;
        }
      }

      if (resolved && resolved !== rec.outputConnectionId) {
        await putOne(storeName, { ...rec, outputConnectionId: resolved, updatedAt: nowISO() });
      }
    }
  }

  await _fixTemplateOutputLinks('personalTemplates', snap.personalTemplates, sel.personalTemplates, idMap.personalTemplates);
  await _fixTemplateOutputLinks('careerTemplates', snap.careerTemplates, sel.careerTemplates, idMap.careerTemplates);

}
async function importSnapshotSelectionReplaceOverwrite(snap, sel) {
  const now = nowISO();
  const idMap = {
    users: new Map(),
    careers: new Map(),
    promptItems: new Map(),
    personalTemplates: new Map(),
    careerTemplates: new Map(),
    connections: new Map()
  };

  // Local lookups by title/name (normalized)
  const localUsers = await getAll('users');
  const localCareers = await getAll('careers');
  const localPrompts = await getAll('promptItems');
  const localPT = await getAll('personalTemplates');
  const localCT = await getAll('careerTemplates');
  const localConns = await getAll('connections');

  const by = {
    users: new Map(localUsers.map(u => [normTitle(u.name), u])),
    careers: new Map(localCareers.map(c => [normTitle(c.title), c])),
    promptItems: new Map(localPrompts.map(p => [normTitle(p.title), p])),
    personalTemplates: new Map(localPT.map(t => [normTitle(t.title), t])),
    careerTemplates: new Map(localCT.map(t => [normTitle(t.title), t])),
    connections: new Map(localConns.map(c => [normTitle(c.title), c])),
  };

  async function ensureUniqueId(storeName, proposedId) {
    const found = await getOne(storeName, proposedId);
    if (!found) return proposedId;
    return uid();
  }

  function keepCreated(local, incoming) {
    return local?.createdAt || incoming?.createdAt || now;
  }

  // 1) Users (match by name)
  for (const u of snap.users) {
    if (!sel.users.has(u.id)) continue;
    const key = normTitle(u.name);
    const local = by.users.get(key);
    if (local) {
      const id = local.id;
      idMap.users.set(u.id, id);
      await putOne('users', { ...local, ...u, id, name: u.name, createdAt: keepCreated(local, u), updatedAt: u.updatedAt || now });
    } else {
      const id = await ensureUniqueId('users', u.id);
      idMap.users.set(u.id, id);
      await putOne('users', { ...u, id, createdAt: u.createdAt || now, updatedAt: u.updatedAt || now });
      by.users.set(key, { ...u, id });
    }
  }

  // 2) Careers (match by title)
  for (const c of snap.careers) {
    if (!sel.careers.has(c.id)) continue;
    const key = normTitle(c.title);
    const local = by.careers.get(key);
    if (local) {
      const id = local.id;
      idMap.careers.set(c.id, id);
      await putOne('careers', { ...local, ...c, id, title: c.title, createdAt: keepCreated(local, c), updatedAt: c.updatedAt || now });
    } else {
      const id = await ensureUniqueId('careers', c.id);
      idMap.careers.set(c.id, id);
      await putOne('careers', { ...c, id, createdAt: c.createdAt || now, updatedAt: c.updatedAt || now });
      by.careers.set(key, { ...c, id });
    }
  }

  // 3) Prompt items (match by title)
  for (const p of snap.promptItems) {
    if (!sel.promptItems.has(p.id)) continue;
    const key = normTitle(p.title);
    const local = by.promptItems.get(key);
    if (local) {
      const id = local.id;
      idMap.promptItems.set(p.id, id);
      await putOne('promptItems', { ...local, ...p, id, title: p.title, createdAt: keepCreated(local, p), updatedAt: p.updatedAt || now });
    } else {
      const id = await ensureUniqueId('promptItems', p.id);
      idMap.promptItems.set(p.id, id);
      await putOne('promptItems', { ...p, id, createdAt: p.createdAt || now, updatedAt: p.updatedAt || now });
      by.promptItems.set(key, { ...p, id });
    }
  }

  // 4) Personal templates (match by title)
  for (const t of snap.personalTemplates) {
    if (!sel.personalTemplates.has(t.id)) continue;
    const key = normTitle(t.title);
    const local = by.personalTemplates.get(key);
    if (local) {
      const id = local.id;
      idMap.personalTemplates.set(t.id, id);
      await putOne('personalTemplates', { ...local, ...t, id, title: t.title, createdAt: keepCreated(local, t), updatedAt: t.updatedAt || now });
    } else {
      const id = await ensureUniqueId('personalTemplates', t.id);
      idMap.personalTemplates.set(t.id, id);
      await putOne('personalTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || now });
      by.personalTemplates.set(key, { ...t, id });
    }
  }

  // 5) Career templates (match by title)
  for (const t of snap.careerTemplates) {
    if (!sel.careerTemplates.has(t.id)) continue;
    const key = normTitle(t.title);
    const local = by.careerTemplates.get(key);
    if (local) {
      const id = local.id;
      idMap.careerTemplates.set(t.id, id);
      await putOne('careerTemplates', { ...local, ...t, id, title: t.title, createdAt: keepCreated(local, t), updatedAt: t.updatedAt || now });
    } else {
      const id = await ensureUniqueId('careerTemplates', t.id);
      idMap.careerTemplates.set(t.id, id);
      await putOne('careerTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || now });
      by.careerTemplates.set(key, { ...t, id });
    }
  }

  // 6) Personal content (only selected rows, and only for imported users + imported templates)
  if (sel.personalContentKeys && sel.personalContentKeys.size) {
    for (const r of snap.personalContent) {
      const _k = `${r.userId}::${r.templateId}`;
      if (!sel.personalContentKeys.has(_k)) continue;
      const userNew = idMap.users.get(r.userId);
      if (!userNew) continue;
      const tplNew = idMap.personalTemplates.get(r.templateId);
      if (!tplNew) continue;
      await putOne('personalContent', { ...r, userId: userNew, templateId: tplNew, createdAt: r.createdAt || now, updatedAt: r.updatedAt || now });
    }
  }

  // 7) Career content (only selected rows, and only for imported careers + imported templates)
  if (sel.careerContentKeys && sel.careerContentKeys.size) {
    for (const r of snap.careerContent) {
      const _k = `${r.careerId}::${r.templateId}`;
      if (!sel.careerContentKeys.has(_k)) continue;
      const careerNew = idMap.careers.get(r.careerId);
      if (!careerNew) continue;
      const tplNew = idMap.careerTemplates.get(r.templateId);
      if (!tplNew) continue;
      await putOne('careerContent', { ...r, careerId: careerNew, templateId: tplNew, createdAt: r.createdAt || now, updatedAt: r.updatedAt || now });
    }
  }

  // 8) User -> Career mapping (optional)
  if (sel.includeUserCareer) {
    for (const r of snap.userCareer || []) {
      const userNew = idMap.users.get(r.userId);
      const careerNew = idMap.careers.get(r.careerId);
      if (!userNew || !careerNew) continue;
      await putOne('userCareer', { ...r, userId: userNew, careerId: careerNew, updatedAt: r.updatedAt || now });
    }
  }

  
  // Snapshot lookups for dependency resolution (Connections)
  const snapBy = {
    promptItems: new Map((snap.promptItems || []).map(p => [p.id, p])),
    personalTemplates: new Map((snap.personalTemplates || []).map(t => [t.id, t])),
    careerTemplates: new Map((snap.careerTemplates || []).map(t => [t.id, t])),
  };

  async function ensurePromptItemForConnection(oldId) {
    if (!oldId) return null;
    if (idMap.promptItems.has(oldId)) return idMap.promptItems.get(oldId);

    const p = snapBy.promptItems.get(oldId);
    if (!p) return null;

    const key = normTitle(p.title);
    const local = by.promptItems.get(key);
    if (local) {
      idMap.promptItems.set(oldId, local.id);
      return local.id;
    }

    const id = await ensureUniqueId('promptItems', p.id);
    idMap.promptItems.set(oldId, id);
    await putOne('promptItems', { ...p, id, createdAt: p.createdAt || now, updatedAt: p.updatedAt || p.createdAt || now });
    by.promptItems.set(key, { ...p, id });
    return id;
  }

  async function ensurePersonalTemplateForConnection(oldId) {
    if (!oldId) return null;
    if (idMap.personalTemplates.has(oldId)) return idMap.personalTemplates.get(oldId);

    const t = snapBy.personalTemplates.get(oldId);
    if (!t) return null;

    const key = normTitle(t.title);
    const local = by.personalTemplates.get(key);
    if (local) {
      idMap.personalTemplates.set(oldId, local.id);
      return local.id;
    }

    const id = await ensureUniqueId('personalTemplates', t.id);
    idMap.personalTemplates.set(oldId, id);
    await putOne('personalTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || t.createdAt || now });
    by.personalTemplates.set(key, { ...t, id });
    return id;
  }

  async function ensureCareerTemplateForConnection(oldId) {
    if (!oldId) return null;
    if (idMap.careerTemplates.has(oldId)) return idMap.careerTemplates.get(oldId);

    const t = snapBy.careerTemplates.get(oldId);
    if (!t) return null;

    const key = normTitle(t.title);
    const local = by.careerTemplates.get(key);
    if (local) {
      idMap.careerTemplates.set(oldId, local.id);
      return local.id;
    }

    const id = await ensureUniqueId('careerTemplates', t.id);
    idMap.careerTemplates.set(oldId, id);
    await putOne('careerTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || t.createdAt || now });
    by.careerTemplates.set(key, { ...t, id });
    return id;
  }

// 9) Connections (match by title, rewrite referenced IDs)
  for (const c of snap.connections) {
    if (!sel.connections.has(c.id)) continue;

    const promptItemIds = [];
    for (const pid of (c.promptItemIds || [])) {
      const mapped = await ensurePromptItemForConnection(pid);
      if (mapped) promptItemIds.push(mapped);
    }

    const personalTemplateIds = [];
    for (const tid of (c.personalTemplateIds || [])) {
      const mapped = await ensurePersonalTemplateForConnection(tid);
      if (mapped) personalTemplateIds.push(mapped);
    }

    const careerTemplateIds = [];
    for (const tid of (c.careerTemplateIds || [])) {
      const mapped = await ensureCareerTemplateForConnection(tid);
      if (mapped) careerTemplateIds.push(mapped);
    }

    const key = normTitle(c.title);
    const local = by.connections.get(key);

    if (local) {
      const id = local.id;
      idMap.connections.set(c.id, id);
      await putOne('connections', {
        ...local,
        ...c,
        id,
        title: c.title,
        promptItemIds,
        personalTemplateIds,
        careerTemplateIds,
        createdAt: keepCreated(local, c),
        updatedAt: c.updatedAt || now
      });
    } else {
      const id = await ensureUniqueId('connections', c.id);
      idMap.connections.set(c.id, id);
      await putOne('connections', {
        ...c,
        id,
        title: c.title,
        promptItemIds,
        personalTemplateIds,
        careerTemplateIds,
        createdAt: c.createdAt || now,
        updatedAt: c.updatedAt || now
      });
      by.connections.set(key, { ...c, id });
    }
  }
  // Fix template output↔connection links when imported connections get new IDs.
  // We first try id remapping via idMap.connections (best for Add mode), then fall back to title matching.
  const _connsNow = await getAll('connections');
  const _connByTitleNow = new Map((_connsNow || []).map(c => [normTitle(c.title), c]));

  async function _fixTemplateOutputLinks(storeName, snapArr, selSet, tplIdMap) {
    for (const t of (snapArr || [])) {
      if (!selSet || !selSet.has(t.id)) continue;
      const newTplId = tplIdMap.get(t.id);
      if (!newTplId) continue;

      const rec = await getOne(storeName, newTplId);
      if (!rec) continue;
      if (rec.isOutput === false) continue;

      const oldConnId = String(rec.outputConnectionId || '');
      let resolved = '';

      if (oldConnId && idMap.connections && idMap.connections.has(oldConnId)) {
        resolved = idMap.connections.get(oldConnId);
      }

      if (!resolved) {
        const title = String(rec.outputConnectionTitle || t.outputConnectionTitle || '');
        if (title) {
          const hit = _connByTitleNow.get(normTitle(title));
          if (hit) resolved = hit.id;
        }
      }

      if (resolved && resolved !== rec.outputConnectionId) {
        await putOne(storeName, { ...rec, outputConnectionId: resolved, updatedAt: nowISO() });
      }
    }
  }

  await _fixTemplateOutputLinks('personalTemplates', snap.personalTemplates, sel.personalTemplates, idMap.personalTemplates);
  await _fixTemplateOutputLinks('careerTemplates', snap.careerTemplates, sel.careerTemplates, idMap.careerTemplates);

}


/** Legacy destructive replace (unused): clears existing local data first, then imports selected snapshot parts. */
/** Legacy destructive replace (unused): clears existing local data first, then imports selected snapshot parts. */
async function clearAllLocalData() {
  // NOTE: This app no longer uses a global `db` handle.
  // Always open the DB via openDB() so import flows never fail with "db is not defined".
  const db = await openDB();
  const allStores = ['users','promptItems','personalItems','personalTemplates','personalContent','careers','careerBlocks','careerTemplates','careerContent','userCareer','connections','changeLogs'];
  const stores = allStores.filter(n => db.objectStoreNames.contains(n));
  if (!stores.length) return;
  const tx = db.transaction(stores, 'readwrite');
  stores.forEach(n => tx.objectStore(n).clear());
  await txComplete(tx);
}

async function importSnapshotSelectionReplace(snap, sel) {
  await clearAllLocalData();

  // Reset remembered selections (they may no longer exist after replace)
  try {
    localStorage.removeItem('mivida_current_user_id');
    localStorage.removeItem('mivida_current_career_id');
    localStorage.removeItem('mivida_prompt_career_id');
  } catch {}
  state.currentUserId = '';
  state.currentCareerId = '';

  const emptyExistTitles = {
    users: new Set(),
    careers: new Set(),
    promptItems: new Set(),
    personalTemplates: new Map(),
    careerTemplates: new Map(),
    connections: new Set()
  };

  await importSnapshotSelectionAddToLocal(snap, sel);
}


async function refreshAll() {
  // 1) Top filters first (so downstream renders can rely on state + selects)
  await loadUsersIntoSelect();
  await loadCareerFilterSelect();
  await renderPersonalCareerPick();

  // 2) Setup page sections
  await renderPrompts();
  await renderPersonal();
  await renderCareerBlocks();
  await renderConnections();

  // 3) Prompt page
  await renderPromptPickers();
  await renderPromptPage();
}

/** ========= Wire Events ========= */
function wireEvents() {
  $('#btnCloseModal').addEventListener('click', closeModal);
  const overlay = $('#modalOverlay');
  let downOnOverlay = false;
  overlay.addEventListener('pointerdown', (e) => { downOnOverlay = (e.target === overlay); });
  overlay.addEventListener('pointerup', (e) => {
    if (e.target === overlay && downOnOverlay) closeModal();
    downOnOverlay = false;
  });
  overlay.addEventListener('pointercancel', () => { downOnOverlay = false; });

  $('#tabSetup').addEventListener('click', () => setTab('setup'));
  $('#tabPrompt').addEventListener('click', () => setTab('prompt'));

  $('#btnAddUser').addEventListener('click', addUserFlow);
  $('#btnRenameUser').addEventListener('click', renameUserFlow);
  $('#btnDeleteUser').addEventListener('click', deleteUserFlow);


  // Careers (top filter + management)
  $('#btnAddCareerTop').addEventListener('click', addCareerFlow);
  $('#btnRenameCareer').addEventListener('click', renameCareerFlow);
  $('#btnDeleteCareer').addEventListener('click', deleteCareerFlow);

  $('#btnAddPrompt').addEventListener('click', () => openEditItemModal({
    title: 'Edit · Prompt Item',
    initial: { title:'', content:'' },
    onSave: savePromptItem,
    onDelete: deletePromptItem
  }));
  $('#btnAddPersonal').addEventListener('click', () => openEditItemModal({
    title: 'Edit · Personal Info Item',
    initial: { title:'', content:'', isOutput: true, outputConnectionId: '' },
    outputMeta: { connections: null },
    onSave: savePersonalTemplateAndContent,
    onDelete: deletePersonalTemplate
  }));


  $('#btnAddCareerBlock').addEventListener('click', () => openEditItemModal({
    title: 'Edit · Career Item',
    initial: { title:'', content:'', isOutput: true, outputConnectionId: '' },
    outputMeta: { connections: null },
    onSave: saveCareerTemplateAndContentByFilter,
    onDelete: deleteCareerTemplate
  }));

$('#btnAddConnection').addEventListener('click', () => openConnectionModal({
    mode:'create',
    initial:{ title:'', promptItemIds:[], personalTemplateIds:[], careerTemplateIds:[] }
  }));

  $('#btnExportLogs').addEventListener('click', exportLogsCsv);
  $('#btnExportSnapshot').addEventListener('click', openExportWizard);

  const fileInput = $('#fileImportSnapshot');
  $('#btnImportSnapshot').addEventListener('click', async () => {
    const s = getSyncUiState();
    if (s.provider === 'github') {
      await githubImportFlow({ wipe: false });
      return;
    }
    fileInput.click();
  });
  fileInput.addEventListener('change', async () => {
  const f = fileInput.files && fileInput.files[0];
  if (!f) return;
  try {
    const text = await f.text();
    await openImportWizardFromText(text);
  } catch (err) {
    console.error(err);
    toast('Import failed: ' + (err?.message || String(err)));
  } finally {
    fileInput.value = '';
  }
});

  // One-click wipe local data then import JSON (destructive)
  const wipeInput = $('#fileImportSnapshotWipe');
  const btnWipeImport = $('#btnWipeImportSnapshot');
  if (btnWipeImport && wipeInput) {
    btnWipeImport.addEventListener('click', async () => {
      const s = getSyncUiState();
      if (s.provider === 'github') {
        await githubImportFlow({ wipe: true });
        return;
      }
      wipeInput.click();
    });
    wipeInput.addEventListener('change', async () => {
      const f = wipeInput.files && wipeInput.files[0];
      if (!f) return;
      const ok = confirm('This will delete all local data and replace it with the selected JSON snapshot. Continue?');
      if (!ok) { wipeInput.value = ''; return; }
      try {
        const text = await f.text();
        await wipeLocalAndImportAllFromText(text);
      } catch (err) {
        console.error(err);
        toast('Import failed: ' + (err?.message || String(err)));
      } finally {
        wipeInput.value = '';
      }
    });
  }
  // Prompt page: Expand/Collapse all (default collapsed)
  const btnExpandAll = $('#btnExpandAllPrompt');
  const btnCollapseAll = $('#btnCollapseAllPrompt');
  if (btnExpandAll) btnExpandAll.addEventListener('click', () => {
    document.querySelectorAll('[data-prompt-content="1"]').forEach(el => { el.style.display = 'block'; });
    // also update per-card toggle buttons
    document.querySelectorAll('#promptConnections .btn').forEach(b => {
      if (b.textContent === 'Expand') b.textContent = 'Collapse';
    });
  });
  if (btnCollapseAll) btnCollapseAll.addEventListener('click', () => {
    document.querySelectorAll('[data-prompt-content="1"]').forEach(el => { el.style.display = 'none'; });
    document.querySelectorAll('#promptConnections .btn').forEach(b => {
      if (b.textContent === 'Collapse') b.textContent = 'Expand';
    });
  });
  // Prompt page: Current User / User Career / Current Career pickers
  const promptUserSel = $('#promptUserSelect');
  const promptUserCareerSel = $('#promptUserCareerSelect');
  const promptCurrentCareerSel = $('#promptCurrentCareerSelect');

  if (promptUserSel) promptUserSel.addEventListener('change', async () => {
    state.currentUserId = promptUserSel.value || '';
    try { localStorage.setItem('mivida_current_user_id', state.currentUserId); } catch {}

    // Sync Setup tab selector (selection only)
    const setupUserSel = $('#userSelect');
    if (setupUserSel) setupUserSel.value = state.currentUserId || '';

    await renderPersonalCareerPick();
    await renderPersonal();
    await renderPromptPickers();
    await renderPromptPage();
  });

  if (promptUserCareerSel) promptUserCareerSel.addEventListener('change', async () => {
    const userId = state.currentUserId || '';
    if (!userId) return;

    const v = promptUserCareerSel.value || '';
    const t = nowISO();
    const before = await getOne('userCareer', userId);
    const after = { userId, careerId: v || null, updatedAt: t, createdAt: before?.createdAt || t };
    await putOne('userCareer', after);
    await logChange({ entityType:'userCareer', entityId:userId, action: before ? 'update' : 'create', after, before });

    // Sync Setup tab User Career selector
    const setupUcSel = $('#personalCareerPick');
    if (setupUcSel) setupUcSel.value = v || '';

    await renderPersonalCareerPick();
    await renderPromptPickers();
    await renderPromptPage();
  });

  if (promptCurrentCareerSel) promptCurrentCareerSel.addEventListener('change', async () => {
    await setCurrentCareer(promptCurrentCareerSel.value || '');
  });


  // Theme toggle (Dark/Light)
  const btnTheme = $('#btnToggleTheme');
  if (btnTheme) btnTheme.addEventListener('click', () => {
    const cur = document.documentElement.dataset.theme || 'dark';
    const next = (cur === 'light') ? 'dark' : 'light';
    setTheme(next);
  });

}





/** ========= GitHub Online Import (Manual + Auto) ========= */
const GitHubSync = (() => {
  const GH_OWNER_KEY = 'mivida_gh_owner';
  const GH_REPO_KEY = 'mivida_gh_repo';
  const GH_BRANCH_KEY = 'mivida_gh_branch';
  const GH_FOLDER_KEY = 'mivida_gh_folder';
  const GH_UPLOADER_KEY = 'mivida_gh_uploader_name';
  const GH_TOKEN_KEY = 'mivida_gh_token';
  const GH_LOGIN_KEY = 'mivida_gh_login';
  const GH_LAST_OK_KEY = 'mivida_gh_last_ok';

  function getConfig(){
    return {
      owner: (localStorage.getItem(GH_OWNER_KEY) || '').trim(),
      repo: (localStorage.getItem(GH_REPO_KEY) || '').trim(),
      branch: (localStorage.getItem(GH_BRANCH_KEY) || 'main').trim() || 'main',
      folder: (localStorage.getItem(GH_FOLDER_KEY) || 'snapshots').trim() || 'snapshots',
      uploader: (localStorage.getItem(GH_UPLOADER_KEY) || '').trim(),
      token: (localStorage.getItem(GH_TOKEN_KEY) || '').trim(),
      login: (localStorage.getItem(GH_LOGIN_KEY) || '').trim(),
      lastOk: (localStorage.getItem(GH_LAST_OK_KEY) || '').trim(),
    };
  }

  function setConfig(cfg = {}){
    if (typeof cfg.owner === 'string') localStorage.setItem(GH_OWNER_KEY, cfg.owner.trim());
    if (typeof cfg.repo === 'string') localStorage.setItem(GH_REPO_KEY, cfg.repo.trim());
    if (typeof cfg.branch === 'string') localStorage.setItem(GH_BRANCH_KEY, (cfg.branch.trim() || 'main'));
    if (typeof cfg.folder === 'string') localStorage.setItem(GH_FOLDER_KEY, (cfg.folder.trim() || 'snapshots'));
    if (typeof cfg.uploader === 'string') localStorage.setItem(GH_UPLOADER_KEY, cfg.uploader.trim());
    if (typeof cfg.token === 'string') localStorage.setItem(GH_TOKEN_KEY, cfg.token.trim());
  }

  function isConfigured(){
    const c = getConfig();
    return !!(c.owner && c.repo && c.token);
  }

  function getStatusLabel(){
    const c = getConfig();
    if (!isConfigured()) return 'Not configured';
    if (!c.login) return 'Configured (not tested)';
    // fmtTime is scoped inside the import modal code path; use global formatLocal here.
    const when = c.lastOk ? ` · OK ${formatLocal(c.lastOk)}` : '';
    return `Connected as ${c.login}${when}`;
  }

  function _encodePath(path){
    return String(path || '')
      .split('/')
      .filter(Boolean)
      .map(seg => encodeURIComponent(seg))
      .join('/');
  }

  async function api(path, { method='GET', headers={}, body=null } = {}, cfg=null){
    const c = cfg || getConfig();
    if (!c.token) throw new Error('Missing GitHub token.');
    const url = `https://api.github.com${path}`;
    const h = {
      'Accept': 'application/vnd.github+json',
      'Authorization': `Bearer ${c.token}`,
      ...headers
    };
    const res = await fetch(url, { method, headers: h, body });
    if (!res.ok){
      let msg = `${res.status} ${res.statusText}`;
      try {
        const j = await res.json();
        if (j && j.message) msg = `${msg}: ${j.message}`;
      } catch {}
      throw new Error(msg);
    }
    // Some endpoints may return empty body
    const ct = res.headers.get('content-type') || '';
    if (ct.includes('application/json')) return await res.json();
    return await res.text();
  }

  async function testConnection(){
    const c = getConfig();
    if (!isConfigured()) throw new Error('Missing GitHub settings.');
    const me = await api('/user', {}, c);
    const repo = await api(`/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}`, {}, c);

    try {
      localStorage.setItem(GH_LOGIN_KEY, me?.login || '');
      localStorage.setItem(GH_LAST_OK_KEY, nowISO());
    } catch {}
    // If branch wasn't set, follow default branch.
    if (!localStorage.getItem(GH_BRANCH_KEY) && repo?.default_branch) {
      try { localStorage.setItem(GH_BRANCH_KEY, repo.default_branch); } catch {}
    }
    return { login: me?.login || '', repoFullName: repo?.full_name || '' };
  }

  function _b64ToUtf8(b64){
    const clean = String(b64 || '').replace(/\n/g,'');
    const bin = atob(clean);
    const bytes = new Uint8Array(bin.length);
    for (let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return new TextDecoder('utf-8').decode(bytes);
  }

  function _parseSortScore(name){
    const n = String(name || '');
    // Prefer YYYYMMDD_HHMMSS
    let m = n.match(/(\d{8})[_-](\d{6})/);
    if (m) return Number(m[1] + m[2]);
    // ISO-ish: YYYY-MM-DDTHH-MM-SS or YYYY-MM-DD_HH-MM-SS
    m = n.match(/(\d{4})[-_](\d{2})[-_](\d{2})[T_ -](\d{2})[-_](\d{2})[-_](\d{2})/);
    if (m) return Number(m[1]+m[2]+m[3]+m[4]+m[5]+m[6]);
    // Date only
    m = n.match(/(\d{4})[-_](\d{2})[-_](\d{2})/);
    if (m) return Number(m[1]+m[2]+m[3]) * 1000000;
    return 0;
  }

  async function listSnapshots(){
    const c = getConfig();
    if (!isConfigured()) throw new Error('GitHub sync is not configured.');
    const folder = _encodePath(c.folder || 'snapshots');
    const branch = encodeURIComponent(c.branch || 'main');

    let items;
    try {
      items = await api(`/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}/contents/${folder}?ref=${branch}`, {}, c);
    } catch (e) {
      // When folder doesn't exist, GitHub returns 404
      throw new Error(`Cannot list snapshots in "${c.folder}". Make sure the folder exists in the repo and the token has access.\n\n${e.message || e}`);
    }

    const files = (Array.isArray(items) ? items : [])
      .filter(x => x && x.type === 'file' && (x.name || '').toLowerCase().endsWith('.json'))
      .map(x => ({
        name: x.name || '',
        path: x.path || '',
        size: typeof x.size === 'number' ? x.size : null,
        sha: x.sha || '',
        sortScore: _parseSortScore(x.name || ''),
      }));

    files.sort((a,b) => {
      if ((b.sortScore || 0) !== (a.sortScore || 0)) return (b.sortScore||0) - (a.sortScore||0);
      return String(b.name||'').localeCompare(String(a.name||'')); // fallback
    });

    return files;
  }

  async function downloadSnapshot(file){
    const c = getConfig();
    if (!file || !file.path) throw new Error('Missing snapshot file path.');
    const branch = encodeURIComponent(c.branch || 'main');
    const resp = await api(`/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}/contents/${_encodePath(file.path)}?ref=${branch}`, {}, c);
    if (!resp || !resp.content) throw new Error('Snapshot content not found.');
    return _b64ToUtf8(resp.content);
  }

  return {
    getConfig,
    setConfig,
    isConfigured,
    getStatusLabel,
    testConnection,
    listSnapshots,
    downloadSnapshot,
  };
})();

function openGitHubSnapshotPicker({ title='Choose a snapshot', onPick }){
  const cfg = GitHubSync.getConfig();

  const wrap = document.createElement('div');
  wrap.innerHTML = `
    <div class="row" style="align-items:center; justify-content:space-between;">
      <div class="muted" id="ghPickerStatus">Loading snapshots…</div>
      <div style="display:flex; gap:8px;">
        <button class="btn mini" id="ghPickerRefresh">Refresh</button>
      </div>
    </div>
    <div class="row" style="margin-top:10px;">
      <input id="ghPickerSearch" type="text" placeholder="Search filename…" style="width:100%;"/>
    </div>
    <div class="divider" style="margin:12px 0;"></div>
    <div id="ghPickerList" style="max-height:55vh; overflow:auto; border:1px solid var(--border); border-radius:12px; background:var(--panelB);"></div>
    <div class="muted" style="margin-top:10px;">
      Repo: <b>${escapeHtml(cfg.owner || '')}/${escapeHtml(cfg.repo || '')}</b> · Branch: <b>${escapeHtml(cfg.branch || '')}</b> · Folder: <b>${escapeHtml(cfg.folder || '')}</b>
    </div>
  `;

  const statusEl = wrap.querySelector('#ghPickerStatus');
  const listEl = wrap.querySelector('#ghPickerList');
  const searchEl = wrap.querySelector('#ghPickerSearch');
  const refreshBtn = wrap.querySelector('#ghPickerRefresh');

  let allFiles = [];

  function render(){
    const q = (searchEl?.value || '').trim().toLowerCase();
    const files = allFiles.filter(f => !q || (f.name || '').toLowerCase().includes(q));

    if (!files.length){
      listEl.innerHTML = `<div class="muted" style="padding:14px;">No matching snapshots.</div>`;
      return;
    }

    listEl.innerHTML = files.map((f, idx) => {
      const size = (typeof f.size === 'number') ? ` · ${(f.size/1024).toFixed(1)} KB` : '';
      const latest = idx === 0 ? `<span class="pill" style="margin-left:8px;">Latest</span>` : '';
      return `
        <div class="row" style="padding:10px 12px; border-bottom:1px solid var(--border); align-items:flex-start;">
          <div style="flex:1; min-width:0;">
            <div style="font-weight:650; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
              ${escapeHtml(f.name)} ${latest}
            </div>
            <div class="muted" style="margin-top:4px;">${escapeHtml(f.path || '')}${size}</div>
          </div>
          <button class="btn mini" data-path="${escapeHtml(f.path)}" style="margin-left:10px;">Select</button>
        </div>
      `;
    }).join('');

    listEl.querySelectorAll('button[data-path]').forEach(b => {
      b.addEventListener('click', async () => {
        const path = b.getAttribute('data-path');
        const file = allFiles.find(x => x.path === path);
        if (!file) return;
        closeModal();
        try {
          await onPick(file);
        } catch (e) {
          console.error(e);
          toast('Failed to load snapshot');
          alert('Failed to load snapshot.\n\n' + (e && e.message ? e.message : e));
        }
      });
    });
  }

  async function load(){
    try {
      if (statusEl) statusEl.textContent = 'Loading snapshots…';
      allFiles = await GitHubSync.listSnapshots();
      if (statusEl) statusEl.textContent = `Found ${allFiles.length} JSON snapshot(s).`;
      render();
    } catch (e) {
      console.error(e);
      if (statusEl) statusEl.textContent = 'Failed to load snapshots.';
      listEl.innerHTML = `<div class="muted" style="padding:14px; white-space:pre-wrap;">${escapeHtml(e && e.message ? e.message : String(e))}</div>`;
    }
  }

  if (searchEl) searchEl.addEventListener('input', render);
  if (refreshBtn) refreshBtn.addEventListener('click', load);

  openModal(title, wrap, [btn('Close', { onClick: () => closeModal() })]);
  load();
}

async function githubImportFlow({ wipe=false } = {}){
  const s = getSyncUiState();
  if (s.provider !== 'github') return;

  if (!GitHubSync.isConfigured()) {
    openGitHubSettingsModal({ focusToken: true });
    return;
  }

  try {
    if (s.mode === 'manual') {
      openGitHubSnapshotPicker({
        title: wipe ? 'Choose a snapshot to WIPE and import' : 'Choose a snapshot to import',
        onPick: async (file) => {
          const text = await GitHubSync.downloadSnapshot(file);
          if (wipe) {
            const ok = confirm(`This will delete all local data and replace it with:\n\n${file.name}\n\nContinue?`);
            if (!ok) return;
            await wipeLocalAndImportAllFromText(text);
          } else {
            await openImportWizardFromText(text);
          }
          toast(`Imported: ${file.name}`);
        }
      });
      return;
    }

    // Auto: import the "latest" snapshot from the folder (best-effort by filename)
    const files = await GitHubSync.listSnapshots();
    if (!files.length) {
      toast('No JSON snapshots found in the configured folder.');
      alert('No JSON snapshots found in the configured folder.\n\nFolder: ' + GitHubSync.getConfig().folder);
      return;
    }
    const latest = files[0];
    const text = await GitHubSync.downloadSnapshot(latest);

    if (wipe) {
      const ok = confirm(`This will delete all local data and replace it with:\n\n${latest.name}\n\nContinue?`);
      if (!ok) return;
      await wipeLocalAndImportAllFromText(text);
    } else {
      await openImportWizardFromText(text);
    }
    toast(`Imported latest: ${latest.name}`);
  } catch (err) {
    console.error(err);
    toast('Import failed: ' + (err?.message || String(err)));
    alert('Import failed.\n\n' + (err && err.message ? err.message : err));
  }
}


/** ========= Sync Mode UI (Offline / GitHub Online) ========= */
const SYNC_UI_PROVIDER_KEY = 'mivida_sync_provider'; // 'local' | 'github'
const SYNC_UI_MODE_KEY = 'mivida_sync_mode'; // 'auto' | 'manual'

function getSyncUiState(){
  let provider = (localStorage.getItem(SYNC_UI_PROVIDER_KEY) || 'local').toLowerCase();
  let mode = (localStorage.getItem(SYNC_UI_MODE_KEY) || 'manual').toLowerCase();

  // Migration from older builds
  if (provider === 'onedrive') provider = 'github';

  provider = (provider === 'github') ? 'github' : 'local';
  mode = (mode === 'auto') ? 'auto' : 'manual';

  return { provider, mode };
}
function setSyncProvider(provider){
  localStorage.setItem(SYNC_UI_PROVIDER_KEY, provider === 'github' ? 'github' : 'local');
  applySyncUiState();
}
function setSyncMode(mode){
  localStorage.setItem(SYNC_UI_MODE_KEY, mode === 'auto' ? 'auto' : 'manual');
  applySyncUiState();
}

function applySyncUiState(){
  const s = getSyncUiState();

  const btnProvider = document.getElementById('btnSyncProvider');
  const btnMode = document.getElementById('btnSyncModeToggle');
  const btnSettings = document.getElementById('btnSyncSettings');
  const subEl = document.getElementById('syncSubText');

  if (btnProvider){
    btnProvider.dataset.provider = s.provider;
    const label = btnProvider.querySelector('.label');
    if (label) label.textContent = (s.provider === 'local') ? 'Offline' : 'Online';
  }
  if (btnMode){
    btnMode.style.display = (s.provider === 'github') ? '' : 'none';
    btnMode.dataset.provider = 'github';
    const label = btnMode.querySelector('.label');
    if (label) label.textContent = (s.mode === 'auto') ? 'Auto' : 'Manual';
  }
  if (btnSettings){
    btnSettings.style.display = (s.provider === 'github') ? '' : 'none';
  }
  if (subEl){
    if (s.provider === 'local') {
      subEl.textContent = 'Offline · Local cache · Import/Export JSON';
    } else {
      subEl.textContent = `Online · GitHub · ${s.mode === 'auto' ? 'Auto' : 'Manual'} · ${GitHubSync.getStatusLabel()}`;
    }
  }

  document.title = (s.provider === 'local') ? 'Prompt Builder' : 'Prompt Builder · Online';

  // Update button labels to reduce confusion
  const btnExp = document.getElementById('btnExportSnapshot');
  const btnImp = document.getElementById('btnImportSnapshot');
  const btnWip = document.getElementById('btnWipeImportSnapshot');
  if (btnExp) btnExp.textContent = 'Export Snapshot (JSON)';
  if (btnImp) btnImp.textContent = (s.provider === 'github')
    ? (s.mode === 'auto' ? 'Import Latest (GitHub)' : 'Import (GitHub)')
    : 'Import Snapshot (JSON)';
  if (btnWip) btnWip.textContent = (s.provider === 'github')
    ? (s.mode === 'auto' ? 'Wipe & Import Latest (GitHub)' : 'Wipe & Import (GitHub)')
    : 'Wipe & Import Snapshot';
}

function openGitHubSettingsModal({ focusToken=false } = {}){
  const c = GitHubSync.getConfig();

  const body = document.createElement('div');
  body.className = 'modalBody';

  const hint = document.createElement('div');
  hint.className = 'hint';
  hint.style.marginBottom = '10px';
  hint.innerHTML = `
    <div style="font-weight:700; margin-bottom:4px;">GitHub Sync Settings</div>
    <div class="muted">Use a fine-grained token. Minimum for reading snapshots: <b>Contents: Read</b> on the private data repo.</div>
  `;
  body.appendChild(hint);

  const form = document.createElement('div');
  form.className = 'form';
  form.innerHTML = `
    <label>Private data repo owner</label>
    <input id="ghOwner" placeholder="e.g., Sophophobia" value="${escapeHtml(c.owner)}"/>

    <label>Private data repo name</label>
    <input id="ghRepo" placeholder="e.g., MiVidaPrompt" value="${escapeHtml(c.repo)}"/>

    <div class="row" style="gap:10px;">
      <div style="flex:1;">
        <label>Branch</label>
        <input id="ghBranch" placeholder="main" value="${escapeHtml(c.branch || 'main')}"/>
      </div>
      <div style="flex:1;">
        <label>Folder</label>
        <input id="ghFolder" placeholder="snapshots" value="${escapeHtml(c.folder || 'snapshots')}"/>
      </div>
    </div>

    <label>Uploader name (optional, used for file naming later)</label>
    <input id="ghUploader" placeholder="Your name" value="${escapeHtml(c.uploader || '')}"/>

    <label>GitHub token</label>
    <input id="ghToken" placeholder="Paste your token here" value="${escapeHtml(c.token ? '••••••••••' : '')}" autocomplete="off"/>
    <div class="muted" style="margin-top:6px;">Token is stored in your browser's local storage on this device.</div>

    <div class="divider" style="margin:12px 0;"></div>
    <div class="row" style="align-items:center; justify-content:space-between;">
      <div class="muted" id="ghStatus">${escapeHtml(GitHubSync.getStatusLabel())}</div>
      <div style="display:flex; gap:8px;">
        <button class="btn mini" id="btnGhTest">Test Connection</button>
      </div>
    </div>
  `;
  body.appendChild(form);

  const ownerEl = form.querySelector('#ghOwner');
  const repoEl = form.querySelector('#ghRepo');
  const branchEl = form.querySelector('#ghBranch');
  const folderEl = form.querySelector('#ghFolder');
  const uploaderEl = form.querySelector('#ghUploader');
  const tokenEl = form.querySelector('#ghToken');
  const statusEl = form.querySelector('#ghStatus');
  const testBtn = form.querySelector('#btnGhTest');

  // Only show token placeholder dots; if user focuses, clear to allow paste.
  if (tokenEl){
    tokenEl.addEventListener('focus', () => {
      if (tokenEl.value === '••••••••••') tokenEl.value = '';
    });
  }

  const saveNow = () => {
    const owner = (ownerEl?.value || '').trim();
    const repo = (repoEl?.value || '').trim();
    const branch = (branchEl?.value || 'main').trim() || 'main';
    const folder = (folderEl?.value || 'snapshots').trim() || 'snapshots';
    const uploader = (uploaderEl?.value || '').trim();

    // Only overwrite token if user actually typed something (not placeholder)
    let token = undefined;
    const t = (tokenEl?.value || '').trim();
    if (t && t !== '••••••••••') token = t;

    const cfg = { owner, repo, branch, folder, uploader };
    if (typeof token === 'string') cfg.token = token;

    GitHubSync.setConfig(cfg);
    applySyncUiState();
    return GitHubSync.getConfig();
  };

  if (testBtn){
    testBtn.addEventListener('click', async () => {
      try {
        statusEl.textContent = 'Testing…';
        const cfg = saveNow();
        if (!GitHubSync.isConfigured()){
          statusEl.textContent = 'Missing required settings.';
          toast('Please fill owner, repo, and token.');
          return;
        }
        const r = await GitHubSync.testConnection();
        statusEl.textContent = GitHubSync.getStatusLabel();
        toast(`Connected as ${r.login}`);
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Test failed.';
        toast('Test failed: ' + (e?.message || String(e)));
        alert('Test failed.\n\n' + (e && e.message ? e.message : e));
      } finally {
        applySyncUiState();
      }
    });
  }

  openModal('Sync Settings', body, [
    btn('Cancel', { onClick: () => closeModal() }),
    btn('Save', { primary:true, onClick: () => { saveNow(); closeModal(); toast('Sync settings saved'); } })
  ]);

  // Optional focus
  if (focusToken && tokenEl) {
    setTimeout(() => tokenEl.focus(), 0);
  }
}

function initSyncUi(){
  applySyncUiState();

  const btnProvider = document.getElementById('btnSyncProvider');
  const btnMode = document.getElementById('btnSyncModeToggle');
  const btnSettings = document.getElementById('btnSyncSettings');

  if (btnProvider){
    btnProvider.addEventListener('click', () => {
      const s = getSyncUiState();
      if (s.provider === 'local') {
        // switch to online
        setSyncProvider('github');
        // Don't force the modal if settings already exist.
        if (!GitHubSync.isConfigured()) openGitHubSettingsModal({ focusToken:true });
      } else {
        setSyncProvider('local');
      }
    });
  }

  if (btnMode){
    btnMode.addEventListener('click', () => {
      const s = getSyncUiState();
      if (s.provider !== 'github') return;
      setSyncMode(s.mode === 'manual' ? 'auto' : 'manual');
    });
  }

  if (btnSettings){
    btnSettings.addEventListener('click', () => openGitHubSettingsModal());
  }
}


/** ========= Init ========= */
(async function init(){
  initTheme();
  wireEvents();
  initSyncUi();
  await ensureSeed();
  await refreshAll();
})();
</script>
</body>
</html>
