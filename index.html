<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Builder</title>
  <style>
    :root{
      color-scheme: dark;
      /* Theme variables (default: dark) */
      --bg:#0b0f17; --bgGlow:#17213a;
      --panel:#121a27; --panel2:#0f1622;
      --text:#e8eefc; --muted:#9fb0d0;
      --border:#22314b; --accent:#7aa2ff; --danger:#ff6b6b; --ok:#4cd97b; --warn:#ffd166;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      /* Alpha surfaces (use vars so Light mode looks right) */
      --panelA: rgba(18,26,39,.7);
      --panelB: rgba(18,26,39,.72);
      --panelC: rgba(15,22,34,.75);
      --panelD: rgba(18,26,39,.55);
      --borderA: rgba(34,49,75,.85);
      --borderB: rgba(34,49,75,.9);
      --divider: rgba(34,49,75,.8);
      --accentA: rgba(122,162,255,.55);
      --accentB: rgba(122,162,255,.10);
      --overlay: rgba(0,0,0,.55);
      --modalHeaderBg: rgba(18,26,39,.92);
      --btnHoverBorder: rgba(122,162,255,.55);
      --btnPrimaryBg: rgba(122,162,255,.18);
      --btnPrimaryBorder: rgba(122,162,255,.45);
      --btnDangerBg: rgba(255,107,107,.12);
      --btnDangerBorder: rgba(255,107,107,.35);
      --pillOkBorder: rgba(76,217,123,.35);
      --pillOkBg: rgba(76,217,123,.10);
      --pillWarnBorder: rgba(255,209,102,.35);
      --pillWarnBg: rgba(255,209,102,.08);
      --calloutBorder: rgba(34,49,75,.85);
      --calloutBg: rgba(15,22,34,.75);
      --blockquoteBorder: rgba(122,162,255,.55);
      --blockquoteBg: rgba(122,162,255,.07);

      --inputBg: rgba(15,22,34,.9);
      --inputOptionBg: #0f1622;

      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    :root[data-theme="light"]{
      color-scheme: light;
      --bg:#f7f9ff; --bgGlow:#dbe7ff;
      --panel:#ffffff; --panel2:#f2f6ff;
      --text:#0b1220; --muted:#4b5b7a;
      --border:#d4deef; --accent:#2b6cff;
      --danger:#d63c3c; --ok:#1c9b4a; --warn:#b8860b;
      --shadow: 0 10px 30px rgba(10,30,70,.12);

      --panelA: rgba(255,255,255,.86);
      --panelB: rgba(255,255,255,.92);
      --panelC: rgba(242,246,255,.92);
      --panelD: rgba(255,255,255,.70);
      --borderA: rgba(212,222,239,.95);
      --borderB: rgba(212,222,239,.95);
      --divider: rgba(212,222,239,.9);
      --accentA: rgba(43,108,255,.45);
      --accentB: rgba(43,108,255,.10);
      --overlay: rgba(0,0,0,.35);
      --modalHeaderBg: rgba(255,255,255,.92);
      --btnHoverBorder: rgba(43,108,255,.45);
      --btnPrimaryBg: rgba(43,108,255,.10);
      --btnPrimaryBorder: rgba(43,108,255,.28);
      --btnDangerBg: rgba(214,60,60,.10);
      --btnDangerBorder: rgba(214,60,60,.28);
      --pillOkBorder: rgba(28,155,74,.28);
      --pillOkBg: rgba(28,155,74,.10);
      --pillWarnBorder: rgba(184,134,11,.28);
      --pillWarnBg: rgba(184,134,11,.10);
      --calloutBorder: rgba(212,222,239,.95);
      --calloutBg: rgba(242,246,255,.9);
      --blockquoteBorder: rgba(43,108,255,.35);
      --blockquoteBg: rgba(43,108,255,.07);

      --inputBg: #ffffff;
      --inputOptionBg: #ffffff;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0; font-family:var(--sans); color:var(--text);
      background: radial-gradient(1200px 800px at 20% 10%, var(--bgGlow) 0%, var(--bg) 60%);
    }
    .app{ max-width: 1180px; margin: 26px auto; padding: 0 18px 34px; }
    header{ display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom: 14px; }
    .title{ display:flex; flex-direction:column; gap:4px; }
    .title h1{ margin:0; font-size:18px; letter-spacing:.2px;}
    .titleRow{ display:flex; align-items:center; gap:10px; }
    .modeGroup{ display:flex; align-items:center; gap:8px; }
    .modeChip.iconOnly{ padding:6px 9px; }
    .modeChip.iconOnly .dot{ display:none; }
    /* icon-only buttons should be compact and truly icon-only */
    .modeChip.iconOnly{ width:34px; justify-content:center; padding:6px 0; }
    .modeChip.iconOnly .icon{ font-size:14px; line-height:1; display:inline-flex; align-items:center; justify-content:center; }
    .modeChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: var(--panelB);
      color: var(--text);
      font-size:12px;
      cursor:pointer;
      user-select:none;
      line-height:1;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .modeChip:hover{ background: rgba(255,255,255,.06); }
    [data-theme="light"] .modeChip:hover{ background: rgba(0,0,0,.04); }
    .modeChip:active{ transform: translateY(1px); }
    .modeChip .dot{
      width:9px;
      height:9px;
      border-radius:50%;
      background: var(--muted);
      box-shadow: 0 0 0 2px rgba(0,0,0,.15) inset;
    }
    .modeChip[data-provider="local"] .dot{ background: #94a3b8; }
    .modeChip[data-provider="github"] .dot{ background: #22c55e; }
    .modeChip[data-provider="github"]{ border-color: rgba(34,197,94,.55); }
    .modeChip[data-provider="github"]:hover{ background: rgba(34,197,94,.08); }

    .syncInfoBadge{
      display:none;
      align-items:center;
      gap:8px;
      margin-left:8px;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background: var(--panelB);
      max-width: 560px;
      white-space:nowrap;
      flex-wrap:nowrap;
    }
    .syncInfoLabel{
      font-size:11px;
      line-height:1.2;
      color: var(--muted);
      white-space:nowrap;
      opacity:.9;
    }
    .syncInfoValue{
      font-size:11px;
      line-height:1.2;
      color: var(--text);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 420px;
    }
    .syncEditedTag{
      font-size:11px;
      line-height:1.2;
      color: var(--warn);
      white-space:nowrap;
      opacity:.95;
    }

.title .sub{ color:var(--muted); font-size:13px; }
    .tabs{
      display:flex; gap:10px; background: var(--panelA);
      border:1px solid var(--border); border-radius: 999px; padding:6px; box-shadow: var(--shadow);
    }
    .tab{
      border:0; background: transparent; color: var(--muted);
      padding: 10px 14px; border-radius: 999px; cursor:pointer; font-weight:600;
    }
    .tab.active{ background: var(--btnPrimaryBg); color: var(--text); }
    .topbar{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin: 14px 0 18px; }
    .chip{
      display:flex; align-items:center; gap:10px;
      background: var(--panelA); border:1px solid var(--border);
      border-radius: 999px; padding: 10px 12px;
      box-shadow: var(--shadow);
    }
    .chip label{ color: var(--muted); font-size:12px; }
    select, input[type="text"], textarea{
      background: var(--inputBg); color: var(--text);
      border: 1px solid var(--border); border-radius: 10px;
      padding: 10px 10px; font-size: 14px; outline: none;
    }
    select{ padding: 9px 10px; }
    select option{ background: var(--inputOptionBg); color: var(--text); }
    textarea{
      width:100%;
      min-height: 140px;
      height: 240px;
      max-height: 45vh;
      resize: vertical;
      font-family: var(--mono);
      line-height:1.35;
    }

    .btn{
      border: 1px solid var(--border);
      background: var(--panelA);
      color: var(--text); border-radius: 10px;
      padding: 10px 12px; cursor:pointer; font-weight:600;
    }
    .btn:hover{ border-color: var(--btnHoverBorder); }
    .btn.primary{ background: var(--btnPrimaryBg); border-color: var(--btnPrimaryBorder); }
    .btn.danger{ background: var(--btnDangerBg); border-color: var(--btnDangerBorder); }
    .btn.ghost{ background: transparent; }
    .mini{ font-size: 12px; padding: 8px 10px; border-radius: 10px; }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }
    .card{
      background: var(--panelB);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .card h2{
      margin: 0 0 10px; font-size: 14px; letter-spacing:.2px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .muted{ color: var(--muted); font-size: 12px; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    /* Form rows (used in edit popups) */
    .formRow{
      display:grid;
      grid-template-columns: 110px 1fr;
      gap: 12px;
      align-items: center;
    }
    .formRow.top{ align-items: start; }
    .formLabel{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.2;
      padding-top: 2px;
      user-select: none;
      white-space: nowrap;
    }
    .formRow > *:nth-child(2){
      min-width: 0;
    }
    .fieldBlock{ display:flex; flex-direction:column; gap:6px; }
    .fieldBlock textarea{ width:100%; }
    .outConfig{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .outConfig .muted{ font-size: 12px; }
    .outConfig select{ min-width: 260px; }
    .list{ display:flex; flex-direction:column; gap:8px; }
    .item{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      padding: 10px 10px; border:1px solid var(--borderA);
      border-radius: 12px; background: var(--panelC);
    }
    .item .meta{ display:flex; flex-direction:column; gap:3px; min-width: 0; }
    .item .meta .name{
      font-weight:700; font-size: 13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width: 520px;
    }
    .item .meta .small{ font-size: 12px; color: var(--muted); }
    .item .actions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
.outCtrl{ display:flex; align-items:center; gap:6px; padding:2px 8px; border:1px solid var(--line); border-radius:999px; background:var(--panel); }
.outCtrl label{ font-size:12px; color:var(--muted); user-select:none; }
.outCtrl select{ font-size:12px; padding:4px 8px; border-radius:10px; border:1px solid var(--line); background:transparent; color:inherit; }
.outCtrl input[type="checkbox"]{ transform: translateY(1px); }

    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding: 2px 8px; border-radius:999px;
      border:1px solid var(--borderB);
      background: var(--panelD);
      color: var(--muted); font-size: 11px;
    }
    .divider{ height:1px; background: var(--divider); margin: 10px 0; }
    .hint{
      border: 1px dashed var(--accentA);
      background: var(--accentB);
      padding: 10px 12px; border-radius: 12px;
      color: var(--muted); font-size: 12px;
    }

    /* Modal */
    .modalOverlay{
      position:fixed; inset:0;
      background: var(--overlay);
      display:none; align-items:center; justify-content:center;
      padding: 18px;
      overflow-y: auto;
      overflow-x: hidden; /* critical */
    }
    .modalOverlay.open{ display:flex; }
    .modal{
  width: min(1020px, 100%);
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 16px;
  box-shadow: var(--shadow);
  padding: 14px;
  max-height: calc(100vh - 40px);
  display: flex;
  flex-direction: column;
  overflow: hidden; /* body scrolls, header stays fixed */
}

    /* Fullscreen modal (used by Output reader) */
    .modalOverlay.fullscreen{
      padding: 0;
      align-items: stretch;
      justify-content: stretch;
    }
    .modalOverlay.fullscreen .modal{
      width: 100%;
      height: 100vh;
      max-height: 100vh;
      border-radius: 0;
      padding: 0;
    }
    .modalOverlay.fullscreen .modalHeader{
      margin: 0;
      padding: 14px 16px;
    }
    .modalOverlay.fullscreen #modalBody{
      padding: 14px 16px;
      padding-right: 16px;
    }
    .modalOverlay.fullscreen #modalFooter{
      margin-top: 0 !important;
      padding: 12px 16px;
    }
    .mdPreview.outputReader{
      font-size: 15px;
      line-height: 1.7;
      max-width: 920px;
      margin: 0 auto;
      padding: 18px 20px;
      background: var(--panel2);
      border: 1px solid var(--calloutBorder);
      border-radius: 14px;
      box-sizing: border-box;
    }

.split{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 980px){ .split{ grid-template-columns: 1fr; } }
    .split > div{ min-width:0; }

    .badgeOk{
      color: var(--ok);
      border-color: var(--pillOkBorder);
      background: var(--pillOkBg);
    }
    .badgeWarn{
      color: var(--warn);
      border-color: var(--pillWarnBorder);
      background: var(--pillWarnBg);
    }

    .dupTimes{
      display:flex;
      flex-direction:column;
      gap:2px;
      text-align:right;
      width:100%;
    }
    .dupTimes .dupLine{
      font-size: 11px;
      color: var(--muted);
      white-space: normal;
      overflow-wrap: anywhere;
      line-height: 1.2;
    }
    .dupTimes b{ color: var(--text); font-weight:700; }

    .importItemTitle{
      font-weight: 700;
      white-space: normal;
      overflow-wrap: break-word;
      word-break: normal;
      hyphens: auto;
      line-height: 1.25;
      max-width: none;
    }
    .newerTag{ margin-left:6px; }

    /* Import snapshot wizard (clean layout) */
    .importGrid{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 980px){ .importGrid{ grid-template-columns: 1fr; } }
    .importFooterFull{ grid-column: 1 / -1; }

    .importGroup{
      background: var(--panelB);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      overflow: hidden;
    }
    .importGroupHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .importGroupTitle{
      font-weight: 800;
      font-size: 13px;
      letter-spacing: .2px;
      color: var(--text);
      min-width: 0;
    }
    .importGroupControls{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }
    .importRows{ display:flex; flex-direction:column; gap:8px; }

    .importRow{
      display:grid;
      grid-template-columns: 18px 1fr;
      gap:10px;
      align-items:flex-start;
      padding: 10px;
      border: 1px solid var(--borderA);
      border-radius: 12px;
      background: var(--panelC);
    }
    .importRow.auto{ outline: 1px dashed var(--accentA); }
    .importMain{ min-width:0; }
    .importTitleLine{ display:flex; align-items:flex-start; gap:8px; min-width:0; }
    .importMeta{
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
      overflow-wrap: break-word;
    }
    .importBadges{
      margin-top: 6px;
      display:flex;
      align-items:center;
      gap:6px;
      flex-wrap:wrap;
    }

    .importMeta:empty{ display:none; }
    .importBadges:empty{ display:none; }
    /* Import accordions (Users/Careers grouped) */
    .importAccordion{ display:flex; flex-direction:column; gap:10px; }
    .importAccordion details{
      border: 1px solid var(--borderA);
      border-radius: 12px;
      background: var(--panelC);
      overflow: hidden;
    }
    .importAccordion summary{
      list-style: none;
      cursor: pointer;
      padding: 10px;
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .importAccordion summary::-webkit-details-marker{ display:none; }
    .importAccSummaryLeft{ display:flex; align-items:flex-start; gap:10px; min-width:0; flex:1; }
    .importAccName{ font-weight:800; min-width:0; overflow-wrap: break-word; word-break: normal; }
    .importAccCounts{ font-size:11px; color: var(--muted); margin-left:auto; white-space:nowrap; }
    .importAccBody{
      padding: 10px;
      border-top: 1px solid var(--borderA);
      background: var(--panelB);
    }
    .importAccTools{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .importAccTools .muted{ font-size:11px; }




    /* Markdown preview */
    .mdPreview{
      border: 1px solid var(--calloutBorder);
      background: var(--panelC);
      border-radius: 12px;
      padding: 10px;
      max-height: 80vh;
      min-width: 0;
      overflow-y: auto;
      overflow-x: hidden;
      color: var(--text);
    }
    .mdPreview h1,.mdPreview h2,.mdPreview h3,.mdPreview h4,.mdPreview h5,.mdPreview h6{ margin: 10px 0 6px; }
    .mdPreview p{ margin: 8px 0; }
    .mdPreview code{ font-family: var(--mono); background: rgba(255,255,255,.06); padding: 1px 6px; border-radius: 8px; }
    .mdPreview pre{
      background: var(--panel2);
      padding: 10px;
      border-radius: 12px;
      overflow-y:auto; overflow-x:hidden; white-space: pre-wrap; word-break: break-word;
      max-height: 80vh;
      border: 1px solid var(--calloutBorder);
    }
    .mdPreview pre code{ background: transparent; padding: 0; }
    .mdPreview blockquote{
      border-left: 3px solid var(--blockquoteBorder);
      margin: 8px 0;
      padding: 6px 10px;
      color: var(--muted);
      background: var(--blockquoteBg);
      border-radius: 10px;
    }

    .sectionTitle{
      margin-top:10px;
      font-weight:800;
      color: var(--text);
      font-size: 13px;
      letter-spacing: .2px;
    }
    .readonlyBox{
      width:100%;
      min-height: 140px;
      height: 240px;
      max-height: 45vh;
      font-family: var(--mono);
    }
  

    /* Prevent horizontal scrolling from long markdown/code/URLs */
    html, body { overflow-x: hidden; }
    .app, main, section, .card { overflow-x: hidden; }
    .modal { overflow-x: hidden; }
    #modalBody { overflow-x: hidden; }
    textarea { white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; overflow-x: hidden; }
    .mdPreview { overflow-x: hidden; max-width: 100%; overflow-wrap: anywhere; word-break: break-word; }
    .mdPreview pre { white-space: pre-wrap; overflow-x: hidden; max-width: 100%; }
    .mdPreview code { white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; }

    /* Modal header (title + close) */
.modalHeader{
  position: relative;
  z-index: 50;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin: 0 0 10px;
  padding: 2px 0 10px;
  background: var(--panel);
  border-bottom: 1px solid var(--border);
}


    .modalHeaderLeft{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    #modalHeaderActions{ flex-wrap: wrap; }

/* Scrollable modal content area */
#modalBody{
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 2px;
}

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin: 0 0 10px;
    }
    .field label{
      display:block;
      color: var(--muted);
      font-size: 12px;
    }
    .field input[type="text"]{ width:100%; }

    .pill.warn{

      border-color: rgba(255, 205, 76, .45);
      background: rgba(255, 205, 76, .12);
      color: rgba(255, 223, 160, 1);
    }


    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      z-index: 9999;
      display: none;
      max-width: min(680px, calc(100vw - 24px));
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--calloutBorder);
      background: var(--modalHeaderBg);
      color: var(--text);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .toast.show{ display:block; }

    
.mdTableWrap{
  width:100%;
  max-width:100%;
  min-width:0;
  overflow-x:auto;
  overflow-y:hidden;
  -webkit-overflow-scrolling: touch;
  border-radius: 12px;
  border: 1px solid var(--calloutBorder);
  background: var(--panelC);
  margin: 10px 0;
  padding-bottom: 6px; /* make room for horizontal scrollbar */
}
.mdPreview table{
  width: max-content;
  min-width: 100%;
  table-layout: auto;
  border-collapse: collapse;
  margin: 0;
}
.mdPreview th, .mdPreview td{
  border: 1px solid var(--calloutBorder);
  padding: 10px 12px;
  vertical-align: top;
  white-space: normal;
  word-break: normal;
  overflow-wrap: break-word;
  min-width: 180px;
  max-width: 560px;
}
.mdPreview th{ background: var(--panelB); font-weight: 800; }
.mdPreview tr:nth-child(even) td{ background: rgba(255,255,255,.03); }
:root[data-theme="light"] .mdPreview tr:nth-child(even) td{ background: rgba(20,40,80,.04); }
/* v7.7.2: cleaner tile header layouts (User/Career) */
    .tileSubHeader{ display:flex; flex-wrap:nowrap; gap:8px; align-items:center; justify-content:flex-start; margin: 0 0 10px; overflow-x:auto; -webkit-overflow-scrolling: touch; }

    .headerActions{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-end; }
    .actionGroup{ display:flex; flex-wrap:nowrap; gap:8px; align-items:center; padding:6px 8px; border:1px solid var(--border); border-radius:12px; background: var(--panelB); overflow-x:auto; -webkit-overflow-scrolling: touch; }
    .actionLabel{ font-size:12px; color: var(--muted); margin-right:2px; }
    .headerActions select{ min-width: 220px; max-width: 320px; }
    .actionGroup select{ min-width: 190px; max-width: 280px; }
    .fieldRow{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-top:10px; padding:10px 12px; border:1px solid var(--border); border-radius:12px; background: var(--panelB); }
    .fieldRow label{ font-size:12px; color: var(--muted); }


    /* v7.7.4: keep User/Career controls on a single row */
    .tileSubHeader::-webkit-scrollbar,
    .actionGroup::-webkit-scrollbar{ height:6px; }
    .tileSubHeader::-webkit-scrollbar-thumb,
    .actionGroup::-webkit-scrollbar-thumb{ background: rgba(120,140,180,.35); border-radius:999px; }
    :root[data-theme="light"] .tileSubHeader::-webkit-scrollbar-thumb,
    :root[data-theme="light"] .actionGroup::-webkit-scrollbar-thumb{ background: rgba(40,60,100,.18); }
    .actionGroup .btn{ white-space:nowrap; }
    


    /* v7.7.11: Drag-and-drop reordering (Setup lists only) */
    .item.sortable{ justify-content:flex-start; }
    .item.sortable .actions{ margin-left:auto; }
    .dragHandle{
      width: 26px;
      min-width: 26px;
      height: 26px;
      margin-top: 2px;
      margin-right: 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--panelB);
      display:flex;
      align-items:center;
      justify-content:center;
      color: var(--muted);
      cursor: grab;
      user-select: none;
    }

    /* Category manager */
    .catItem{ align-items:center; }
    .catTitle{
      font-weight:700;
      font-size:13px;
      flex:1;
      min-width: 160px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .catMeta{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .catMeta label{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
      user-select:none;
    }
    .catMeta input[type="checkbox"]{ transform: translateY(1px); }
    .catRowUnc{ opacity:.85; }
    .dragHandle:active{ cursor: grabbing; }
    .item.sortable.dragging{ opacity: .55; }
    

    /* Category groups (Setup list) */
    .catGroup{ border:1px solid var(--border); border-radius:14px; background: rgba(255,255,255,0.03); overflow:hidden; }
    body.light .catGroup{ background: rgba(0,0,0,0.02); }
    .catGroup + .catGroup{ margin-top:12px; }
    .catGroupHeader{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; cursor:pointer; user-select:none; }
    .catGroupTitleWrap{ display:flex; align-items:center; gap:10px; min-width:0; }
    .catGroupChevron{ font-size:13px; opacity:.75; flex:0 0 auto; }
    .catGroupTitle{ font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .catGroupMeta{ font-size:12px; opacity:.7; flex:0 0 auto; }
    .catGroupItems{ padding:10px 12px 12px; display:flex; flex-direction:column; gap:10px; }
    .catGroup.isCollapsed .catGroupItems{ display:none; }
    .catGroupEmpty{ opacity:.65; font-size:12px; padding:6px 0 0; }

</style>
</head>

<body>
  <div class="app">
    <header>
      <div class="title">
        <div class="titleRow">
          <h1>Prompt Builder</h1>
          <button class="modeChip" id="btnSyncProvider" title="Toggle Offline and Online">
            <span class="dot" aria-hidden="true"></span>
            <span class="label">Offline</span>
          </button>

          <div class="modeGroup" id="onlineModeGroup" style="display:none;">
            <button class="modeChip" id="btnSyncOnlineMode" title="Toggle Auto and Manual">
              <span class="dot" aria-hidden="true"></span>
              <span class="label">Manual</span>
            </button>
            
            <button class="modeChip iconOnly" id="btnSyncSettings" title="Sync settings">
              <span class="icon" aria-hidden="true">‚öô</span>
            </button>

            <div class="syncInfoBadge" id="syncInfoBadge" title="">
              <span class="syncInfoLabel">JSON</span>
              <span class="syncInfoValue" id="syncVersionValue">‚Äî</span>
              <span class="syncEditedTag" id="syncEditedTag" style="display:none">(edited)</span>
            </div>
          </div>
        </div>
        <div class="sub" id="syncSubText">Offline ¬∑ Local cache</div>
      </div>
      <div class="tabs" role="tablist" aria-label="Main Tabs">
        <button class="tab active" id="tabSetup" aria-selected="true">Setup</button>
        <button class="tab" id="tabPrompt" aria-selected="false">Prompt</button>
      </div>
    </header>

    <div class="topbar">
<div class="chip">
        <label>Data</label>
        <button class="btn mini" id="btnExportLogs">Export Change Log (CSV)</button>
        <button class="btn mini" id="btnExportSnapshot">Export Snapshot (JSON)</button>
        <button class="btn mini" id="btnImportSnapshot">Import Snapshot (JSON)</button>
        <button class="btn mini danger" id="btnWipeImportSnapshot" title="Delete all local data and replace it with the selected JSON snapshot">Wipe Local and Import JSON</button>
      </div>

      <div class="chip" style="margin-left:auto;">
        <label>Theme</label>
        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
          <button class="btn mini" id="btnToggleTheme">Light mode</button>
          <button class="btn mini" id="btnHardRefresh" title="Hard refresh (bypass cache)">‚Üª</button>
        </div>
      </div>

    </div>

    <!-- Setup Page -->
    <main id="pageSetup">
      <div class="grid">
        <section class="card">
          <h2>
            <span>Prompts</span>
            <div class="row" style="justify-content:flex-end; gap:8px;">
              <button class="btn mini" id="btnManageCatsPrompts" title="Manage categories">üóÇ</button>
              <button class="btn primary" id="btnAddPrompt">Add</button>
            </div>
          </h2>
          <div class="muted">Reusable prompt blocks (Markdown). Shared across all users.</div>
          <div class="divider"></div>
          <div class="list" id="listPrompts"></div>
          <div class="hint" id="hintPrompts" style="display:none;">No items yet. Click Add to create your first prompt block.</div>
        </section>

        <section class="card">
          <h2>
            <span>Personal Info</span>
            <div class="row" style="justify-content:flex-end; gap:8px;">
              <button class="btn mini" id="btnManageCatsPersonal" title="Manage categories">üóÇ</button>
              <button class="btn primary" id="btnAddPersonal">Add Item</button>
            </div>
          </h2>
          <div class="tileSubHeader">
            <div class="actionGroup">
              <span class="actionLabel">User</span>
              <select id="userSelect"></select>
              <button class="btn mini" id="btnAddUser">Add</button>
              <button class="btn mini" id="btnRenameUser">Rename</button>
              <button class="btn mini danger" id="btnDeleteUser">Delete</button>
            </div>
          </div>
          <div class="fieldRow" id="personalCareerPickRow">
            <label for="personalCareerPick">User Career</label>
            <select id="personalCareerPick" style="min-width:260px;"></select>
          </div>
          <div class="divider"></div>
          <div class="list" id="listPersonal"></div>
          <div class="hint" id="hintPersonal" style="display:none;">No items for this user yet. Click Add to create.</div>
        </section>

        <section class="card">
          <h2>
            <span>Career Info</span>
            <div class="row" style="justify-content:flex-end; gap:8px;">
              <button class="btn mini" id="btnManageCatsCareer" title="Manage categories">üóÇ</button>
              <button class="btn primary" id="btnAddCareerBlock">Add Item</button>
            </div>
          </h2>
          <div class="tileSubHeader">
            <div class="actionGroup">
              <span class="actionLabel">Career</span>
              <select id="careerFilter"></select>
              <button class="btn mini" id="btnAddCareerTop">Add</button>
              <button class="btn mini" id="btnRenameCareer">Rename</button>
              <button class="btn mini danger" id="btnDeleteCareer">Delete</button>
            </div>
          </div>
          <div class="divider"></div>
          <div style="margin-top:10px;">
            <div class="list" id="listCareerBlocks"></div>
            <div class="hint" id="hintCareerBlocks" style="display:none;">No items for this career yet. Click Add to create.</div>
          </div>
        </section>

        <section class="card">
          <h2>
            <span>Connection</span>
            <div class="row" style="justify-content:flex-end; gap:8px;">
              <button class="btn mini" id="btnManageCatsConnections" title="Manage categories">üóÇ</button>
              <button class="btn primary" id="btnAddConnection">Add</button>
            </div>
          </h2>
          <div class="muted">
            Global connections. Each connection can select items from Prompt, Personal Info, and Career Info.
            When you view/copy in the Prompt tab, it compiles using the current user and that user‚Äôs selected career.
            If a selected Personal/Career item has no content for the current user/career, the title is kept and the content is empty (you‚Äôll see an ‚ÄúEmpty‚Äù warning).
          </div>
          <div class="divider"></div>
          <div class="list" id="listConnections"></div>
          <div class="hint" id="hintConnections" style="display:none;">No connections yet. Click Add to create.</div>
        </section>
      </div>
    </main>

    <!-- Prompt Page -->
    <main id="pagePrompt" style="display:none;">
      <section class="card">
        <h2 style="margin:0 0 6px;">Prompt</h2>
        <div class="muted">Read only. Choose a user and career above to compile prompts per Connection.</div>
        <div class="divider"></div>

        <div class="row" style="justify-content:space-between; gap:10px; align-items:center; margin: 6px 0 12px; flex-wrap:wrap;">
          <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
            <div class="chip" style="padding:8px 10px; box-shadow:none;">
              <label>Current User</label>
              <select id="promptUserSelect" style="min-width:220px;"></select>
            </div>
            <div class="chip" style="padding:8px 10px; box-shadow:none;">
              <label>User Career</label>
              <select id="promptUserCareerSelect" style="min-width:260px;"></select>
            </div>
            <div class="chip" style="padding:8px 10px; box-shadow:none;">
              <label>Current Career</label>
              <select id="promptCurrentCareerSelect" style="min-width:260px;"></select>
            </div>
          </div>
</div>
        <div id="promptEmpty" class="hint" style="display:none;">
          No Connections found. Create them in Setup.
        </div>
        <div class="list" id="promptConnections"></div>
      </section>
    </main>

    <!-- Modal -->
    <div class="modalOverlay" id="modalOverlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <header class="modalHeader">
          <div class="modalHeaderLeft">
            <h3 id="modalTitle" style="margin:0; font-size: 14px;">Edit</h3>
            <div id="modalHeaderActions" class="row" style="gap:8px;"></div>
          </div>
          <button class="btn ghost mini" id="btnCloseModal" aria-label="Close">‚úï</button>
        </header>
        <div id="modalBody"></div>
        <div class="footer" id="modalFooter" style="display:flex; justify-content:flex-end; gap:10px; margin-top:12px;"></div>
      </div>
    </div>

    <input type="file" id="fileImportSnapshot" accept="application/json" style="display:none;" />
    <input type="file" id="fileImportSnapshotWipe" accept="application/json" style="display:none;" />
    <div class="toast" id="toast" aria-live="polite"></div>
  </div>

<script>
/** ========= Utilities ========= */
const $ = (sel) => document.querySelector(sel);
const nowISO = () => new Date().toISOString();
const formatLocal = (iso) => { try { return new Date(iso).toLocaleString(); } catch { return iso; } };
const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : ('id_' + Math.random().toString(16).slice(2) + '_' + Date.now()));
const escapeCsv = (v) => {
  const s = String(v ?? "");
  if (/[",\n\r]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
  return s;
};
const downloadText = (filename, text, mime='text/plain') => {
  const blob = new Blob([text], { type: mime });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(a.href);
};
const copyToClipboard = async (text) => {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.focus(); ta.select();
    try {
      const ok = document.execCommand('copy');
      ta.remove();
      return ok;
    } catch {
      ta.remove();
      return false;
    }
  }
};


/** ========= Theme ========= */
function setTheme(theme) {
  const t = (theme === 'light') ? 'light' : 'dark';
  document.documentElement.dataset.theme = t;
  localStorage.setItem('mivida_theme', t);
  const btn = $('#btnToggleTheme');
  if (btn) btn.textContent = (t === 'light') ? 'Dark mode' : 'Light mode';
}
function initTheme() {
  const saved = localStorage.getItem('mivida_theme');
  const t = saved ? saved : 'dark';
  setTheme(t);
}

function toast(msg, ms=2200){
  const el = document.getElementById('toast');
  if (!el) { alert(msg); return; }
  el.textContent = msg;
  el.classList.add('show');
  clearTimeout(toast._t);
  toast._t = setTimeout(() => el.classList.remove('show'), ms);
}

function txComplete(tx){
  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error || new Error('Transaction error'));
    tx.onabort = () => reject(tx.error || new Error('Transaction aborted'));
  });
}

async function safeGetAll(storeName){
  try { return await getAll(storeName); } catch { return []; }
}

/** ========= Minimal safe Markdown renderer (no external libs) ========= */
function escapeHtml(s){
  return String(s ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#039;');
}
function renderMarkdown(md){
  const lines = String(md ?? '').replace(/\r\n/g,'\n').split('\n');

  let html = '';
  let inCode = false;
  let codeBuf = [];
  let paraBuf = [];

  // Nested list stack: [{type:'ul'|'ol', indent:number, liOpen:boolean}]
  let listStack = [];

  const BR_TOKEN = '%%__BR__%%';

  const inlineFmt = (raw) => {
    let s = String(raw ?? '');

    // Allow <br> tags inside markdown (especially for tables)
    s = s.replace(/<br\s*\/?>/gi, BR_TOKEN);

    // Split by backticks for inline code (GFM-ish)
    const parts = s.split('`');
    let out = '';
    for (let k = 0; k < parts.length; k++){
      const seg = parts[k];
      if (k % 2 === 1){
        out += `<code>${escapeHtml(seg)}</code>`;
        continue;
      }
      let t = escapeHtml(seg);

      // Bold **text**
      t = t.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
      // Italic *text* (avoid **)
      t = t.replace(/\*(?!\*)([^*]+?)\*(?!\*)/g, '<em>$1</em>');

      out += t;
    }

    // Restore <br>
    out = out.split(BR_TOKEN).join('<br>');
    return out;
  };

  const flushPara = () => {
    if (!paraBuf.length) return;
    const text = paraBuf.join(' ').trim();
    if (text) html += `<p>${inlineFmt(text)}</p>`;
    paraBuf = [];
  };

  const closeAllLists = () => {
    while (listStack.length){
      const top = listStack.pop();
      if (top.liOpen) html += `</li>`;
      html += top.type === 'ul' ? `</ul>` : `</ol>`;
    }
  };

  const closeListsToIndent = (indent) => {
    while (listStack.length && indent < listStack[listStack.length - 1].indent){
      const top = listStack.pop();
      if (top.liOpen) html += `</li>`;
      html += top.type === 'ul' ? `</ul>` : `</ol>`;
    }
  };

  const ensureList = (type, indent) => {
    // Close deeper lists if needed
    closeListsToIndent(indent);

    if (!listStack.length){
      html += type === 'ul' ? `<ul>` : `<ol>`;
      listStack.push({ type, indent, liOpen: false });
      return;
    }

    const top = listStack[listStack.length - 1];

    // Nested list
    if (indent > top.indent){
      // Must be inside an open <li> of the parent list
      if (!top.liOpen){
        // If no open li, open an empty one to nest under (rare edge case)
        html += `<li>`;
        top.liOpen = true;
      }
      html += type === 'ul' ? `<ul>` : `<ol>`;
      listStack.push({ type, indent, liOpen: false });
      return;
    }

    // Same indent: switch list type if needed
    if (top.indent === indent && top.type !== type){
      if (top.liOpen) html += `</li>`;
      html += top.type === 'ul' ? `</ul>` : `</ol>`;
      listStack.pop();

      html += type === 'ul' ? `<ul>` : `<ol>`;
      listStack.push({ type, indent, liOpen: false });
      return;
    }

    // Same type, same indent: nothing to do
  };

  const startListItem = (type, indent, content) => {
    flushPara();
    ensureList(type, indent);

    const top = listStack[listStack.length - 1];

    // Close previous <li> in the same list
    if (top.liOpen) html += `</li>`;
    html += `<li>${inlineFmt(content)}`;
    top.liOpen = true;
  };

  const splitTableRow = (rowRaw) => {
    const s0 = String(rowRaw ?? '').trim();
    const leadingPipe = s0.startsWith('|');
    const trailingPipe = s0.endsWith('|');

    const cells = [];
    let cur = '';
    for (let i = 0; i < s0.length; i++){
      const ch = s0[i];
      if (ch === '\\' && s0[i+1] === '|'){
        cur += '|';
        i++;
        continue;
      }
      if (ch === '|'){
        cells.push(cur.trim());
        cur = '';
        continue;
      }
      cur += ch;
    }
    cells.push(cur.trim());

    if (leadingPipe) cells.shift();
    if (trailingPipe) cells.pop();

    return cells.map(c => c.trim());
  };

  const parseTableAlign = (sepLine, colCount) => {
    const parts = splitTableRow(sepLine);
    const aligns = [];
    for (let i = 0; i < colCount; i++){
      const cell = (parts[i] ?? '').trim().replace(/\s+/g,'');
      const plain = cell.replace(/:/g,'');
      const ok = /^-{2,}$/.test(plain);
      if (!ok) return null;

      const left = cell.startsWith(':');
      const right = cell.endsWith(':');
      if (left && right) aligns.push('center');
      else if (right) aligns.push('right');
      else aligns.push('left');
    }
    return aligns;
  };

  const isPotentialTableHeader = (line) => {
    const t = String(line ?? '').trim();
    return t.includes('|');
  };

  const normalizeRow = (cells, count) => {
    const out = cells.slice(0, count);
    while (out.length < count) out.push('');
    return out;
  };

  let i = 0;
  while (i < lines.length){
    const raw = lines[i];

    // Code fence
    if (raw.trim().startsWith('```')) {
      if (!inCode) {
        flushPara(); closeAllLists();
        inCode = true; codeBuf = [];
      } else {
        const code = escapeHtml(codeBuf.join('\n'));
        html += `<pre><code>${code}</code></pre>`;
        inCode = false; codeBuf = [];
      }
      i++;
      continue;
    }
    if (inCode) { codeBuf.push(raw); i++; continue; }

    const rawRight = raw.trimRight();
    const lead = rawRight.match(/^\s*/)?.[0] ?? '';
    const indent = lead.length;
    const line = rawRight; // keep leading spaces for list nesting decisions

    // Blank line
    if (!line.trim()){
      flushPara();
      // Keep list contexts open across blank lines so ordered lists don't restart.
      // (Markdown allows blank lines between list items and between a parent item and its nested list.)
      i++;
      continue;
    }

    // Table (GFM-ish): header line + separator line
    if (isPotentialTableHeader(line) && i + 1 < lines.length){
      const sep = lines[i+1].trimRight();
      const headerCells = splitTableRow(line);
      const aligns = parseTableAlign(sep, headerCells.length);
      if (aligns) {
        flushPara(); closeAllLists();

        const rows = [];
        let j = i + 2;
        while (j < lines.length){
          const rowLine = lines[j].trimRight();
          if (!rowLine.trim()) break;
          if (!rowLine.includes('|')) break;
          if (parseTableAlign(rowLine, headerCells.length)) break;

          rows.push(normalizeRow(splitTableRow(rowLine), headerCells.length));
          j++;
        }

        html += `<div class="mdTableWrap"><table class="mdTable"><thead><tr>`;
        for (let c = 0; c < headerCells.length; c++){
          const a = aligns[c] || 'left';
          html += `<th style="text-align:${a}">${inlineFmt(headerCells[c])}</th>`;
        }
        html += `</tr></thead>`;

        if (rows.length){
          html += `<tbody>`;
          for (const r of rows){
            html += `<tr>`;
            for (let c = 0; c < headerCells.length; c++){
              const a = aligns[c] || 'left';
              html += `<td style="text-align:${a}">${inlineFmt(r[c])}</td>`;
            }
            html += `</tr>`;
          }
          html += `</tbody>`;
        }

        html += `</table></div>`;
        i = j;
        continue;
      }
    }

    // Blockquote
    if (line.trim().startsWith('> ')) {
      flushPara(); closeAllLists();
      html += `<blockquote>${inlineFmt(line.trim().slice(2))}</blockquote>`;
      i++;
      continue;
    }

    // Headings
    const mH = line.match(/^\s*(#{1,6})\s+(.+)$/);
    if (mH) {
      flushPara(); closeAllLists();
      const level = mH[1].length;
      html += `<h${level}>${inlineFmt(mH[2])}</h${level}>`;
      i++;
      continue;
    }

    // Unordered list item (supports indentation and ‚Ä¢)
    const mUl = line.match(/^\s*[-*+‚Ä¢]\s+(.+)$/);
    if (mUl) {
      startListItem('ul', indent, mUl[1]);
      i++;
      continue;
    }

    // Ordered list item (supports indentation)
    const mOl = line.match(/^\s*\d+\.\s+(.+)$/);
    if (mOl) {
      startListItem('ol', indent, mOl[1]);
      i++;
      continue;
    }

    // Non-list content
    if (listStack.length){
      // If this line is indented more than the current list level, treat as continuation inside <li>
      const top = listStack[listStack.length - 1];
      if (indent > top.indent){
        // add as a line inside current li
        html += `<div class="mdLiCont">${inlineFmt(line.trim())}</div>`;
        i++;
        continue;
      }
      // otherwise, end lists and treat as paragraph
      closeAllLists();
    }

    paraBuf.push(line.trim());
    i++;
  }

  // finalize
  if (inCode) {
    const code = escapeHtml(codeBuf.join('\n'));
    html += `<pre><code>${code}</code></pre>`;
  }
  closeAllLists();
  flushPara();
  return html;
}


/** ========= IndexedDB ========= */
const DB_NAME = 'mivida_prompt_builder_offline';
const DB_VERSION = 4;

let dbPromise = null;

function openDB() {
  if (dbPromise) return dbPromise;
  dbPromise = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);

    req.onupgradeneeded = (e) => {
      const db = req.result;
      const tx = req.transaction;
      const oldVersion = e.oldVersion || 0;

      // v1 stores
      if (oldVersion < 1) {
        const users = db.createObjectStore('users', { keyPath: 'id' });
        users.createIndex('by_name', 'name', { unique: false });

        const prompts = db.createObjectStore('promptItems', { keyPath: 'id' });
        prompts.createIndex('by_updatedAt', 'updatedAt', { unique: false });

        const personal = db.createObjectStore('personalItems', { keyPath: 'id' });
        personal.createIndex('by_userId', 'userId', { unique: false });

        db.createObjectStore('userCareer', { keyPath: 'userId' });

        const connections = db.createObjectStore('connections', { keyPath: 'id' });
        connections.createIndex('by_updatedAt', 'updatedAt', { unique: false });

        const logs = db.createObjectStore('changeLogs', { keyPath: 'id' });
        logs.createIndex('by_timestamp', 'timestamp', { unique: false });
      } else {
        // ensure missing indexes for safety
        if (!db.objectStoreNames.contains('changeLogs')) {
          const logs = db.createObjectStore('changeLogs', { keyPath: 'id' });
          logs.createIndex('by_timestamp', 'timestamp', { unique: false });
        }
      }

      // v2: careers + careerBlocks
      if (!db.objectStoreNames.contains('careers')) {
        const careers = db.createObjectStore('careers', { keyPath: 'id' });
        careers.createIndex('by_title', 'title', { unique: false });
        careers.createIndex('by_updatedAt', 'updatedAt', { unique: false });
      }
      if (!db.objectStoreNames.contains('careerBlocks')) {
        const blocks = db.createObjectStore('careerBlocks', { keyPath: 'id' });
        blocks.createIndex('by_careerId', 'careerId', { unique: false });
        blocks.createIndex('by_careerId_updatedAt', ['careerId', 'updatedAt'], { unique: false });
      }

      // Migration (best effort): old 'careerItems' -> careers + careerBlocks(Main)
      if (oldVersion < 2) {
        if (db.objectStoreNames.contains('careerItems')) {
          const oldStore = tx.objectStore('careerItems');
          const getAllReq = oldStore.getAll();
          getAllReq.onsuccess = () => {
            const oldRows = getAllReq.result || [];
            const careersStore = tx.objectStore('careers');
            const blocksStore = tx.objectStore('careerBlocks');

            oldRows.forEach((c) => {
              const career = {
                id: c.id,
                title: c.title || '(Career)',
                createdAt: c.createdAt || nowISO(),
                updatedAt: c.updatedAt || c.createdAt || nowISO()
              };
              careersStore.put(career);

              const block = {
                id: uid(),
                careerId: c.id,
                title: 'Main',
                content: c.content || '',
                createdAt: career.createdAt,
                updatedAt: career.updatedAt
              };
              blocksStore.add(block);
            });
          };
        }

        // Migration: old per-user connections -> global: keep promptItemIds, drop personal selection/userId
        if (db.objectStoreNames.contains('connections')) {
          const connStore = tx.objectStore('connections');
          const reqAll = connStore.getAll();
          reqAll.onsuccess = () => {
            const rows = reqAll.result || [];
            rows.forEach((r) => {
              const migrated = {
                id: r.id,
                title: r.title || '',
                promptItemIds: r.promptItemIds || [],
                createdAt: r.createdAt || nowISO(),
                updatedAt: r.updatedAt || r.createdAt || nowISO()
              };
              connStore.put(migrated);
            });
          };
        }
      }
      // v3: Templates for Personal & Career items + per-user/per-career content
      if (oldVersion < 3) {
        const now = new Date().toISOString();
        const mkId = () => (self.crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).slice(2));

        if (!db.objectStoreNames.contains('personalTemplates')) {
          const st = db.createObjectStore('personalTemplates', { keyPath: 'id' });
          st.createIndex('by_title', 'title', { unique: false });
          st.createIndex('by_updatedAt', 'updatedAt', { unique: false });
        }
        if (!db.objectStoreNames.contains('personalContent')) {
          const sc = db.createObjectStore('personalContent', { keyPath: ['userId', 'templateId'] });
          sc.createIndex('by_userId', 'userId', { unique: false });
          sc.createIndex('by_templateId', 'templateId', { unique: false });
          sc.createIndex('by_userId_updatedAt', ['userId', 'updatedAt'], { unique: false });
        }

        if (!db.objectStoreNames.contains('careerTemplates')) {
          const ct = db.createObjectStore('careerTemplates', { keyPath: 'id' });
          ct.createIndex('by_title', 'title', { unique: false });
          ct.createIndex('by_updatedAt', 'updatedAt', { unique: false });
        }
        if (!db.objectStoreNames.contains('careerContent')) {
          const cc = db.createObjectStore('careerContent', { keyPath: ['careerId', 'templateId'] });
          cc.createIndex('by_careerId', 'careerId', { unique: false });
          cc.createIndex('by_templateId', 'templateId', { unique: false });
          cc.createIndex('by_careerId_updatedAt', ['careerId', 'updatedAt'], { unique: false });
        }

        // Migration: personalItems (per-user) -> personalTemplates (global) + personalContent (per-user)
        try {
          if (db.objectStoreNames.contains('personalItems')) {
            const oldStore = tx.objectStore('personalItems');
            const tplStore = tx.objectStore('personalTemplates');
            const contentStore = tx.objectStore('personalContent');

            const reqAll = oldStore.getAll();
            reqAll.onsuccess = () => {
              const rows = reqAll.result || [];
              const titleToTpl = new Map();

              // create templates (unique by title)
              rows.forEach(r => {
                const title = (r.title || '').trim();
                if (!title) return;
                if (!titleToTpl.has(title)) {
                  titleToTpl.set(title, {
                    id: mkId(),
                    title,
                    createdAt: r.createdAt || now,
                    updatedAt: r.updatedAt || r.createdAt || now
                  });
                } else {
                  // keep latest updatedAt
                  const tpl = titleToTpl.get(title);
                  const u = r.updatedAt || r.createdAt || now;
                  if ((tpl.updatedAt || '') < u) tpl.updatedAt = u;
                }
              });

              titleToTpl.forEach(tpl => tplStore.put(tpl));

              // create content rows
              rows.forEach(r => {
                const title = (r.title || '').trim();
                const tpl = titleToTpl.get(title);
                if (!tpl) return;
                contentStore.put({
                  userId: r.userId,
                  templateId: tpl.id,
                  content: r.content || '',
                  createdAt: r.createdAt || now,
                  updatedAt: r.updatedAt || r.createdAt || now
                });
              });
            };
          }
        } catch (err) { /* best effort */ }

        // Migration: careerBlocks (per-career) -> careerTemplates (global) + careerContent (per-career)
        try {
          if (db.objectStoreNames.contains('careerBlocks')) {
            const oldStore = tx.objectStore('careerBlocks');
            const tplStore = tx.objectStore('careerTemplates');
            const contentStore = tx.objectStore('careerContent');

            const reqAll = oldStore.getAll();
            reqAll.onsuccess = () => {
              const rows = reqAll.result || [];
              const titleToTpl = new Map();

              rows.forEach(r => {
                const title = (r.title || '').trim();
                if (!title) return;
                if (!titleToTpl.has(title)) {
                  titleToTpl.set(title, {
                    id: mkId(),
                    title,
                    createdAt: r.createdAt || now,
                    updatedAt: r.updatedAt || r.createdAt || now
                  });
                } else {
                  const tpl = titleToTpl.get(title);
                  const u = r.updatedAt || r.createdAt || now;
                  if ((tpl.updatedAt || '') < u) tpl.updatedAt = u;
                }
              });

              titleToTpl.forEach(tpl => tplStore.put(tpl));

              rows.forEach(r => {
                const title = (r.title || '').trim();
                const tpl = titleToTpl.get(title);
                if (!tpl) return;
                contentStore.put({
                  careerId: r.careerId,
                  templateId: tpl.id,
                  content: r.content || '',
                  createdAt: r.createdAt || now,
                  updatedAt: r.updatedAt || r.createdAt || now
                });
              });
            };
          }
        } catch (err) { /* best effort */ }

        // Normalize: ensure connections have arrays for all categories
        try {
          if (db.objectStoreNames.contains('connections')) {
            const connStore = tx.objectStore('connections');
            const reqAll = connStore.getAll();
            reqAll.onsuccess = () => {
              const rows = reqAll.result || [];
              rows.forEach(r => {
                const patched = {
                  ...r,
                  promptItemIds: r.promptItemIds || [],
                  personalTemplateIds: r.personalTemplateIds || [],
                  careerTemplateIds: r.careerTemplateIds || [],
                  updatedAt: r.updatedAt || r.createdAt || now
                };
                connStore.put(patched);
              });
            };
          }
        } catch (err) { /* best effort */ }
      }

      // v4: Setup Categories (per Setup section) + order + default collapse
      if (oldVersion < 4) {
        try {
          if (!db.objectStoreNames.contains('setupCategories')) {
            const sc = db.createObjectStore('setupCategories', { keyPath: 'id' });
            sc.createIndex('by_sectionKey', 'sectionKey', { unique: false });
            sc.createIndex('by_sectionKey_order', ['sectionKey', 'order'], { unique: false });
          }
        } catch (err) { /* best effort */ }
      } else {
        // Safety: ensure store/indexes exist
        try {
          if (!db.objectStoreNames.contains('setupCategories')) {
            const sc = db.createObjectStore('setupCategories', { keyPath: 'id' });
            sc.createIndex('by_sectionKey', 'sectionKey', { unique: false });
            sc.createIndex('by_sectionKey_order', ['sectionKey', 'order'], { unique: false });
          } else {
            const sc = tx.objectStore('setupCategories');
            if (!sc.indexNames.contains('by_sectionKey')) sc.createIndex('by_sectionKey', 'sectionKey', { unique: false });
            if (!sc.indexNames.contains('by_sectionKey_order')) sc.createIndex('by_sectionKey_order', ['sectionKey', 'order'], { unique: false });
          }
        } catch (err) { /* best effort */ }
      }


    };

    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return dbPromise;
}

async function withStore(storeName, mode, fn) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, mode);
    const store = tx.objectStore(storeName);
    const res = fn(store, tx);
    tx.oncomplete = () => {
      try { if (mode === 'readwrite') markLocalModified(); } catch {}
      resolve(res);
    };
    tx.onerror = () => reject(tx.error);
    tx.onabort = () => reject(tx.error);
  });
}
async function getAll(storeName) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const req = store.getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
async function getOne(storeName, key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result ?? null);
    req.onerror = () => reject(req.error);
  });
}
async function putOne(storeName, value) { return withStore(storeName, 'readwrite', (s) => s.put(value)); }
async function addOne(storeName, value) { return withStore(storeName, 'readwrite', (s) => s.add(value)); }
async function deleteOne(storeName, key) { return withStore(storeName, 'readwrite', (s) => s.delete(key)); }

async function getByIndex(storeName, indexName, query) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    const idx = store.index(indexName);
    const req = idx.getAll(query);
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

/** ========= Change Log ========= */
async function logChange({ entityType, entityId, action, after, before=null }) {
  const row = { id: uid(), timestamp: nowISO(), entityType, entityId, action, after, before };
  await addOne('changeLogs', row);
}

/** ========= State ========= */
const state = { currentUserId: null, currentCareerId: null, promptCareerId: '', activeTab: 'setup' };
// NOTE: promptCareerId is kept for backward compatibility, but is always synced to currentCareerId.

/** ========= UI Sort (local-only, affects Setup lists only) ========= */
const UI_SORT_STORAGE_KEY = 'mivida_uiSort_v1';
let uiSort = (() => {
  try {
    const raw = localStorage.getItem(UI_SORT_STORAGE_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    return (obj && typeof obj === 'object') ? obj : {};
  } catch {
    return {};
  }
})();
function saveUiSort(){
  try { localStorage.setItem(UI_SORT_STORAGE_KEY, JSON.stringify(uiSort || {})); } catch {}
}
function getUiOrder(sortKey){
  const v = uiSort?.[sortKey];
  return Array.isArray(v) ? v : null;
}
function setUiOrder(sortKey, ids){
  uiSort = uiSort || {};
  uiSort[sortKey] = Array.isArray(ids) ? ids : [];
  saveUiSort();
}
function applyUiOrder(items, sortKey, getId, fallbackSortFn){
  const arr = [...(items || [])];
  const order = getUiOrder(sortKey);
  if (!order || order.length === 0){
    if (fallbackSortFn) arr.sort(fallbackSortFn);
    return arr;
  }
  const idx = new Map(order.map((id,i) => [id, i]));
  arr.sort((a,b) => {
    const ia = idx.has(getId(a)) ? idx.get(getId(a)) : 1e9;
    const ib = idx.has(getId(b)) ? idx.get(getId(b)) : 1e9;
    if (ia !== ib) return ia - ib;
    return fallbackSortFn ? fallbackSortFn(a,b) : 0;
  });

  // keep order list healthy: remove deleted ids, append new ids
  const ids = arr.map(getId).filter(Boolean);
  const set = new Set(ids);
  const cleaned = order.filter(id => set.has(id));
  const cleanedSet = new Set(cleaned);
  for (const id of ids){
    if (!cleanedSet.has(id)) cleaned.push(id);
  }
  if (cleaned.length !== order.length || cleaned.some((v,i) => v !== order[i])){
    setUiOrder(sortKey, cleaned);
  }

  return arr;
}

function applyUiSortFromSnapshot(sortObj, mode='merge'){
  if (!sortObj || typeof sortObj !== 'object') return;
  if (mode === 'replace') uiSort = {};
  uiSort = uiSort || {};
  for (const k of Object.keys(sortObj)){
    const arr = sortObj[k];
    if (Array.isArray(arr)) uiSort[k] = arr;
  }
  saveUiSort();
}

let dragCtx = null; // { sortKey, el }
function initSortableList(listEl, sortKey){
  if (!listEl || listEl.dataset.sortInit === '1') return;
  listEl.dataset.sortInit = '1';
  listEl.dataset.sortKey = sortKey;

  listEl.addEventListener('dragover', (e) => {
    if (!dragCtx || dragCtx.sortKey !== sortKey) return;
    e.preventDefault();
    const after = getDragAfterElement(listEl, e.clientY);
    if (!after) listEl.appendChild(dragCtx.el);
    else listEl.insertBefore(dragCtx.el, after);
  });

  listEl.addEventListener('drop', (e) => {
    if (!dragCtx || dragCtx.sortKey !== sortKey) return;
    e.preventDefault();
    finalizeSort(listEl, sortKey);
  });

  listEl.addEventListener('dragend', () => {
    if (dragCtx && dragCtx.sortKey === sortKey) cleanupDrag();
  });
}
function getDragAfterElement(container, y){
  const items = [...container.querySelectorAll('.item.sortable:not(.dragging)')];
  let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
  for (const child of items){
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height/2;
    if (offset < 0 && offset > closest.offset){
      closest = { offset, element: child };
    }
  }
  return closest.element;
}
function cleanupDrag(){
  if (dragCtx?.el) dragCtx.el.classList.remove('dragging');
  dragCtx = null;
}
function finalizeSort(listEl, sortKey){
  const ids = [...listEl.querySelectorAll('.item.sortable')]
    .map(el => el.dataset.sortId)
    .filter(Boolean);
  setUiOrder(sortKey, ids);
  cleanupDrag();
  toast('Order saved');
}
function makeRowSortable(rowEl, { sortKey, id }){
  if (!rowEl) return rowEl;
  rowEl.classList.add('sortable');
  rowEl.dataset.sortId = id;

  const handle = document.createElement('div');
  handle.className = 'dragHandle';
  handle.textContent = '‚†ø';
  handle.title = 'Drag to reorder';
  handle.setAttribute('draggable', 'true');

  handle.addEventListener('dragstart', (e) => {
    dragCtx = { sortKey, el: rowEl };
    rowEl.classList.add('dragging');
    try {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', String(id || ''));
    } catch {}
  });
  handle.addEventListener('dragend', () => cleanupDrag());

  rowEl.insertBefore(handle, rowEl.firstChild);
  return rowEl;
}



function setTab(tab){
  state.activeTab = tab;
  const isSetup = (tab === 'setup');
  const pageSetup = $('#pageSetup');
  const pagePrompt = $('#pagePrompt');
  if (pageSetup) pageSetup.style.display = isSetup ? '' : 'none';
  if (pagePrompt) pagePrompt.style.display = isSetup ? 'none' : '';

  const tSetup = $('#tabSetup');
  const tPrompt = $('#tabPrompt');
  if (tSetup) {
    tSetup.classList.toggle('active', isSetup);
    tSetup.setAttribute('aria-selected', isSetup ? 'true' : 'false');
  }
  if (tPrompt) {
    tPrompt.classList.toggle('active', !isSetup);
    tPrompt.setAttribute('aria-selected', !isSetup ? 'true' : 'false');
  }

  // When entering Prompt tab, ensure it renders latest compiled output.
  if (!isSetup) {
    Promise.resolve(renderPromptPickers()).then(() => renderPromptPage()).catch((e) => { console.error(e); toast('Failed to render Prompt tab'); });
  }
}
/** ========= Modal helpers ========= */
function openModal(title, bodyEl, footerButtons=[], headerButtons=[], opts={}) {
  const overlay = $('#modalOverlay');
  const modalBox = overlay ? overlay.querySelector('.modal') : null;

  // Reset modal mode
  if (overlay) overlay.classList.remove('fullscreen');
  if (modalBox) modalBox.classList.remove('fullscreen');

  // Apply mode
  if (opts && opts.fullscreen) {
    if (overlay) overlay.classList.add('fullscreen');
    if (modalBox) modalBox.classList.add('fullscreen');
  }
  // Remember what kind of modal this is (used for import context cleanup)
  if (overlay) {
    try { overlay.dataset.kind = (opts && opts.kind) ? String(opts.kind) : ''; } catch {}
  }

  $('#modalTitle').textContent = title;

  const headerAct = $('#modalHeaderActions');
  if (headerAct) {
    headerAct.innerHTML = '';
    headerButtons.forEach(b => headerAct.appendChild(b));
  }

  const body = $('#modalBody');
  body.innerHTML = '';
  body.appendChild(bodyEl);

  const footer = $('#modalFooter');
  footer.innerHTML = '';
  footerButtons.forEach(b => footer.appendChild(b));
  footer.style.display = footerButtons.length ? 'flex' : 'none';

  if (overlay) {
    overlay.classList.add('open');
    overlay.setAttribute('aria-hidden', 'false');
  }
}
function closeModal() {
  const overlay = $('#modalOverlay');
  const _kind = (() => { try { return overlay && overlay.dataset ? overlay.dataset.kind : ''; } catch { return ''; } })();
  if (_kind === 'import') { try { pendingOnlineImportMeta = null; } catch {} }
  if (overlay) { try { overlay.dataset.kind = ''; } catch {} }
  const modalBox = overlay ? overlay.querySelector('.modal') : null;

  if (overlay) {
    overlay.classList.remove('open');
    overlay.classList.remove('fullscreen');
    overlay.setAttribute('aria-hidden', 'true');
  }
  if (modalBox) modalBox.classList.remove('fullscreen');

  const headerAct = $('#modalHeaderActions');
  if (headerAct) headerAct.innerHTML = '';

  const footer = $('#modalFooter');
  if (footer) footer.style.display = 'flex';
}
function btn(text, opts={}) {
  const b = document.createElement('button');
  b.className = 'btn' + (opts.primary ? ' primary' : '') + (opts.danger ? ' danger' : '') + (opts.ghost ? ' ghost' : '') + (opts.mini ? ' mini' : '');
  b.textContent = text;
  if (opts.onClick) b.addEventListener('click', opts.onClick);
  return b;
}

function makeOutputControl({ tpl, storeName, entityType, connections }) {
  const wrap = document.createElement('div');
  wrap.className = 'outCtrl';

  const cb = document.createElement('input');
  cb.type = 'checkbox';
  // Default behavior: output is ON unless explicitly set to false
  const currentOn = (tpl?.isOutput !== false);
  cb.checked = currentOn;

  const lbl = document.createElement('label');
  lbl.textContent = 'Output';

  const sel = document.createElement('select');
  sel.style.display = cb.checked ? '' : 'none';

  function setOptions(conns) {
    sel.innerHTML = '';

    const opAny = document.createElement('option');
    opAny.value = '';
    opAny.textContent = 'All connections';
    sel.appendChild(opAny);

    (conns || []).forEach(c => {
      const op = document.createElement('option');
      op.value = c.id;
      op.textContent = c.title || '(Untitled)';
      sel.appendChild(op);
    });

    const current = (tpl?.outputConnectionId || '');
    // If a previously selected connection no longer exists, keep it visible.
    if (current && !Array.from(sel.options).some(o => o.value === current)) {
      const op = document.createElement('option');
      op.value = current;
      op.textContent = '(Missing connection)';
      sel.appendChild(op);
    }
    sel.value = current;
  }

  // Initial populate
  if (Array.isArray(connections)) {
    setOptions(connections);
  } else {
    setOptions([], outputMeta.assignments || null);
    (async () => {
      try {
        let conns = await getAll('connections');
        conns = applyUiOrder(conns, 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
        setOptions(conns, outputMeta.assignments || null);
      } catch(e) { /* ignore */ }
    })();
  }

  async function persist() {
    const before = await getOne(storeName, tpl.id);
    const after = {
      ...(before || tpl),
      isOutput: cb.checked,
      outputConnectionId: (sel.value || ''),
      updatedAt: nowISO()
    };
    await putOne(storeName, after);
    // best-effort change log
    try {
      await logChange({ entityType, entityId: tpl.id, action: 'update', after, before });
    } catch(e) { /* ignore */ }
    await refreshAll();
  }

  cb.addEventListener('change', async () => {
    sel.style.display = cb.checked ? '' : 'none';
    await persist();
  });
  sel.addEventListener('change', async () => {
    if (!cb.checked) return;
    await persist();
  });

  wrap.appendChild(cb);
  wrap.appendChild(lbl);
  wrap.appendChild(sel);
  return wrap;
}



function makeItemRow({ title, subtitle, pills=[] }, actions=[]) {
  const wrap = document.createElement('div');
  wrap.className = 'item';
  const meta = document.createElement('div');
  meta.className = 'meta';

  const name = document.createElement('div');
  name.className = 'name';
  name.textContent = title || '(Untitled)';

  const small = document.createElement('div');
  small.className = 'small';
  small.textContent = subtitle || '';

  meta.appendChild(name);
  meta.appendChild(small);

  if (pills.length) {
    const pillRow = document.createElement('div');
    pillRow.className = 'row';
    pills.forEach(p => {
      const sp = document.createElement('span');
      if (typeof p === 'string') {
        sp.className = 'pill';
        sp.textContent = p;
      } else {
        sp.className = 'pill' + (p?.className ? (' ' + p.className) : '');
        sp.textContent = p?.text ?? '';
      }
      pillRow.appendChild(sp);
    });
    meta.appendChild(pillRow);
  }

  const act = document.createElement('div');
  act.className = 'actions';
  actions.forEach(a => act.appendChild(a));

  wrap.appendChild(meta);
  wrap.appendChild(act);
  return wrap;
}
function inputRow(labelText, inputEl) {
  const row = document.createElement('div');
  row.className = 'formRow';
  const label = document.createElement('div');
  label.className = 'formLabel';
  label.textContent = labelText;
  row.appendChild(label);
  row.appendChild(inputEl);

  // Better alignment for multi-line controls
  if (String(inputEl?.tagName || '').toUpperCase() === 'TEXTAREA') {
    row.classList.add('top');
  }
  return row;
}

/** ========= Bootstrap ========= */
async function ensureSeed() {
  const users = await getAll('users');
  if (!users.length) {
    const me = { id: uid(), name: 'Me', createdAt: nowISO(), updatedAt: nowISO() };
    await addOne('users', me);
    await logChange({ entityType: 'user', entityId: me.id, action: 'create', after: me });
  }
}


/** ========= Setup Categories ========= */
const SETUP_SECTIONS = [
  { key: 'promptItems', label: 'Prompts' },
  { key: 'personalTemplates', label: 'Personal Info' },
  { key: 'careerTemplates', label: 'Career Info' },
  { key: 'connections', label: 'Connection' }
];

async function getSetupCategories(sectionKey){
  // Prefer index for efficiency, but fall back safely.
  try {
    const rows = await getByIndex('setupCategories', 'by_sectionKey', sectionKey);
    return (rows || []).sort((a,b) => (a.order||0) - (b.order||0));
  } catch {
    const all = await safeGetAll('setupCategories');
    return (all || []).filter(x => x.sectionKey === sectionKey).sort((a,b) => (a.order||0) - (b.order||0));
  }
}

function renderCategoryGroups({ listEl, hintEl, sectionKey, categories, items, sortKey, emptyHintText, makeRow }) {
  const catsAll = Array.isArray(categories) ? categories : [];
  const cats = catsAll.filter(c => String(c.sectionKey || '') === String(sectionKey || ''))
    .sort((a, b) => {
      const ao = (typeof a.order === 'number') ? a.order : 0;
      const bo = (typeof b.order === 'number') ? b.order : 0;
      if (ao !== bo) return ao - bo;
      return String(a.title || '').localeCompare(String(b.title || ''));
    });

  const itemsArr = Array.isArray(items) ? items : [];
  const hasAny = (itemsArr.length > 0) || (cats.length > 0);

  if (hintEl) hintEl.style.display = hasAny ? 'none' : 'block';
  if (!hasAny) return;

  const catIds = new Set(cats.map(c => String(c.id)));
  const byCat = new Map();

  for (const it of itemsArr) {
    const raw = String(it?.categoryId || '');
    const key = catIds.has(raw) ? raw : '';
    if (!byCat.has(key)) byCat.set(key, []);
    byCat.get(key).push(it);
  }

  const groups = [
    { id: '', title: 'Uncategorized', isCollapsed: false, order: -1, __virtual: true },
    ...cats
  ];

  groups.forEach(cat => {
    const groupEl = document.createElement('div');
    groupEl.className = 'catGroup' + (cat.isCollapsed ? ' isCollapsed' : '');
    groupEl.dataset.catId = String(cat.id || '');

    const header = document.createElement('div');
    header.className = 'catGroupHeader';

    const titleWrap = document.createElement('div');
    titleWrap.className = 'catGroupTitleWrap';

    const chev = document.createElement('span');
    chev.className = 'catGroupChevron';
    chev.textContent = groupEl.classList.contains('isCollapsed') ? '‚ñ∏' : '‚ñæ';

    const title = document.createElement('div');
    title.className = 'catGroupTitle';
    title.textContent = cat.title || '(Untitled)';

    titleWrap.appendChild(chev);
    titleWrap.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'catGroupMeta';

    const groupItems = byCat.get(String(cat.id || '')) || [];
    meta.textContent = String(groupItems.length);

    header.appendChild(titleWrap);
    header.appendChild(meta);

    // Toggle is UI-only: does not persist or change isCollapsed in the category record.
    header.onclick = () => {
      const collapsed = groupEl.classList.toggle('isCollapsed');
      chev.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
    };

    const itemsEl = document.createElement('div');
    itemsEl.className = 'catGroupItems';

    const ordered = groupItems.slice().sort((a, b) => {
      const ao = (typeof a.sortOrder === 'number') ? a.sortOrder : 0;
      const bo = (typeof b.sortOrder === 'number') ? b.sortOrder : 0;
      if (ao !== bo) return ao - bo;
      return String(a.title || a.name || '').localeCompare(String(b.title || b.name || ''));
    });

    if (!ordered.length) {
      const empty = document.createElement('div');
      empty.className = 'catGroupEmpty';
      empty.textContent = emptyHintText || 'No items.';
      itemsEl.appendChild(empty);
    } else {
      ordered.forEach(it => itemsEl.appendChild(makeRow(it)));
    }

    groupEl.appendChild(header);
    groupEl.appendChild(itemsEl);
    listEl.appendChild(groupEl);
  });
}



async function upsertSetupCategory(cat){
  const now = nowISO();
  const row = {
    id: cat.id || uid(),
    sectionKey: cat.sectionKey,
    title: (cat.title || '').trim() || 'Untitled',
    order: Number.isFinite(cat.order) ? cat.order : 1000,
    isCollapsed: !!cat.isCollapsed,
    createdAt: cat.createdAt || now,
    updatedAt: now
  };
  await putOne('setupCategories', row);
  return row;
}

async function deleteSetupCategory(sectionKey, catId){
  // Delete category row
  await deleteOne('setupCategories', catId);

  // Move any items in that category to Uncategorized (best effort)
  await clearCategoryFromItems(sectionKey, catId);

  // Re-normalize category order (keep gaps small)
  const cats = await getSetupCategories(sectionKey);
  const tx = await openDB();
  if (!tx.objectStoreNames.contains('setupCategories')) return;
  const now = nowISO();
  const txx = tx.transaction('setupCategories','readwrite');
  const store = txx.objectStore('setupCategories');
  cats.forEach((c, i) => {
    store.put({ ...c, order: (i+1)*1000, updatedAt: now });
  });
  await txComplete(txx);
}

async function clearCategoryFromItems(sectionKey, catId){
  const storeName = sectionKey; // sectionKey matches store name for the 4 Setup sections
  const db = await openDB();
  if (!db.objectStoreNames.contains(storeName)) return;
  const items = await safeGetAll(storeName);
  const now = nowISO();
  const changed = (items || []).filter(x => String(x.categoryId || '') === String(catId));
  if (!changed.length) return;

  const tx = db.transaction(storeName, 'readwrite');
  const st = tx.objectStore(storeName);
  changed.forEach(x => {
    st.put({ ...x, categoryId: '', updatedAt: now });
  });
  await txComplete(tx);
}

/** Category list drag reorder (persists category.order) */
let catDragCtx = null;
function makeCategoryRowSortable(rowEl){
  if (!rowEl) return;
  if (rowEl.querySelector('.dragHandle')) return;
  const handle = document.createElement('div');
  handle.className = 'dragHandle';
  handle.textContent = '‚ãÆ‚ãÆ';
  handle.title = 'Drag to reorder';
  rowEl.insertBefore(handle, rowEl.firstChild);

  rowEl.draggable = true;
  rowEl.classList.add('sortable');

  rowEl.addEventListener('dragstart', (e) => {
    catDragCtx = { el: rowEl };
    rowEl.classList.add('dragging');
    try { e.dataTransfer.effectAllowed = 'move'; } catch {}
  });
  rowEl.addEventListener('dragend', () => {
    rowEl.classList.remove('dragging');
    catDragCtx = null;
  });

  // Ensure dragging starts only from handle
  handle.addEventListener('pointerdown', (e) => {
    // no-op; presence of handle is the UX cue
  });
}

function initSortableCategoryList(listEl, sectionKey, onAfterReorder){
  if (!listEl) return;
  listEl.addEventListener('dragover', (e) => {
    if (!catDragCtx) return;
    e.preventDefault();
    const dragging = catDragCtx.el;
    if (!dragging) return;

    const afterEl = getDragAfterElement(listEl, e.clientY);
    if (afterEl == null) {
      listEl.appendChild(dragging);
    } else if (afterEl !== dragging) {
      listEl.insertBefore(dragging, afterEl);
    }
  });

  listEl.addEventListener('drop', async (e) => {
    if (!catDragCtx) return;
    e.preventDefault();
    await finalizeCategorySort(listEl, sectionKey);
    if (typeof onAfterReorder === 'function') onAfterReorder();
  });
}

async function finalizeCategorySort(listEl, sectionKey){
  const ids = [...listEl.querySelectorAll('.catItem.sortable[data-cat-id]')]
    .map(el => el.getAttribute('data-cat-id'))
    .filter(Boolean);

  if (!ids.length) return;

  const db = await openDB();
  if (!db.objectStoreNames.contains('setupCategories')) return;

  const cats = await getSetupCategories(sectionKey);
  const byId = new Map(cats.map(c => [c.id, c]));
  const now = nowISO();
  const tx = db.transaction('setupCategories', 'readwrite');
  const st = tx.objectStore('setupCategories');

  ids.forEach((id, i) => {
    const c = byId.get(id);
    if (!c) return;
    st.put({ ...c, order: (i+1)*1000, updatedAt: now });
  });
  await txComplete(tx);
}

/** Category manager modal */
async function openCategoryManager(sectionKey){
  const section = SETUP_SECTIONS.find(s => s.key === sectionKey);
  const label = section ? section.label : 'Categories';

  const wrap = document.createElement('div');
  wrap.className = 'modalBody';

  const headerRow = document.createElement('div');
  headerRow.className = 'row';
  headerRow.style.justifyContent = 'space-between';
  headerRow.style.alignItems = 'center';

  const hint = document.createElement('div');
  hint.className = 'muted';
  hint.textContent = 'Reorder categories, set default collapse, rename, or delete. Uncategorized is always available.';
  hint.style.flex = '1';

  const btnAdd = document.createElement('button');
  btnAdd.className = 'btn mini primary';
  btnAdd.textContent = 'Add Category';

  headerRow.appendChild(hint);
  headerRow.appendChild(btnAdd);
  wrap.appendChild(headerRow);

  wrap.appendChild(document.createElement('div')).className = 'divider';

  const list = document.createElement('div');
  list.className = 'list';
  wrap.appendChild(list);

  // Enable drag reorder for the category rows in this modal.
  initSortableCategoryList(list, sectionKey);

  const rerender = async () => {
    const cats = await getSetupCategories(sectionKey);
    list.innerHTML = '';

    // Uncategorized (non-editable)
    const unc = document.createElement('div');
    unc.className = 'item catItem catRowUnc';
    const uncMeta = document.createElement('div');
    uncMeta.className = 'meta';
    uncMeta.innerHTML = `<div class="name">Uncategorized</div><div class="small">Items with no category.</div>`;
    const uncActions = document.createElement('div');
    uncActions.className = 'actions';
    uncActions.innerHTML = `<span class="pill">Default</span>`;
    unc.appendChild(uncMeta);
    unc.appendChild(uncActions);
    list.appendChild(unc);

    cats.forEach(cat => {
      const row = document.createElement('div');
      row.className = 'item catItem';
      row.setAttribute('data-cat-id', cat.id);

      const titleWrap = document.createElement('div');
      titleWrap.className = 'catTitle';
      titleWrap.title = cat.title || '';
      titleWrap.textContent = cat.title || 'Untitled';

      const meta = document.createElement('div');
      meta.className = 'catMeta';

      const collapseLabel = document.createElement('label');
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!cat.isCollapsed;
      cb.addEventListener('change', async () => {
        await upsertSetupCategory({ ...cat, isCollapsed: cb.checked });
      });
      const span = document.createElement('span');
      span.textContent = 'Default collapsed';
      collapseLabel.appendChild(cb);
      collapseLabel.appendChild(span);

      meta.appendChild(collapseLabel);

      const actions = document.createElement('div');
      actions.className = 'actions';

      const btnRename = document.createElement('button');
      btnRename.className = 'btn mini';
      btnRename.textContent = 'Rename';

      const btnDelete = document.createElement('button');
      btnDelete.className = 'btn mini danger';
      btnDelete.textContent = 'Delete';

      const startInlineRename = () => {
        const input = document.createElement('input');
        input.value = cat.title || '';
        input.style.flex = '1';
        input.style.minWidth = '180px';

        // replace title
        row.replaceChild(input, titleWrap);

        actions.innerHTML = '';
        const bSave = document.createElement('button');
        bSave.className = 'btn mini primary';
        bSave.textContent = 'Save';
        const bCancel = document.createElement('button');
        bCancel.className = 'btn mini';
        bCancel.textContent = 'Cancel';

        const finish = async (save) => {
          if (save) {
            const v = (input.value || '').trim();
            if (!v) { toast('Title cannot be empty'); return; }
            await upsertSetupCategory({ ...cat, title: v });
          }
          await rerender();
        };

        bSave.addEventListener('click', () => finish(true));
        bCancel.addEventListener('click', () => finish(false));
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') finish(true);
          if (e.key === 'Escape') finish(false);
        });

        actions.appendChild(bCancel);
        actions.appendChild(bSave);

        // focus
        setTimeout(() => {
          input.focus();
          input.select();
        }, 0);
      };

      btnRename.addEventListener('click', (e) => {
        e.preventDefault();
        startInlineRename();
      });

      btnDelete.addEventListener('click', async (e) => {
        e.preventDefault();
        const ok = confirm(`Delete category "${cat.title || 'Untitled'}"?\n\nItems in this category will become Uncategorized.`);
        if (!ok) return;
        await deleteSetupCategory(sectionKey, cat.id);
        await rerender();
      });

      actions.appendChild(btnRename);
      actions.appendChild(btnDelete);

      row.appendChild(titleWrap);
      row.appendChild(meta);
      row.appendChild(actions);

      makeCategoryRowSortable(row);
      list.appendChild(row);
    });
  };

  btnAdd.addEventListener('click', async () => {
    const cats = await getSetupCategories(sectionKey);
    const maxOrder = (cats || []).reduce((m,c)=>Math.max(m, c.order || 0), 0);
    const now = nowISO();
    const cat = await upsertSetupCategory({
      id: uid(),
      sectionKey,
      title: 'New Category',
      order: maxOrder + 1000,
      isCollapsed: false,
      createdAt: now
    });
    await rerender();

    // Auto-enter rename for the new row
    const row = list.querySelector(`.catItem[data-cat-id="${cat.id}"]`);
    if (row) {
      const renameBtn = row.querySelector('.actions .btn');
      if (renameBtn) renameBtn.click();
    }
  });

  await rerender();

  openModal(`Manage Categories ¬∑ ${label}`, wrap, [
    btn('Close', { onClick: () => closeModal() })
  ]);
}
/** ========= Users ========= */
async function loadUsersIntoSelect() {
  const users = await getAll('users');
  users.sort((a,b) => (a.name || '').localeCompare(b.name || ''));

  const sel = $('#userSelect');
  sel.innerHTML = '';
  users.forEach(u => {
    const opt = document.createElement('option');
    opt.value = u.id;
    opt.textContent = u.name || '(Unnamed)';
    sel.appendChild(opt);
  });

  const remembered = localStorage.getItem('mivida_current_user_id');
  const pick = (remembered && users.some(u => u.id === remembered)) ? remembered : (users[0]?.id || null);
  state.currentUserId = pick;
  sel.value = pick;

  sel.onchange = async () => {
    state.currentUserId = sel.value;
    localStorage.setItem('mivida_current_user_id', state.currentUserId);
    await refreshAll();
  };
}
async function addUserFlow() {
  const name = prompt('User name?');
  if (!name) return;
  const t = nowISO();
  const row = { id: uid(), name: name.trim(), createdAt: t, updatedAt: t };
  await addOne('users', row);
  await logChange({ entityType: 'user', entityId: row.id, action: 'create', after: row });
  state.currentUserId = row.id;
  localStorage.setItem('mivida_current_user_id', row.id);
  await refreshAll();
}
async function renameUserFlow() {
  const userId = state.currentUserId;
  if (!userId) { alert('Select a user first.'); return; }
  const u = await getOne('users', userId);
  const name = prompt('New user name?', u?.name || '');
  if (!name) return;
  const before = u;
  const after = { ...u, name: name.trim(), updatedAt: nowISO() };
  await putOne('users', after);
  await logChange({ entityType: 'user', entityId: userId, action: 'update', after, before });
  await refreshAll();
}
async function deleteUserFlow() {
  const userId = state.currentUserId;
  if (!userId) { alert('Select a user first.'); return; }
  const u = await getOne('users', userId);
  const ok = confirm(`Delete user "${u?.name || ''}"?\nThis removes their Personal Info and selected career mapping.`);
  if (!ok) return;

  // delete per-user content rows (v3)
  const pc = await getByIndex('personalContent', 'by_userId', userId);
  for (const r of (pc || [])) {
    await deleteOne('personalContent', [r.userId, r.templateId]);
    await logChange({ entityType: 'personalContent', entityId: `${r.userId}:${r.templateId}`, action: 'delete', after: null, before: r });
  }

  // delete legacy per-user items too (if any exist from older versions)
  const personalsLegacy = await getByIndex('personalItems', 'by_userId', userId);
  for (const p of (personalsLegacy || [])) {
    await deleteOne('personalItems', p.id);
    await logChange({ entityType: 'personalItem', entityId: p.id, action: 'delete', after: null, before: p });
  }

  const uc = await getOne('userCareer', userId);
  if (uc) {
    await deleteOne('userCareer', userId);
    await logChange({ entityType: 'userCareer', entityId: userId, action: 'delete', after: null, before: uc });
  }

  await deleteOne('users', userId);
  await logChange({ entityType: 'user', entityId: userId, action: 'delete', after: null, before: u });

  localStorage.removeItem('mivida_current_user_id');
  state.currentUserId = null;
  await refreshAll();
}


async function setCurrentCareer(careerId) {
  state.currentCareerId = careerId || '';
  // Keep Prompt tab career in lockstep with Setup's current career
  state.promptCareerId = state.currentCareerId || '';

  try { localStorage.setItem('mivida_current_career_id', state.currentCareerId); } catch {}
  // Clear any legacy prompt-only override so it never diverges
  try { localStorage.removeItem('mivida_prompt_career_id'); } catch {}

  const sel = $('#careerFilter');
  if (sel) sel.value = state.currentCareerId;

  const pSel = $('#promptCurrentCareerSelect');
  if (pSel) pSel.value = state.currentCareerId;

  await renderCareerBlocks();

  // Keep Prompt tab in sync (safe even if the tab is currently hidden)
  try {
    await renderPromptPickers();
    await renderPromptPage();
  } catch (e) { /* ignore */ }
}

async function addCareerFlow() {
  const title = prompt('Career name?');
  if (!title) return;
  const t = nowISO();
  const row = { id: uid(), title: title.trim(), createdAt: t, updatedAt: t };
  await addOne('careers', row);
  await logChange({ entityType: 'career', entityId: row.id, action: 'create', after: row });

  // refresh the top career dropdown options, then select the new one
  await loadCareerFilterSelect();
  await setCurrentCareer(row.id);

  await renderPersonalCareerPick(); // so user career dropdown includes the new career
}

async function renameCareerFlow() {
  const careerId = state.currentCareerId;
  if (!careerId) { alert('Select a career first.'); return; }
  const c = await getOne('careers', careerId);
  const name = prompt('New career name?', c?.title || '');
  if (!name) return;

  const before = c;
  const after = { ...c, title: name.trim(), updatedAt: nowISO() };
  await putOne('careers', after);
  await logChange({ entityType: 'career', entityId: careerId, action: 'update', after, before });

  await refreshAll();
}

async function deleteCareerFlow() {
  const careerId = state.currentCareerId;
  if (!careerId) { alert('Select a career first.'); return; }
  const c = await getOne('careers', careerId);
  const ok = confirm(`Delete career "${c?.title || ''}"?\nThis will also delete all its career items and remove it from any users.`);
  if (!ok) return;

  await deleteCareer(c);

  // pick next available career (if any)
  const careers = await getAll('careers');
  careers.sort((a,b) => (a.title || '').localeCompare(b.title || ''));
  const next = careers[0]?.id || '';
  await setCurrentCareer(next);
  await renderPersonalCareerPick();
}

/** ========= Career (Edit only) ========= */
async function loadCareerFilterSelect() {
  const careers = await getAll('careers');
  careers.sort((a,b) => (a.title || '').localeCompare(b.title || ''));

  const sel = $('#careerFilter');
  sel.innerHTML = '';

  const optNone = document.createElement('option');
  optNone.value = '';
  optNone.textContent = '(Choose a career)';
  sel.appendChild(optNone);

  careers.forEach(c => {
    const opt = document.createElement('option');
    opt.value = c.id;
    opt.textContent = c.title || '(Career)';
    sel.appendChild(opt);
  });

  const remembered = localStorage.getItem('mivida_current_career_id');
  const pick = (remembered && careers.some(c => c.id === remembered)) ? remembered : (careers[0]?.id || '');
  state.currentCareerId = pick || '';
  sel.value = state.currentCareerId;

  sel.onchange = async () => {
    await setCurrentCareer(sel.value || '');
  };
}


/** ========= Output assignment helpers ========= */
async function getOutputAssignments() {
  // Map: connectionId -> { key: templateId, store: 'personalTemplates'|'careerTemplates', title }
  const [pTemps, cTemps] = await Promise.all([getAll('personalTemplates'), getAll('careerTemplates')]);
  const out = Object.create(null);

  (pTemps || []).forEach(t => {
    const cid = (t.outputConnectionId || '');
    if (cid && (t.isOutput !== false) && !out[cid]) {
      out[cid] = { key: t.id, store: 'personalTemplates', title: t.title || '(Personal Item)' };
    }
  });

  (cTemps || []).forEach(t => {
    const cid = (t.outputConnectionId || '');
    if (cid && (t.isOutput !== false) && !out[cid]) {
      out[cid] = { key: t.id, store: 'careerTemplates', title: t.title || '(Career Item)' };
    }
  });

  return out;
}

async function enforceSingleOutputPerConnection({ currentKey, connId }) {
  // Returns: { ok: boolean, conflict?: { store, row, title }, connTitle?: string }
  if (!connId) return { ok: true };

  const [pTemps, cTemps, connRow] = await Promise.all([
    getAll('personalTemplates'),
    getAll('careerTemplates'),
    getOne('connections', connId)
  ]);

  const connTitle = connRow?.title || 'this connection';

  // Find any other output item already bound to this connection
  const pHit = (pTemps || []).find(t => (t.isOutput !== false) && (t.outputConnectionId || '') === connId && t.id !== currentKey);
  if (pHit) return { ok: false, conflict: { store: 'personalTemplates', row: pHit, title: pHit.title || '(Personal Item)' }, connTitle };

  const cHit = (cTemps || []).find(t => (t.isOutput !== false) && (t.outputConnectionId || '') === connId && t.id !== currentKey);
  if (cHit) return { ok: false, conflict: { store: 'careerTemplates', row: cHit, title: cHit.title || '(Career Item)' }, connTitle };

  return { ok: true };
}

async function clearOutputLink(conflictRow, storeName) {
  const t = nowISO();
  const before = await getOne(storeName, conflictRow.id);
  const after = { ...before, isOutput: false, outputConnectionId: '', updatedAt: t };
  await putOne(storeName, after);
  await logChange({ entityType: storeName === 'personalTemplates' ? 'personalTemplate' : 'careerTemplate', entityId: after.id, action: 'update', after, before });
  return after;
}

/** ========= Generic Item Modal (Edit only) ========= */
function openEditItemModal({ title, initial, onSave, onDelete, previewLabel='Preview (rendered markdown)', outputMeta=null, contentOnly=false }) {
  const container = document.createElement('div');
  container.className = 'split';

  const left = document.createElement('div');
  const right = document.createElement('div');

  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.placeholder = 'Title';
  titleInput.value = initial?.title || '';

  if (contentOnly) {
    titleInput.readOnly = true;
    titleInput.classList.add('readOnly');
  }

  left.appendChild(inputRow('Title', titleInput));

  // Optional: Output config (only for Personal/Career items)
  let outputCb = null;
  let outputSel = null;

  if (outputMeta) {
    const outWrap = document.createElement('div');
    outWrap.className = 'outConfig';

    outputCb = document.createElement('input');
    outputCb.type = 'checkbox';
    // Default: output is ON unless explicitly set to false
    outputCb.checked = (initial?.isOutput !== false);

    const outLbl = document.createElement('span');
    outLbl.className = 'muted';
    outLbl.style.userSelect = 'none';
    outLbl.textContent = 'Mark as output';

    outputSel = document.createElement('select');
    outputSel.style.minWidth = '240px';
    outputSel.style.display = outputCb.checked ? '' : 'none';

    function setOptions(conns, assignments) {
      outputSel.innerHTML = '';

      const opAny = document.createElement('option');
      opAny.value = '';
      opAny.textContent = 'All connections';
      outputSel.appendChild(opAny);

      const myKey = (initial?.templateId || initial?.id || '');

      (conns || []).forEach(c => {
        const op = document.createElement('option');
        op.value = c.id;
        op.textContent = c.title || '(Untitled)';

        // If this connection is already used as an output by another item, tint it.
        const used = assignments && assignments[c.id] && (assignments[c.id].key !== myKey);
        if (used) {
          op.style.color = '#b42318';      // muted red
          op.style.fontWeight = '600';
        }

        outputSel.appendChild(op);
      });

      const current = (initial?.outputConnectionId || '');
      if (current && !Array.from(outputSel.options).some(o => o.value === current)) {
        const op = document.createElement('option');
        op.value = current;
        op.textContent = '(Missing connection)';
        outputSel.appendChild(op);
      }
      outputSel.value = current;
    }

    // Initial populate
    if (Array.isArray(outputMeta.connections)) {
      setOptions(outputMeta.connections, outputMeta.assignments || null);
    } else {
      setOptions([], outputMeta.assignments || null);
      (async () => {
        try {
          let conns = await getAll('connections');
          conns = applyUiOrder(conns, 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
          setOptions(conns, outputMeta.assignments || null);
        } catch(e) { /* ignore */ }
      })();
    }

    outputCb.addEventListener('change', () => {
      outputSel.style.display = outputCb.checked ? '' : 'none';
    });

    outWrap.appendChild(outputCb);
    outWrap.appendChild(outLbl);
    outWrap.appendChild(outputSel);

    left.appendChild(inputRow('Output', outWrap));
  }

  left.appendChild(document.createElement('div')).className = 'divider';

  const content = document.createElement('textarea');
  content.placeholder = 'Markdown content...';
  content.value = initial?.content || '';

  const preview = document.createElement('div');
  preview.className = 'mdPreview';
  preview.innerHTML = renderMarkdown(content.value);

  content.addEventListener('input', () => {
    preview.innerHTML = renderMarkdown(content.value);
  });


  // Content (label on its own line for better readability)
  const contentBlock = document.createElement('div');
  contentBlock.className = 'fieldBlock';

  const contentLabel = document.createElement('div');
  contentLabel.className = 'formLabel';
  contentLabel.textContent = 'Content';

  contentBlock.appendChild(contentLabel);
  contentBlock.appendChild(content);

  left.appendChild(contentBlock);

  const label = document.createElement('div');
  label.className = 'muted';
  label.textContent = previewLabel;

  right.appendChild(label);
  right.appendChild(document.createElement('div')).className = 'divider';
  right.appendChild(preview);

  container.appendChild(left);
  container.appendChild(right);

  const footerButtons = [
    btn('Save', {
      primary: true,
      onClick: async () => {
        const payload = {
          ...initial,
          title: (contentOnly ? (initial?.title || '') : titleInput.value.trim()),
          content: content.value
        };
        if (outputCb && outputSel) {
          payload.isOutput = !!outputCb.checked;
          payload.outputConnectionId = (outputSel.value || '');
        }
        const _ok = await onSave(payload);
        if (_ok === false) return;
        closeModal();
      }
    }),
    // Cancel sits at the far-right of the footer to reduce mis-click risk.
    btn('Cancel', { ghost: true, onClick: closeModal })
  ];

  const headerButtons = [];
  // Delete sits next to the modal title (header actions) to reduce mis-click risk.
  if (!contentOnly && (initial?.id || initial?.templateId)) {
    headerButtons.push(btn('Delete', {
      mini: true,
      danger: true,
      onClick: async () => {
        const ok = confirm('Delete this item?');
        if (!ok) return;
        await onDelete(initial);
        closeModal();
      }
    }));
  }

  openModal(title, container, footerButtons, headerButtons);
}

/** ========= Prompts ========= */
async function renderPrompts() {
  const list = $('#listPrompts');
  const hint = $('#hintPrompts');
  list.innerHTML = '';

  const itemsRaw = await getAll('promptItems');
  const items = Array.isArray(itemsRaw) ? itemsRaw : [];
  const cats = await getSetupCategories('promptItems');

  renderCategoryGroups({
    listEl: list,
    hintEl: hint,
    sectionKey: 'promptItems',
    categories: cats,
    items,
    sortKey: 'promptItems',
    emptyHintText: 'No prompt items in this category.',
    makeRow: (it) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.dataset.id = it.id;

      const left = document.createElement('div');
      left.className = 'row-left';

      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = it.title || '(Untitled)';

      const subtitle = document.createElement('div');
      subtitle.className = 'muted';
      const updated = it.updatedAt || it.createdAt || '';
      subtitle.textContent = updated ? `Updated: ${fmtLocalShort(updated)}` : '';

      const small = document.createElement('div');
      small.className = 'small';
      const preview = String(it.content || '').replace(/\s+/g, ' ').trim();
      small.textContent = preview ? preview.slice(0, 160) + (preview.length > 160 ? '‚Ä¶' : '') : '‚Äî';

      left.appendChild(title);
      if (subtitle.textContent) left.appendChild(subtitle);
      left.appendChild(small);

      const right = document.createElement('div');
      right.className = 'row-actions';

      const editBtn = document.createElement('button');
      editBtn.className = 'btn small';
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openEditItemModal({
        title: 'Edit ¬∑ Prompt Item',
        initial: it,
        onSave: savePromptItem,
        onDelete: deletePromptItem
      });

      right.appendChild(editBtn);

      row.appendChild(left);
      row.appendChild(right);
      return row;
    }
  });
}

async function savePromptItem(payload) {
  const t = nowISO();
  if (!payload.id) {
    const row = {
      id: uid(),
      title: payload.title || '',
      content: payload.content || '',
      categoryId: (typeof payload.categoryId === 'string') ? payload.categoryId : '',
      sortOrder: (typeof payload.sortOrder === 'number') ? payload.sortOrder : Date.now(),
      createdAt: t,
      updatedAt: t
    };
    await addOne('promptItems', row);
    await logChange({ entityType: 'promptItem', entityId: row.id, action: 'create', after: row });
  } else {
    const before = await getOne('promptItems', payload.id);
    const after = {
      ...before,
      title: payload.title || '',
      content: payload.content || '',
      categoryId: (typeof payload.categoryId === 'string') ? payload.categoryId : (before?.categoryId || ''),
      sortOrder: (typeof payload.sortOrder === 'number') ? payload.sortOrder : (typeof before?.sortOrder === 'number' ? before.sortOrder : Date.now()),
      updatedAt: t
    };
    await putOne('promptItems', after);
    await logChange({ entityType: 'promptItem', entityId: after.id, action: 'update', after, before });
  }
  await refreshAll();
}

async function deletePromptItem(it) {
  const before = await getOne('promptItems', it.id);
  await deleteOne('promptItems', it.id);
  await logChange({ entityType: 'promptItem', entityId: it.id, action: 'delete', after: null, before });
  await refreshAll();
}

/** ========= Personal ========= */

async function renderPersonal() {
  const userId = state.currentUserId;
  const list = $('#listPersonal');
  const hint = $('#hintPersonal');
  list.innerHTML = '';

  const addBtn = $('#btnAddPersonal');
  if (!userId) {
    if (addBtn) addBtn.disabled = true;
    if (hint) {
      hint.style.display = 'block';
      hint.textContent = 'Select a user to edit personal info items.';
    }
    return;
  }

  if (addBtn) addBtn.disabled = false;

  let [templatesRaw, contents, conns] = await Promise.all([
    getAll('personalTemplates'),
    getByIndex('personalContent', 'by_userId', userId),
    getAll('connections')
  ]);

  const templates = Array.isArray(templatesRaw) ? templatesRaw : [];
  const cMap = new Map((contents || []).map(c => [c.templateId, c]));

  conns = Array.isArray(conns) ? conns : [];
  const connById = new Map(conns.map(c => [c.id, c]));

  const outputConnTitleFor = (tpl) => {
    const ocid = String(tpl?.outputConnectionId || '');
    if (!ocid) return '';
    const conn = connById.get(ocid);
    return (conn && conn.title) ? String(conn.title) : (tpl.outputConnectionTitle ? String(tpl.outputConnectionTitle) : '');
  };

  const cats = await getSetupCategories('personalTemplates');

  renderCategoryGroups({
    listEl: list,
    hintEl: hint,
    sectionKey: 'personalTemplates',
    categories: cats,
    items: templates,
    sortKey: 'personalTemplates',
    emptyHintText: 'No items in this category.',
    makeRow: (tpl) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.dataset.id = tpl.id;

      const left = document.createElement('div');
      left.className = 'row-left';

      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = tpl.title || '(Untitled)';

      const pills = document.createElement('div');
      pills.style.display = 'flex';
      pills.style.flexWrap = 'wrap';
      pills.style.gap = '6px';
      pills.style.marginTop = '6px';

      if (tpl.isOutput !== false) {
        const p = document.createElement('span');
        p.className = 'pill';
        p.textContent = 'Output';
        pills.appendChild(p);

        const ct = outputConnTitleFor(tpl);
        if (ct) {
          const p2 = document.createElement('span');
          p2.className = 'pill';
          p2.textContent = `For: ${ct}`;
          pills.appendChild(p2);
        }
      }

      const subtitle = document.createElement('div');
      subtitle.className = 'muted';

      const c = cMap.get(tpl.id);
      const updated = (c?.updatedAt || tpl.updatedAt || tpl.createdAt || '');
      subtitle.textContent = updated ? `Updated: ${fmtLocalShort(updated)}` : '';

      const small = document.createElement('div');
      small.className = 'small';
      const preview = (c?.content || '').replace(/\s+/g, ' ').trim();
      small.textContent = preview ? preview.slice(0, 160) + (preview.length > 160 ? '‚Ä¶' : '') : '‚Äî';

      left.appendChild(title);
      if (pills.childNodes.length) left.appendChild(pills);
      if (subtitle.textContent) left.appendChild(subtitle);
      left.appendChild(small);

      const right = document.createElement('div');
      right.className = 'row-actions';

      const editBtn = document.createElement('button');
      editBtn.className = 'btn small';
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openEditItemModal({
        title: 'Edit ¬∑ Personal Info Item',
        initial: {
          templateId: tpl.id,
          title: tpl.title || '',
          content: c?.content || '',
          isOutput: (tpl.isOutput !== false),
          outputConnectionId: (tpl.outputConnectionId || '')
        },
        outputMeta: { connections: conns },
        onSave: savePersonalTemplateAndContent,
        onDelete: deletePersonalTemplate
      });

      const delBtn = document.createElement('button');
      delBtn.className = 'btn small danger';
      delBtn.textContent = 'Delete';
      delBtn.onclick = async () => {
        if (!confirm('Delete this personal info title and all user contents using it?')) return;
        await deletePersonalTemplate({ templateId: tpl.id });
      };

      right.appendChild(editBtn);
      right.appendChild(delBtn);

      row.appendChild(left);
      row.appendChild(right);
      return row;
    }
  });
}

async function renderCareerBlocks() {
  const list = $('#listCareerBlocks');
  const hint = $('#hintCareerBlocks');
  list.innerHTML = '';

  const careerId = state.currentCareerId || '';
  const addBtn = $('#btnAddCareerBlock');

  if (!careerId) {
    if (addBtn) addBtn.disabled = true;
    if (hint) {
      hint.style.display = 'block';
      hint.textContent = 'Select a career to edit career items.';
    }
    return;
  }

  if (addBtn) addBtn.disabled = false;

  let [templatesRaw, contents, conns] = await Promise.all([
    getAll('careerTemplates'),
    getByIndex('careerContent', 'by_careerId', careerId),
    getAll('connections')
  ]);

  const templates = Array.isArray(templatesRaw) ? templatesRaw : [];
  const contentByTpl = new Map((contents || []).map(r => [r.templateId, r]));

  conns = Array.isArray(conns) ? conns : [];
  const connById = new Map(conns.map(c => [c.id, c]));

  const outputConnTitleFor = (tpl) => {
    const ocid = String(tpl?.outputConnectionId || '');
    if (!ocid) return '';
    const conn = connById.get(ocid);
    return (conn && conn.title) ? String(conn.title) : (tpl.outputConnectionTitle ? String(tpl.outputConnectionTitle) : '');
  };

  const cats = await getSetupCategories('careerTemplates');

  renderCategoryGroups({
    listEl: list,
    hintEl: hint,
    sectionKey: 'careerTemplates',
    categories: cats,
    items: templates,
    sortKey: 'careerTemplates',
    emptyHintText: 'No items in this category.',
    makeRow: (tpl) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.dataset.id = tpl.id;

      const left = document.createElement('div');
      left.className = 'row-left';

      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = tpl.title || '(Untitled)';

      const pills = document.createElement('div');
      pills.style.display = 'flex';
      pills.style.flexWrap = 'wrap';
      pills.style.gap = '6px';
      pills.style.marginTop = '6px';

      if (tpl.isOutput !== false) {
        const p = document.createElement('span');
        p.className = 'pill';
        p.textContent = 'Output';
        pills.appendChild(p);

        const ct = outputConnTitleFor(tpl);
        if (ct) {
          const p2 = document.createElement('span');
          p2.className = 'pill';
          p2.textContent = `For: ${ct}`;
          pills.appendChild(p2);
        }
      }

      const subtitle = document.createElement('div');
      subtitle.className = 'muted';

      const contentRow = contentByTpl.get(tpl.id);
      const updated = (contentRow?.updatedAt || tpl.updatedAt || tpl.createdAt || '');
      subtitle.textContent = updated ? `Updated: ${fmtLocalShort(updated)}` : '';

      const small = document.createElement('div');
      small.className = 'small';
      const preview = (contentRow?.content || '').replace(/\s+/g, ' ').trim();
      small.textContent = preview ? preview.slice(0, 160) + (preview.length > 160 ? '‚Ä¶' : '') : '‚Äî';

      left.appendChild(title);
      if (pills.childNodes.length) left.appendChild(pills);
      if (subtitle.textContent) left.appendChild(subtitle);
      left.appendChild(small);

      const right = document.createElement('div');
      right.className = 'row-actions';

      const editBtn = document.createElement('button');
      editBtn.className = 'btn small';
      editBtn.textContent = 'Edit';
      editBtn.onclick = () => openEditItemModal({
        title: 'Edit ¬∑ Career Info Item',
        initial: {
          templateId: tpl.id,
          title: tpl.title || '',
          content: contentRow?.content || '',
          isOutput: (tpl.isOutput !== false),
          outputConnectionId: (tpl.outputConnectionId || '')
        },
        outputMeta: { connections: conns },
        onSave: saveCareerTemplateAndContentByFilter,
        onDelete: deleteCareerTemplate
      });

      const delBtn = document.createElement('button');
      delBtn.className = 'btn small danger';
      delBtn.textContent = 'Delete';
      delBtn.onclick = async () => {
        if (!confirm('Delete this career item title and all career contents using it?')) return;
        await deleteCareerTemplate({ templateId: tpl.id });
      };

      right.appendChild(editBtn);
      right.appendChild(delBtn);

      row.appendChild(left);
      row.appendChild(right);
      return row;
    }
  });
}

async function saveCareerTemplateAndContentByFilter(payload) {
  const careerId = state.currentCareerId || null;
  if (!careerId) { alert('Select a career first.'); return; }

  const t = nowISO();

  // Enforce: one output item per connection (across Personal + Career items).
  if (payload.isOutput && (payload.outputConnectionId || '')) {
    const currentKey = (payload.templateId || payload.id || '');
    const connId = (payload.outputConnectionId || '');
    const check = await enforceSingleOutputPerConnection({ currentKey, connId });
    if (!check.ok && check.conflict) {
      const msg =
        `This connection is already used as the output for ‚Äú${check.conflict.title}‚Äù.\n\n` +
        `If you continue, the previous item‚Äôs output link will be cleared, and this item will become the output for ‚Äú${check.connTitle}‚Äù.\n\n` +
        `Do you want to continue?`;
      const ok = confirm(msg);
      if (!ok) return false;

      // Clear the previous item's output relationship
      await clearOutputLink(check.conflict.row, check.conflict.store);
    }
  }

  const templateId = payload.templateId || payload.id || uid();

  const beforeTpl = await getOne('careerTemplates', templateId);
  const beforeContent = await getOne('careerContent', [careerId, templateId]);

  const tpl = {
    id: templateId,
    title: (payload.title || '').trim(),
    isOutput: (payload.isOutput !== undefined ? payload.isOutput : (beforeTpl?.isOutput ?? true)),
    outputConnectionId: (payload.outputConnectionId !== undefined ? (payload.outputConnectionId || '') : (beforeTpl?.outputConnectionId || '')),
    outputMode: (beforeTpl?.outputMode || 'section'),
    createdAt: beforeTpl?.createdAt || payload.createdAt || t,
    updatedAt: t
  };
  await putOne('careerTemplates', tpl);

  const contentRow = {
    careerId,
    templateId,
    content: payload.content || '',
    createdAt: beforeContent?.createdAt || payload.createdAt || t,
    updatedAt: t
  };
  await putOne('careerContent', contentRow);

  await logChange({
    entityType: 'careerTemplate',
    entityId: templateId,
    action: beforeTpl ? 'update' : 'create',
    after: tpl,
    before: beforeTpl || null
  });
  await logChange({
    entityType: 'careerContent',
    entityId: `${careerId}:${templateId}`,
    action: beforeContent ? 'update' : 'create',
    after: contentRow,
    before: beforeContent || null
  });

  await renderCareerBlocks();
  await renderPromptPage();
}

async function deleteCareerTemplate(payload) {
  const templateId = payload.templateId || payload.id;
  if (!templateId) return;

  const before = await getOne('careerTemplates', templateId);
  await deleteOne('careerTemplates', templateId);

  const all = await getByIndex('careerContent', 'by_templateId', templateId);
  for (const r of all) {
    await deleteOne('careerContent', [r.careerId, r.templateId]);
  }

  await logChange({
    entityType: 'careerTemplate',
    entityId: templateId,
    action: 'delete',
    after: null,
    before: before || null
  });

  await renderCareerBlocks();
  await renderPromptPage();
}


/** ========= Connections (Global) ========= */
async function compileForUserWithConnection(conn, ctx='setup') {
  const userId = state.currentUserId;

  const promptIds = conn?.promptItemIds || [];
  const personalIds = conn?.personalTemplateIds || [];
  const careerIds = conn?.careerTemplateIds || [];

  const parts = [];

  // Prompt items (global)
  if (promptIds.length) {
    const allPrompts = await getAll('promptItems');
    const pMap = new Map(allPrompts.map(p => [p.id, p]));
    promptIds.forEach(id => {
      const p = pMap.get(id);
      if (!p) return;
      const body = (p.content || '').trim() ? `
${p.content}` : '';
      parts.push(`## ${p.title}${body}`);
    });
  }

  // Personal info (titles are shared, content is per-user)
  if (personalIds.length) {
    const templates = await getAll('personalTemplates');
    const tMap = new Map((templates || []).map(t => [t.id, t]));
    let cMap = new Map();

    if (userId) {
      const contents = await getByIndex('personalContent', 'by_userId', userId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    personalIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = userId ? (cMap.get(tid)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;
      const body = hasBody ? `
${content}` : '';
      parts.push(`## ${tpl.title}${body}`);
    });
  }

  // Career info (titles are shared, content is per-career)
  if (careerIds.length) {
    const templates = await getAll('careerTemplates');
    const tMap = new Map((templates || []).map(t => [t.id, t]));

    let careerId = null;
    let cMap = new Map();

    // Determine which career to compile with
    const source = (conn?.careerSource || 'user');
    if (source === 'current') {
      careerId = state.currentCareerId || null;
    } else if (userId) {
      const uc = await getOne('userCareer', userId);
      careerId = uc?.careerId || null;
    }

    if (careerId) {
      const contents = await getByIndex('careerContent', 'by_careerId', careerId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    careerIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = careerId ? (cMap.get(tid)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;
      const body = hasBody ? `
${content}` : '';
      parts.push(`## ${tpl.title}${body}`);
    });
  }

  return parts.join('\n\n').trim();
}


async function compileExplicitOutputForUserWithConnection(conn, ctx='setup') {
  const userId = state.currentUserId;
  const out = [];
  const connId = conn?.id || '';
  if (!connId) return '';

  // Personal explicit outputs (tied to this connection; independent of whether the item is included in the connection pick-list)
  try {
    let [templates, contents] = await Promise.all([
      getAll('personalTemplates'),
      userId ? getByIndex('personalContent', 'by_userId', userId) : Promise.resolve([])
    ]);
    templates = applyUiOrder(templates || [], 'personalTemplates', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));
    const cMap = new Map((contents || []).map(c => [c.templateId, c]));

    (templates || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      const oc = (tpl.outputConnectionId || '');
      if (oc !== connId) return;

      const mode = (tpl.outputMode || 'section');
      const content = userId ? (cMap.get(tpl.id)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;

      if (mode === 'content') {
        if (hasBody) out.push(String(content).trim());
        return;
      }
      if (mode === 'title') {
        out.push(`## ${tpl.title}`);
        return;
      }
      out.push(`## ${tpl.title}`);
      if (hasBody) out.push(content);
    });
  } catch(e) { /* ignore */ }

  // Career explicit outputs (tied to this connection; independent of whether the item is included in the connection pick-list)
  try {
    let templates = await getAll('careerTemplates');
    templates = applyUiOrder(templates || [], 'careerTemplates', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));

    let careerId = null;

    const source = (conn?.careerSource || 'user');
    if (source === 'current') {
      careerId = state.currentCareerId || null;
    } else if (userId) {
      const uc = await getOne('userCareer', userId);
      careerId = uc?.careerId || null;
    }

    let cMap = new Map();
    if (careerId) {
      const contents = await getByIndex('careerContent', 'by_careerId', careerId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    (templates || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      const oc = (tpl.outputConnectionId || '');
      if (oc !== connId) return;

      const mode = (tpl.outputMode || 'section');
      const content = careerId ? (cMap.get(tpl.id)?.content || '') : '';
      const hasBody = String(content).trim().length > 0;

      if (mode === 'content') {
        if (hasBody) out.push(String(content).trim());
        return;
      }
      if (mode === 'title') {
        out.push(`## ${tpl.title}`);
        return;
      }
      out.push(`## ${tpl.title}`);
      if (hasBody) out.push(content);
    });
  } catch(e) { /* ignore */ }

  return out.join('\n\n').trim();
}

async function openOutputModal(conn) {
  const outText = await compileExplicitOutputForUserWithConnection(conn, 'prompt');

  const preview = document.createElement('div');
  preview.className = 'mdPreview outputReader';
  preview.innerHTML = renderMarkdown(outText || '');

  const headerButtons = [
    btn('Copy', { mini:true, onClick: async () => {
      await navigator.clipboard.writeText(outText || '');
      toast('Copied to clipboard');
    }})
  ];

  openModal(`Output ¬∑ ${conn?.title || '(Untitled Connection)'}`, preview, [], headerButtons);
}

async function openPromptModal(conn) {
  const text = await compileForUserWithConnection(conn, 'prompt');

  const preview = document.createElement('div');
  preview.className = 'mdPreview outputReader';
  preview.innerHTML = renderMarkdown(text || '');

  const headerButtons = [
    btn('Copy', { mini:true, onClick: async () => {
      await navigator.clipboard.writeText(text || '');
      toast('Copied to clipboard');
    }})
  ];

  openModal(`Prompt ¬∑ ${conn?.title || '(Untitled Connection)'}`, preview, [], headerButtons);
}


async function analyzeConnectionForCurrentUser(conn, ctx='setup') {
  const userId = state.currentUserId;

  const emptyPersonal = [];
  const emptyCareer = [];
  let missingCareer = false;
  let explicitOutputCount = 0;

  const personalIds = conn?.personalTemplateIds || [];
  const careerIds = conn?.careerTemplateIds || [];

  // Count explicit outputs (independent of whether the item is included in the connection pick-list)
  try {
    const [pTemps, cTemps] = await Promise.all([getAll('personalTemplates'), getAll('careerTemplates')]);
    (pTemps || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      if ((tpl.outputConnectionId || '') === (conn?.id || '')) explicitOutputCount += 1;
    });
    (cTemps || []).forEach(tpl => {
      if (!tpl) return;
      if (tpl.isOutput === false) return;
      if ((tpl.outputConnectionId || '') === (conn?.id || '')) explicitOutputCount += 1;
    });
  } catch(e) { /* ignore */ }

  // Personal empties based on connection selection (content may be empty, but we still warn)
  if (personalIds.length) {
    const [templates, contents] = await Promise.all([
      getAll('personalTemplates'),
      userId ? getByIndex('personalContent', 'by_userId', userId) : Promise.resolve([])
    ]);
    const tMap = new Map((templates || []).map(t => [t.id, t]));
    const cMap = new Map((contents || []).map(c => [c.templateId, c]));

    personalIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = userId ? (cMap.get(tid)?.content || '') : '';
      if (!String(content).trim()) emptyPersonal.push(tpl.title);
    });
  }

  // Resolve career for this compile context (used for missingCareer + emptyCareer)
  let careerId = null;
  if (careerIds.length) {
    const source = (conn?.careerSource || 'user');
    if (source === 'current') {
      careerId = state.currentCareerId || null;
    } else if (userId) {
      const uc = await getOne('userCareer', userId);
      careerId = uc?.careerId || null;
    }
    if (!careerId) missingCareer = true;
  }

  if (careerIds.length) {
    const templates = await getAll('careerTemplates');
    const tMap = new Map((templates || []).map(t => [t.id, t]));

    let cMap = new Map();
    if (careerId) {
      const contents = await getByIndex('careerContent', 'by_careerId', careerId);
      cMap = new Map((contents || []).map(c => [c.templateId, c]));
    }

    careerIds.forEach(tid => {
      const tpl = tMap.get(tid);
      if (!tpl) return;
      const content = careerId ? (cMap.get(tid)?.content || '') : '';
      if (!String(content).trim()) emptyCareer.push(tpl.title);
    });
  }

  const compiled = await compileForUserWithConnection(conn, ctx);
  return { compiled, emptyPersonal, emptyCareer, missingCareer, hasExplicitOutput: (explicitOutputCount > 0) };
}



async function renderConnections() {
  const list = $('#listConnections');
  const hint = $('#hintConnections');
  list.innerHTML = '';

  const connsRaw = await getAll('connections');
  const conns = Array.isArray(connsRaw) ? connsRaw : [];

  const promptItems = await getAll('promptItems');
  const pBy = new Map((promptItems || []).map(p => [p.id, p]));

  const pt = await getAll('personalTemplates');
  const ct = await getAll('careerTemplates');
  const ptBy = new Map((pt || []).map(t => [t.id, t]));
  const ctBy = new Map((ct || []).map(t => [t.id, t]));

  const cats = await getSetupCategories('connections');

  renderCategoryGroups({
    listEl: list,
    hintEl: hint,
    sectionKey: 'connections',
    categories: cats,
    items: conns,
    sortKey: 'connections',
    emptyHintText: 'No connections in this category.',
    makeRow: (c) => {
      const row = document.createElement('div');
      row.className = 'row';
      row.dataset.id = c.id;

      const left = document.createElement('div');
      left.className = 'row-left';

      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = c.title || '(Untitled)';

      const subtitle = document.createElement('div');
      subtitle.className = 'muted';

      const pCount = (c.promptItemIds || []).length;
      const ptCount = (c.personalTemplateIds || []).length;
      const ctCount = (c.careerTemplateIds || []).length;

      const careerMode = c.careerSource === 'global' ? 'Global' : 'Per-career';
      subtitle.textContent = `${careerMode} ‚Ä¢ Prompts: ${pCount} ‚Ä¢ Personal: ${ptCount} ‚Ä¢ Career: ${ctCount}`;

      const small = document.createElement('div');
      small.className = 'small';

      // Show a short readable preview of the linked titles (first few)
      const pickTitles = (ids, byMap) => (ids || [])
        .map(id => byMap.get(id)?.title || byMap.get(id)?.name || '')
        .filter(Boolean)
        .slice(0, 4);

      const pTitles = pickTitles(c.promptItemIds, pBy);
      const ptTitles = pickTitles(c.personalTemplateIds, ptBy);
      const ctTitles = pickTitles(c.careerTemplateIds, ctBy);

      const parts = [];
      if (pTitles.length) parts.push(`Prompts: ${pTitles.join(', ')}${pCount > 4 ? ', ‚Ä¶' : ''}`);
      if (ptTitles.length) parts.push(`Personal: ${ptTitles.join(', ')}${ptCount > 4 ? ', ‚Ä¶' : ''}`);
      if (ctTitles.length) parts.push(`Career: ${ctTitles.join(', ')}${ctCount > 4 ? ', ‚Ä¶' : ''}`);
      small.textContent = parts.length ? parts.join('  |  ') : '‚Äî';

      left.appendChild(title);
      left.appendChild(subtitle);
      left.appendChild(small);

      const right = document.createElement('div');
      right.className = 'row-actions';

      const editBtn = document.createElement('button');
      editBtn.className = 'btn small';
      editBtn.textContent = 'Edit';
      editBtn.onclick = async () => openConnectionModal({ mode:'edit', id: c.id });

      const delBtn = document.createElement('button');
      delBtn.className = 'btn small danger';
      delBtn.textContent = 'Delete';
      delBtn.onclick = async () => {
        if (!confirm('Delete this connection?')) return;
        await deleteConnection({ id: c.id });
      };

      right.appendChild(editBtn);
      right.appendChild(delBtn);

      row.appendChild(left);
      row.appendChild(right);
      return row;
    }
  });
}

async function renderPromptPickers() {
  const uSel = $('#promptUserSelect');
  const ucSel = $('#promptUserCareerSelect');
  const ccSel = $('#promptCurrentCareerSelect');
  if (!uSel || !ucSel || !ccSel) return;

  // Users
  let users = await getAll('users');
  users.sort((a,b) => (a.name || '').localeCompare(b.name || ''));

  uSel.innerHTML = '';
  if (!users.length) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(No users)';
    uSel.appendChild(opt);
    state.currentUserId = '';
    uSel.value = '';
  } else {
    users.forEach(u => {
      const opt = document.createElement('option');
      opt.value = u.id;
      opt.textContent = u.name || '(User)';
      uSel.appendChild(opt);
    });

    const remembered = (() => { try { return localStorage.getItem('mivida_current_user_id'); } catch { return ''; } })();
    const pick = (state.currentUserId && users.some(x => x.id === state.currentUserId))
      ? state.currentUserId
      : ((remembered && users.some(x => x.id === remembered)) ? remembered : (users[0]?.id || ''));

    state.currentUserId = pick || '';
    uSel.value = state.currentUserId || '';
  }

  // Careers (shared option list)
  let careers = await getAll('careers');
  careers.sort((a,b) => (a.title || '').localeCompare(b.title || ''));

  // User Career picker (career saved on the user)
  ucSel.innerHTML = '';
  if (!state.currentUserId) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '(Select a user)';
    ucSel.appendChild(opt);
    ucSel.value = '';
    ucSel.disabled = true;
  } else {
    ucSel.disabled = false;
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = '(No career selected)';
    ucSel.appendChild(opt0);

    careers.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.textContent = c.title || '(Career)';
      ucSel.appendChild(opt);
    });

    const uc = await getOne('userCareer', state.currentUserId);
    ucSel.value = uc?.careerId || '';
  }

  // Current Career picker (global, shared with Setup Career dropdown)
  ccSel.innerHTML = '';
  const optNone = document.createElement('option');
  optNone.value = '';
  optNone.textContent = '(Choose a career)';
  ccSel.appendChild(optNone);

  careers.forEach(c => {
    const opt = document.createElement('option');
    opt.value = c.id;
    opt.textContent = c.title || '(Career)';
    ccSel.appendChild(opt);
  });

  let rememberedCareer = '';
  try { rememberedCareer = localStorage.getItem('mivida_current_career_id') || ''; } catch { rememberedCareer = ''; }

  let pickCareer =
    (state.currentCareerId && careers.some(x => x.id === state.currentCareerId)) ? state.currentCareerId :
    ((rememberedCareer && careers.some(x => x.id === rememberedCareer)) ? rememberedCareer :
     (careers[0]?.id || ''));

  state.currentCareerId = pickCareer || '';
  state.promptCareerId = state.currentCareerId || '';
  ccSel.value = state.currentCareerId || '';
}

async function renderPromptPage() {
  const userId = state.currentUserId;
  const user = userId ? await getOne('users', userId) : null;
  const userName = (user?.name || user?.title || (userId ? ('user ' + userId) : '(No user)'));
  const careersAll = await getAll('careers');
  const careerMap = new Map((careersAll || []).map(x => [x.id, x]));
  let userCareerId = null;
  if (userId) {
    try { const uc = await getOne('userCareer', userId); userCareerId = uc?.careerId || null; } catch {}
  }

  let conns = await getAll('connections');
  conns = applyUiOrder(conns, 'connections', (x)=>x.id, (a,b) => (a.title || '').localeCompare(b.title || ''));

  const host = $('#promptConnections');
  host.innerHTML = '';

  $('#promptEmpty').style.display = (conns.length === 0) ? 'block' : 'none';

// Precompute explicit output counts across all items (connection output depends on item -> connection linkage, not on connection pick-lists)
let explicitOutCount = new Map();
try {
  const [pTemplates, cTemplates] = await Promise.all([
    getAll('personalTemplates'),
    getAll('careerTemplates')
  ]);
  ([...(pTemplates || []), ...(cTemplates || [])] || []).forEach(t => {
    if (!t) return;
    if (t.isOutput === false) return;
    const oc = (t.outputConnectionId || '');
    if (!oc) return;
    explicitOutCount.set(oc, (explicitOutCount.get(oc) || 0) + 1);
  });
} catch(e) { /* ignore */ }

  for (const c of conns) {
    const info = await analyzeConnectionForCurrentUser(c, 'prompt');
    const hasExplicitOutput = (explicitOutCount.get(c.id) || 0) > 0;

    const card = document.createElement('div');
    card.className = 'card';
    card.style.marginTop = '12px';

    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    header.style.gap = '12px';

    const left = document.createElement('div');

    const h = document.createElement('h3');
    h.style.margin = '0';
    h.textContent = c.title;

    const meta = document.createElement('div');
    meta.className = 'hint';
    meta.style.marginTop = '4px';
    meta.textContent = userId
      ? `Compiled for current user. Updated: ${formatLocal(c.updatedAt)}`
      : `Select a user in Setup ‚Üí Users to compile. Updated: ${formatLocal(c.updatedAt)}`;

    left.appendChild(h);

    // Tags: show which user/career this connection compiles with
    const needsUser = (c.personalTemplateIds || []).length > 0;
    const needsCareer = (c.careerTemplateIds || []).length > 0;
    const tags = [];
    if (needsUser) tags.push(`user: ${userName}`);
    if (needsCareer) {
      const src = (c.careerSource || 'user');
      const cid = (src === 'current') ? (state.currentCareerId || null) : (userCareerId || null);
      const cObj = cid ? careerMap.get(cid) : null;
      const cTitle = cid ? (cObj?.title || cObj?.name || cid) : '(not selected)';
      tags.push(`career: ${cTitle}`);
    }
    if (tags.length) {
      const tagRow = document.createElement('div');
      tagRow.style.marginTop = '6px';
      tagRow.style.display = 'flex';
      tagRow.style.gap = '6px';
      tags.slice(0,2).forEach(t => {
        const sp = document.createElement('span');
        sp.className = 'pill';
        sp.textContent = t;
        tagRow.appendChild(sp);
      });
      left.appendChild(tagRow);
    }

    left.appendChild(meta);

    const notes = [];
    if (info.missingCareer && (c.careerTemplateIds || []).length) notes.push('Career not selected for this user.');
    if (info.emptyPersonal.length) notes.push(`Empty personal: ${info.emptyPersonal.join(', ')}`);
    if (info.emptyCareer.length) notes.push(`Empty career: ${info.emptyCareer.join(', ')}`);

    if (notes.length) {
      const warn = document.createElement('div');
      warn.className = 'hint';
      warn.style.marginTop = '6px';
      warn.textContent = '‚ö†Ô∏è ' + notes.join(' ');
      left.appendChild(warn);
    }

    const right = document.createElement('div');
    right.style.display = 'flex';
    right.style.flexDirection = 'column';
    right.style.alignItems = 'flex-end';
    right.style.gap = '6px';

    const actionRowTop = document.createElement('div');
    actionRowTop.style.display = 'flex';
    actionRowTop.style.gap = '8px';
    actionRowTop.style.justifyContent = 'flex-end';

    const actionRowBottom = document.createElement('div');
    actionRowBottom.style.display = 'flex';
    actionRowBottom.style.gap = '8px';
    actionRowBottom.style.justifyContent = 'flex-end';
    const btnPrompt = btn('Prompt', { mini:true, onClick: async () => {
      await openPromptModal(c);
    }});
const btnCopy = btn('Copy', { mini:true, onClick: async () => {
      await navigator.clipboard.writeText(info.compiled || '');
      toast('Copied to clipboard');
    }});

    const promptId = (c?.promptItemIds && c.promptItemIds.length) ? c.promptItemIds[0] : '';
    if (promptId) {
      const btnEditPrompt = btn('Edit Prompt', { mini:true, onClick: async () => {
        try {
          const it = await getOne('promptItems', promptId);
          if (!it) { toast('Prompt item not found'); return; }
          openEditItemModal({
            title: 'Edit ¬∑ Prompt Item',
            initial: it,
            onSave: savePromptItem,
            onDelete: null,
            contentOnly: true
          });
        } catch (e) {
          console.error(e);
          toast('Failed to open prompt editor');
        }
      }});
      actionRowTop.appendChild(btnEditPrompt);
    }

    if (hasExplicitOutput) {
      const btnEditOutput = btn('Edit Output', { mini:true, onClick: async () => {
        try {
          const connId = c?.id || '';
          if (!connId) { toast('Connection not found'); return; }

          const [pTemps, cTemps] = await Promise.all([
            getAll('personalTemplates'),
            getAll('careerTemplates')
          ]);

          let outTpl = (pTemps || []).find(t => t && t.isOutput !== false && (t.outputConnectionId || '') === connId) || null;
          let outType = 'personal';
          if (!outTpl) {
            outTpl = (cTemps || []).find(t => t && t.isOutput !== false && (t.outputConnectionId || '') === connId) || null;
            if (outTpl) outType = 'career';
          }

          if (!outTpl) { toast('No output item is linked to this connection'); return; }

          if (outType === 'personal') {
            const userId = state.currentUserId;
            if (!userId) { toast('Select a user first'); return; }

            const row = await getOne('personalContent', [userId, outTpl.id]);
            openEditItemModal({
              title: 'Edit ¬∑ Output',
              initial: { templateId: outTpl.id, title: outTpl.title, content: (row?.content || '') },
              contentOnly: true,
              onSave: async (payload) => {
                const ok = await savePersonalTemplateAndContent(payload);
                await refreshAll();
                return ok;
              }
            });
            return;
          }

          // Fallback: career output (not expected, but supported)
          let careerId = null;
          const source = (c?.careerSource || 'user');
          if (source === 'current') {
            careerId = state.currentCareerId || null;
          } else if (state.currentUserId) {
            const uc = await getOne('userCareer', state.currentUserId);
            careerId = uc?.careerId || null;
          }
          if (!careerId) { toast('Career is not selected'); return; }

          const row = await getOne('careerContent', [careerId, outTpl.id]);
          openEditItemModal({
            title: 'Edit ¬∑ Output',
            initial: { templateId: outTpl.id, title: outTpl.title, content: (row?.content || '') },
            contentOnly: true,
            onSave: async (payload) => {
              const t = nowISO();
              const before = await getOne('careerContent', [careerId, outTpl.id]);
              await putOne('careerContent', {
                careerId,
                templateId: outTpl.id,
                content: payload.content || '',
                createdAt: before?.createdAt || t,
                updatedAt: t
              });

              const beforeTpl = await getOne('careerTemplates', outTpl.id);
              if (beforeTpl) await putOne('careerTemplates', { ...beforeTpl, updatedAt: t });

              await refreshAll();
            }
          });
        } catch (e) {
          console.error(e);
          toast('Failed to open output editor');
        }
      }});
      actionRowTop.appendChild(btnEditOutput);

      const btnOut = btn('Output', { mini:true, onClick: async () => {
        await openOutputModal(c);
      }});
      actionRowBottom.appendChild(btnOut);
    }

    actionRowBottom.appendChild(btnPrompt);
    actionRowBottom.appendChild(btnCopy);

    if (actionRowTop.childNodes.length) right.appendChild(actionRowTop);
    right.appendChild(actionRowBottom);

    header.appendChild(left);
    header.appendChild(right);

    card.appendChild(header);
    host.appendChild(card);
}
}


/** ========= Export / Import ========= */
async function exportLogsCsv() {
  const logs = await getAll('changeLogs');
  logs.sort((a,b) => (a.timestamp || '').localeCompare(b.timestamp || ''));

  const header = ['timestamp','entityType','entityId','action','after','before'];
  const rows = logs.map(l => [
    l.timestamp, l.entityType, l.entityId, l.action,
    JSON.stringify(l.after ?? null), JSON.stringify(l.before ?? null)
  ]);

  const csv = [header, ...rows].map(r => r.map(escapeCsv).join(',')).join('\n');
  downloadText(`mivida_change_log_${new Date().toISOString().slice(0,10)}.csv`, csv, 'text/csv');
}

async function exportSnapshotJson(options=null) {
  // Export options are intentionally "section-level" (no title-only exports).
  // Sections:
  // - promptItems
  // - profiles (users + personal titles + personal content)
  // - careers (careers + career titles + career content)
  // - connections (connections + required prompt items + required title templates only; does NOT force profile/career content)
  // - changeLogs
  // - includeOrder (exports UI list order for selected sections)
  const defaults = {
    promptItems: false,
    profiles: false,
    careers: false,
    connections: false,
    changeLogs: false,
    includeOrder: false
  };
  const opts = Object.assign({}, defaults, options || {});

  const exportConnections = !!opts.connections;
  const exportPromptsRequested = !!opts.promptItems;
  const exportProfiles = !!opts.profiles;
  const exportCareers = !!opts.careers;
  const exportLogs = !!opts.changeLogs;

  // Mapping is meaningful only when BOTH profiles + careers are exported.
  const exportUserCareer = (exportProfiles && exportCareers);

  // Optional filters: export only selected Users / Careers / Prompt items (and their related content).
  const userFilter = (exportProfiles && Array.isArray(opts.userIds) && opts.userIds.length)
    ? new Set(opts.userIds)
    : null;
  const careerFilter = (exportCareers && Array.isArray(opts.careerIds) && opts.careerIds.length)
    ? new Set(opts.careerIds)
    : null;

  // Prompt filter applies only to the "Prompt items" section selection.
  // If connections are exported, required prompt items will be included additionally (union).
  const promptFilter = (exportPromptsRequested && Array.isArray(opts.promptItemIds) && opts.promptItemIds.length)
    ? new Set(opts.promptItemIds)
    : null;

  // Pull datasets (only what's needed)
  const users = exportProfiles ? await safeGetAll('users') : [];
  const personalTemplates = (exportProfiles || exportConnections) ? await safeGetAll('personalTemplates') : [];
  const personalContent = exportProfiles ? await safeGetAll('personalContent') : [];

  const careers = exportCareers ? await safeGetAll('careers') : [];
  const careerTemplates = (exportCareers || exportConnections) ? await safeGetAll('careerTemplates') : [];
  const careerContent = exportCareers ? await safeGetAll('careerContent') : [];

  const userCareer = exportUserCareer ? await safeGetAll('userCareer') : [];
  const connections = exportConnections ? await safeGetAll('connections') : [];

  // Prompt items are needed when explicitly exporting prompts OR exporting connections (dependencies).
  const promptItems = (exportPromptsRequested || exportConnections) ? await safeGetAll('promptItems') : [];
  const setupCategories = await safeGetAll('setupCategories');

  const changeLogs = exportLogs ? await safeGetAll('changeLogs') : [];

  // Apply filters (profiles/careers only)
  const usersOut = userFilter ? (users || []).filter(u => userFilter.has(u.id)) : users;
  const careersOut = careerFilter ? (careers || []).filter(c => careerFilter.has(c.id)) : careers;

  const personalContentOut = userFilter ? (personalContent || []).filter(r => userFilter.has(r.userId)) : personalContent;
  const careerContentOut = careerFilter ? (careerContent || []).filter(r => careerFilter.has(r.careerId)) : careerContent;

  let userCareerOut = userCareer || [];
  if (userFilter) userCareerOut = userCareerOut.filter(r => userFilter.has(r.userId));
  if (careerFilter) userCareerOut = userCareerOut.filter(r => careerFilter.has(r.careerId));

  // Collect dependencies from exported connections:
  // - promptItemIds
  // - personalTemplateIds (titles)
  // - careerTemplateIds (titles)
  const refPromptIds = new Set();
  const refPersonalTplIds = new Set();
  const refCareerTplIds = new Set();

  if (exportConnections) {
    (connections || []).forEach(c => {
      (c.promptItemIds || []).forEach(id => refPromptIds.add(id));
      (c.personalTemplateIds || []).forEach(id => refPersonalTplIds.add(id));
      (c.careerTemplateIds || []).forEach(id => refCareerTplIds.add(id));
    });
  }

  // Determine prompt items to export:
  // - If Prompt items section is requested without a filter => export all promptItems
  // - Else export selected prompt items (if any) union required prompt items for connections
  let promptItemsOut = [];
  if (exportPromptsRequested && !promptFilter) {
    // Export all prompts (and connections will be satisfied implicitly)
    promptItemsOut = promptItems || [];
  } else {
    const outIds = new Set();
    if (exportPromptsRequested) {
      // If no promptFilter, treat "selected" as all (already handled above).
      (promptFilter ? Array.from(promptFilter) : []).forEach(id => outIds.add(id));
    }
    if (exportConnections) {
      refPromptIds.forEach(id => outIds.add(id));
    }
    promptItemsOut = (promptItems || []).filter(p => outIds.has(p.id));
  }

  // Determine templates to export:
  // - Profiles export: export ALL personalTemplates (paired with content)
  // - Connections export only: export ONLY referenced templates (titles)
  const personalTemplatesOut = exportProfiles
    ? (personalTemplates || [])
    : (exportConnections ? (personalTemplates || []).filter(t => refPersonalTplIds.has(t.id)) : []);

  const careerTemplatesOut = exportCareers
    ? (careerTemplates || [])
    : (exportConnections ? (careerTemplates || []).filter(t => refCareerTplIds.has(t.id)) : []);
  // Ensure we export the item‚Üîconnection "output" relationship in a stable way.
  // Attach outputConnectionTitle (resolved from local connections by id) to templates.
  const _allConnsForOutputTitle = await safeGetAll('connections');
  const _connTitleById = new Map((_allConnsForOutputTitle || []).map(c => [c.id, c.title || '']));

  const personalTemplatesOutFinal = (personalTemplatesOut || []).map(t => {
    const ocid = (t && t.outputConnectionId) ? String(t.outputConnectionId) : '';
    const oct = (t && t.outputConnectionTitle) ? String(t.outputConnectionTitle) : (ocid ? (_connTitleById.get(ocid) || '') : '');
    return { ...t, outputConnectionTitle: oct };
  });

  const careerTemplatesOutFinal = (careerTemplatesOut || []).map(t => {
    const ocid = (t && t.outputConnectionId) ? String(t.outputConnectionId) : '';
    const oct = (t && t.outputConnectionTitle) ? String(t.outputConnectionTitle) : (ocid ? (_connTitleById.get(ocid) || '') : '');
    return { ...t, outputConnectionTitle: oct };
  });


  // Legacy arrays for backward compatibility: include only when exporting the full paired data.
  let personalItemsLegacy = [];
  if (exportProfiles) {
    const tMap = new Map((personalTemplates || []).map(t => [t.id, t.title]));
    personalItemsLegacy = (personalContentOut || []).map(r => ({
      id: `${r.userId}::${r.templateId}`,
      userId: r.userId,
      title: tMap.get(r.templateId) || '',
      content: r.content || '',
      createdAt: r.createdAt || null,
      updatedAt: r.updatedAt || null
    })).filter(r => r.userId && r.title);
  }

  let careerBlocksLegacy = [];
  if (exportCareers) {
    const tMap = new Map((careerTemplates || []).map(t => [t.id, t.title]));
    careerBlocksLegacy = (careerContentOut || []).map(r => ({
      id: `${r.careerId}::${r.templateId}`,
      careerId: r.careerId,
      title: tMap.get(r.templateId) || '',
      content: r.content || '',
      createdAt: r.createdAt || null,
      updatedAt: r.updatedAt || null
    })).filter(r => r.careerId && r.title);
  }

  // Optional: export UI item order (Setup page list order), scoped to the exported data.
  let uiSortOut = null;
  if (opts.includeOrder) {
    const keys = [];
    // Prompt list order is relevant if promptItems are exported OR connections are exported (dependencies).
    if (exportPromptsRequested || exportConnections) keys.push('promptItems');
    // Template list order is relevant if their corresponding templates are included.
    if (exportProfiles || exportConnections) keys.push('personalTemplates');
    if (exportCareers || exportConnections) keys.push('careerTemplates');
    if (exportConnections) keys.push('connections');

    const out = {};
    const exportedPromptIdSet = new Set((promptItemsOut || []).map(p => p.id));
    const exportedPersonalTplIdSet = new Set((personalTemplatesOutFinal || []).map(t => t.id));
    const exportedCareerTplIdSet = new Set((careerTemplatesOutFinal || []).map(t => t.id));

    keys.forEach(k => {
      const arr = getUiOrder(k);
      if (!Array.isArray(arr)) return;

      if (k === 'promptItems' && exportedPromptIdSet.size && exportedPromptIdSet.size < (promptItems || []).length) {
        out[k] = arr.filter(id => exportedPromptIdSet.has(id));
        return;
      }
      if (k === 'personalTemplates' && exportedPersonalTplIdSet.size && exportedPersonalTplIdSet.size < (personalTemplates || []).length) {
        out[k] = arr.filter(id => exportedPersonalTplIdSet.has(id));
        return;
      }
      if (k === 'careerTemplates' && exportedCareerTplIdSet.size && exportedCareerTplIdSet.size < (careerTemplates || []).length) {
        out[k] = arr.filter(id => exportedCareerTplIdSet.has(id));
        return;
      }

      out[k] = arr;
    });

    uiSortOut = out;
  }

  const snapshot = {
    version: DB_VERSION,
    exportedAt: nowISO(),

    // Sections (always present as arrays for predictable import)
    users: usersOut || [],
    personalTemplates: personalTemplatesOutFinal || [],
    personalContent: exportProfiles ? (personalContentOut || []) : [],

    careers: careersOut || [],
    careerTemplates: careerTemplatesOutFinal || [],
    careerContent: exportCareers ? (careerContentOut || []) : [],

    promptItems: promptItemsOut || [],
    connections: exportConnections ? (connections || []) : [],
    userCareer: exportUserCareer ? (userCareerOut || []) : [],

    changeLogs: exportLogs ? (changeLogs || []) : [],

    setupCategories: (setupCategories || []),

    // Optional UI ordering
    uiSort: uiSortOut,

    // legacy (generated for backward compatibility)
    personalItems: exportProfiles ? (personalItemsLegacy || []) : [],
    careerBlocks: exportCareers ? (careerBlocksLegacy || []) : []
  };

  const s = getSyncUiState();

  if (s.provider === 'github') {
    // Online export: upload to GitHub (append-only; never overwrite).
    try {
      const toolVersion = (document.getElementById('appVersionPill')?.textContent || '').trim() || '';
      const uploadedAtLocal = (()=>{ const d=new Date(); const pad=(n,w=2)=>String(n).padStart(w,'0'); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${pad(d.getMilliseconds(),3)}`; })();
      const cfg = GitHubSync.getConfig();
      snapshot.uploadedBy = cfg.uploader || '';
      snapshot.uploadedAtLocal = uploadedAtLocal;
      snapshot.toolVersion = toolVersion;
      const jsonText = JSON.stringify(snapshot, null, 2);
      const up = await GitHubSync.uploadSnapshotJsonText(jsonText);
      toast(`Uploaded: ${up.filename}`);
    } catch (err) {
      console.error(err);
      alert('Online export failed\n\n' + (err?.message || String(err)));
      throw err;
    }
    return snapshot;
  }

  // Offline export: download locally
  const stamp = new Date().toISOString().replace(/[:.]/g,'-');
  const jsonText = JSON.stringify(snapshot, null, 2);
  downloadText(`mivida_snapshot_${stamp}.json`, jsonText, 'application/json');
  toast('Snapshot exported');
  return snapshot;
}

function openExportWizard() {
  // Default: export nothing until the user selects items or other sections.
  const opts = {
    promptItems: false,
    profiles: false,
    careers: false,
    connections: false,
    changeLogs: false,
    includeOrder: false
  };

  // Item pickers (per section)
  let allPromptItems = [];
  let allUsers = [];
  let allCareers = [];

  const selPromptItemIds = new Set();
  const selUserIds = new Set();
  const selCareerIds = new Set();

  const promptChkMap = new Map();
  const userChkMap = new Map();
  const careerChkMap = new Map();

  const body = document.createElement('div');
  body.className = 'modalBody';

  const info = document.createElement('div');
  info.className = 'hint';
  info.textContent = 'Select items to export. Titles and content are always exported together.';
  body.appendChild(info);

  function mkSection(title){
    const s = document.createElement('div');
    s.className = 'importGroup';
    const h = document.createElement('div');
    h.style.fontWeight = '800';
    h.style.marginBottom = '8px';
    h.textContent = title;
    s.appendChild(h);
    return s;
  }

  function mkChk(label, key){
    const wrap = document.createElement('label');
    wrap.className = 'checkRow';
    const c = document.createElement('input');
    c.type = 'checkbox';
    c.checked = false;
    const span = document.createElement('span');
    span.textContent = label;
    wrap.appendChild(c); wrap.appendChild(span);
    return { wrap, c, key };
  }

  function mkPickList(titleText, helperText) {
    const wrap = document.createElement('div');
    wrap.style.display = 'flex';
    wrap.style.flexDirection = 'column';
    wrap.style.gap = '6px';

    const top = document.createElement('div');
    top.style.display = 'flex';
    top.style.alignItems = 'center';
    top.style.gap = '10px';

    const title = document.createElement('div');
    title.className = 'muted';
    title.style.fontSize = '12px';
    title.style.fontWeight = '700';
    title.textContent = titleText;

    const bAll = document.createElement('button');
    bAll.className = 'btn small';
    bAll.textContent = 'Select all';

    const bClr = document.createElement('button');
    bClr.className = 'btn small';
    bClr.textContent = 'Clear';

    top.appendChild(title);
    top.appendChild(bAll);
    top.appendChild(bClr);
    wrap.appendChild(top);

    const hint = document.createElement('div');
    hint.className = 'muted';
    hint.style.fontSize = '12px';
    hint.textContent = helperText || '';
    wrap.appendChild(hint);

    const rows = document.createElement('div');
    rows.style.display = 'flex';
    rows.style.flexDirection = 'column';
    rows.style.gap = '4px';
    wrap.appendChild(rows);

    return { wrap, rows, hint, bAll, bClr };
  }

  function pickHint(setSize, total){
    if (!total) return '';
    if (setSize === 0) return 'None selected';
    if (setSize === total) return `All ${total} selected`;
    return `${setSize} selected`;
  }

  // --- Prompts ---
  const sPrompts = mkSection('Prompts');
  const promptPick = mkPickList('Prompt items', 'Pick which prompt items to export.');
  sPrompts.appendChild(promptPick.wrap);
  body.appendChild(sPrompts);

  // --- Profiles ---
  const sProfiles = mkSection('Profiles');
  const userPick = mkPickList('Users', 'Pick which users to export (includes their Personal Info).');
  sProfiles.appendChild(userPick.wrap);
  body.appendChild(sProfiles);

  // --- Careers ---
  const sCareers = mkSection('Careers');
  const careerPick = mkPickList('Careers', 'Pick which careers to export (includes their Career Info).');
  sCareers.appendChild(careerPick.wrap);
  body.appendChild(sCareers);

  // --- Other toggles ---
  const sOther = mkSection('Other');
  const cConnections = mkChk('Connections', 'connections'); sOther.appendChild(cConnections.wrap);
  const cLogs = mkChk('Change logs', 'changeLogs'); sOther.appendChild(cLogs.wrap);
  const cOrder = mkChk('Include item order (Setup list order)', 'includeOrder'); sOther.appendChild(cOrder.wrap);
  body.appendChild(sOther);

  function syncFromPicks(){
    opts.promptItems = selPromptItemIds.size > 0;
    opts.profiles = selUserIds.size > 0;
    opts.careers = selCareerIds.size > 0;
    sync();
  }

  function renderPromptPick(){
    promptPick.rows.innerHTML = '';
    promptChkMap.clear();
    if (!allPromptItems.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'No prompt items found.';
      promptPick.rows.appendChild(d);
      promptPick.hint.textContent = '';
      return;
    }
    allPromptItems.forEach(p => {
      const wrap = document.createElement('label');
      wrap.className = 'muted';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '8px';
      wrap.style.fontSize = '12px';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selPromptItemIds.has(p.id);
      cb.onchange = () => {
        if (cb.checked) selPromptItemIds.add(p.id);
        else selPromptItemIds.delete(p.id);
        syncFromPicks();
      };

      const name = document.createElement('span');
      name.textContent = p.title || '(Untitled)';

      wrap.appendChild(cb);
      wrap.appendChild(name);
      promptPick.rows.appendChild(wrap);
      promptChkMap.set(p.id, cb);
    });
    promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
  }

  function renderUserPick(){
    userPick.rows.innerHTML = '';
    userChkMap.clear();
    if (!allUsers.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'No users found.';
      userPick.rows.appendChild(d);
      userPick.hint.textContent = '';
      return;
    }
    allUsers.forEach(u => {
      const wrap = document.createElement('label');
      wrap.className = 'muted';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '8px';
      wrap.style.fontSize = '12px';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selUserIds.has(u.id);
      cb.onchange = () => {
        if (cb.checked) selUserIds.add(u.id);
        else selUserIds.delete(u.id);
        syncFromPicks();
      };

      const name = document.createElement('span');
      name.textContent = u.name || '(Unnamed user)';

      wrap.appendChild(cb);
      wrap.appendChild(name);
      userPick.rows.appendChild(wrap);
      userChkMap.set(u.id, cb);
    });
    userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
  }

  function renderCareerPick(){
    careerPick.rows.innerHTML = '';
    careerChkMap.clear();
    if (!allCareers.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'No careers found.';
      careerPick.rows.appendChild(d);
      careerPick.hint.textContent = '';
      return;
    }
    allCareers.forEach(c => {
      const wrap = document.createElement('label');
      wrap.className = 'muted';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '8px';
      wrap.style.fontSize = '12px';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selCareerIds.has(c.id);
      cb.onchange = () => {
        if (cb.checked) selCareerIds.add(c.id);
        else selCareerIds.delete(c.id);
        syncFromPicks();
      };

      const name = document.createElement('span');
      name.textContent = c.title || '(Untitled career)';

      wrap.appendChild(cb);
      wrap.appendChild(name);
      careerPick.rows.appendChild(wrap);
      careerChkMap.set(c.id, cb);
    });
    careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);
  }

  function selectAllPrompts(){
    selPromptItemIds.clear();
    allPromptItems.forEach(p => selPromptItemIds.add(p.id));
    promptChkMap.forEach(cb => { cb.checked = true; });
    promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
    syncFromPicks();
  }
  function clearPrompts(){
    selPromptItemIds.clear();
    promptChkMap.forEach(cb => { cb.checked = false; });
    promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
    syncFromPicks();
  }
  function selectAllUsers(){
    selUserIds.clear();
    allUsers.forEach(u => selUserIds.add(u.id));
    userChkMap.forEach(cb => { cb.checked = true; });
    userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
    syncFromPicks();
  }
  function clearUsers(){
    selUserIds.clear();
    userChkMap.forEach(cb => { cb.checked = false; });
    userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
    syncFromPicks();
  }
  function selectAllCareers(){
    selCareerIds.clear();
    allCareers.forEach(c => selCareerIds.add(c.id));
    careerChkMap.forEach(cb => { cb.checked = true; });
    careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);
    syncFromPicks();
  }
  function clearCareers(){
    selCareerIds.clear();
    careerChkMap.forEach(cb => { cb.checked = false; });
    careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);
    syncFromPicks();
  }

  promptPick.bAll.addEventListener('click', (e) => { e.preventDefault(); selectAllPrompts(); });
  promptPick.bClr.addEventListener('click', (e) => { e.preventDefault(); clearPrompts(); });
  userPick.bAll.addEventListener('click', (e) => { e.preventDefault(); selectAllUsers(); });
  userPick.bClr.addEventListener('click', (e) => { e.preventDefault(); clearUsers(); });
  careerPick.bAll.addEventListener('click', (e) => { e.preventDefault(); selectAllCareers(); });
  careerPick.bClr.addEventListener('click', (e) => { e.preventDefault(); clearCareers(); });

  // Load pick lists (default: nothing selected)
  (async () => {
    try {
      allPromptItems = await safeGetAll('promptItems');
      allPromptItems.sort((a,b) => (a.title||'').localeCompare(b.title||''));
      renderPromptPick();
    } catch (e) {
      promptPick.rows.innerHTML = '';
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'Failed to load prompt items.';
      promptPick.rows.appendChild(d);
    }

    try {
      allUsers = await safeGetAll('users');
      allUsers.sort((a,b) => (a.name||'').localeCompare(b.name||''));
      renderUserPick();
    } catch (e) {
      userPick.rows.innerHTML = '';
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'Failed to load users.';
      userPick.rows.appendChild(d);
    }

    try {
      allCareers = await safeGetAll('careers');
      allCareers.sort((a,b) => (a.title||'').localeCompare(b.title||''));
      renderCareerPick();
    } catch (e) {
      careerPick.rows.innerHTML = '';
      const d = document.createElement('div');
      d.className = 'muted';
      d.style.fontSize = '12px';
      d.textContent = 'Failed to load careers.';
      careerPick.rows.appendChild(d);
    }
  })();

  // Connections toggle: exports connections plus required prompt items and required title templates (no profile/career content forced).
  cConnections.c.onchange = () => {
    opts.connections = cConnections.c.checked;
    sync();
  };
  cLogs.c.onchange = () => { opts.changeLogs = cLogs.c.checked; sync(); };
  cOrder.c.onchange = () => { opts.includeOrder = cOrder.c.checked; sync(); };

  // Footer buttons
  const exportBtn = btn('Export', { primary:true, onClick: async () => {
// Attach filters only when a subset is selected.
if (opts.promptItems && allPromptItems.length && selPromptItemIds.size > 0 && selPromptItemIds.size < allPromptItems.length) {
  opts.promptItemIds = Array.from(selPromptItemIds);
} else {
  delete opts.promptItemIds;
}

if (opts.profiles && allUsers.length && selUserIds.size > 0 && selUserIds.size < allUsers.length) {
  opts.userIds = Array.from(selUserIds);
} else {
  delete opts.userIds;
}

if (opts.careers && allCareers.length && selCareerIds.size > 0 && selCareerIds.size < allCareers.length) {
  opts.careerIds = Array.from(selCareerIds);
} else {
  delete opts.careerIds;
}

// If a section is off, its filter should not apply.
if (!opts.promptItems) delete opts.promptItemIds;
if (!opts.profiles) delete opts.userIds;
if (!opts.careers) delete opts.careerIds;


    closeModal();
    await exportSnapshotJson(opts);
  }});

  const footerBtns = [
    exportBtn,
    btn('Cancel', { onClick: closeModal })
  ];

  function lockPickUI(isLocked){
    // Buttons
    promptPick.bAll.disabled = isLocked;
    promptPick.bClr.disabled = isLocked;
    userPick.bAll.disabled = isLocked;
    userPick.bClr.disabled = isLocked;
    careerPick.bAll.disabled = isLocked;
    careerPick.bClr.disabled = isLocked;

    // Checkboxes
    promptChkMap.forEach(cb => cb.disabled = isLocked);
    userChkMap.forEach(cb => cb.disabled = isLocked);
    careerChkMap.forEach(cb => cb.disabled = isLocked);
  }

  function sync(){
  // Derived section switches (no forced dependencies in the UI).
  opts.promptItems = selPromptItemIds.size > 0;
  opts.profiles = selUserIds.size > 0;
  opts.careers = selCareerIds.size > 0;

  cConnections.c.checked = !!opts.connections;
  cLogs.c.checked = !!opts.changeLogs;
  cOrder.c.checked = !!opts.includeOrder;

  // Never lock pickers; connections export has its own dependency rules in exportSnapshotJson().
  lockPickUI(false);

  // Hints
  if (allPromptItems.length) promptPick.hint.textContent = pickHint(selPromptItemIds.size, allPromptItems.length);
  if (allUsers.length) userPick.hint.textContent = pickHint(selUserIds.size, allUsers.length);
  if (allCareers.length) careerPick.hint.textContent = pickHint(selCareerIds.size, allCareers.length);

  info.textContent = 'Select items to export. Titles and content are always exported together.';

  // Enable export only when something meaningful is selected.
  const canExport = !!(opts.promptItems || opts.profiles || opts.careers || opts.connections || opts.changeLogs);
  exportBtn.disabled = !canExport;
}
sync();

  const headerBtns = [
    btn('Select all', { mini:true, onClick: () => {
      // Pick lists
      selPromptItemIds.clear(); allPromptItems.forEach(p => selPromptItemIds.add(p.id));
      selUserIds.clear(); allUsers.forEach(u => selUserIds.add(u.id));
      selCareerIds.clear(); allCareers.forEach(c => selCareerIds.add(c.id));

      // Other toggles
      opts.connections = true;
      opts.changeLogs = true;
      opts.includeOrder = true;

      renderPromptPick();
      renderUserPick();
      renderCareerPick();
      sync();
    }}),
    btn('Unselect all', { mini:true, danger:true, onClick: () => {
      selPromptItemIds.clear();
      selUserIds.clear();
      selCareerIds.clear();

      opts.connections = false;
      opts.changeLogs = false;
      opts.includeOrder = false;

      renderPromptPick();
      renderUserPick();
      renderCareerPick();
      sync();
    }})
  ];
  openModal('Export Snapshot', body, footerBtns, headerBtns);
}

async function openImportWizardFromText(rawText) {
  let s;
  try {
    s = JSON.parse(rawText);
  } catch (e) {
    toast('Invalid JSON snapshot');
    return;
  }

  // Allow wrappers: { snapshot: {...} } or { data: {...} }
  if (s && typeof s === 'object' && (s.snapshot || s.data)) {
    s = s.snapshot || s.data;
  }

  const looksLikeSnapshot =
    s && typeof s === 'object' &&
    (Array.isArray(s.users) || Array.isArray(s.promptItems) || Array.isArray(s.connections) ||
     Array.isArray(s.careers) || Array.isArray(s.personalTemplates) || Array.isArray(s.careerTemplates) ||
     Array.isArray(s.personalItems) || Array.isArray(s.careerBlocks));

  if (!looksLikeSnapshot) {
    toast('This JSON does not look like a MiVida snapshot. Import cancelled.');
    return;
  }

  const snap = normalizeSnapshotForImport(s);
  await openImportWizard(snap);
}

// One-click destructive import: wipe all local data, then import the entire snapshot.
// This intentionally bypasses the import wizard selection UI.
async function wipeLocalAndImportAllFromText(rawText) {
  let s;
  try {
    s = JSON.parse(rawText);
  } catch {
    toast('Invalid JSON snapshot');
    return;
  }

  // Allow wrappers: { snapshot: {...} } or { data: {...} }
  if (s && typeof s === 'object' && (s.snapshot || s.data)) {
    s = s.snapshot || s.data;
  }

  const looksLikeSnapshot =
    s && typeof s === 'object' &&
    (Array.isArray(s.users) || Array.isArray(s.promptItems) || Array.isArray(s.connections) ||
     Array.isArray(s.careers) || Array.isArray(s.personalTemplates) || Array.isArray(s.careerTemplates) ||
     Array.isArray(s.personalItems) || Array.isArray(s.careerBlocks));

  if (!looksLikeSnapshot) {
    toast('This JSON does not look like a MiVida snapshot. Import cancelled.');
    return;
  }

  const snap = normalizeSnapshotForImport(s);

  // Select everything in the snapshot (including empty personal/career content rows).
  const sel = {
    users: new Set((snap.users || []).map(x => x.id)),
    careers: new Set((snap.careers || []).map(x => x.id)),
    promptItems: new Set((snap.promptItems || []).map(x => x.id)),
    connections: new Set((snap.connections || []).map(x => x.id)),

    personalTemplates: new Set((snap.personalTemplates || []).map(t => t.id)),
    careerTemplates: new Set((snap.careerTemplates || []).map(t => t.id)),

    personalContentKeys: new Set(),
    careerContentKeys: new Set(),

    includePersonalContent: true,
    includeCareerContent: true,
    includeUserCareer: true,
  };

  for (const r of snap.personalContent || []) {
    if (!r || !r.userId || !r.templateId) continue;
    sel.personalContentKeys.add(`${r.userId}::${r.templateId}`);
  }
  for (const r of snap.careerContent || []) {
    if (!r || !r.careerId || !r.templateId) continue;
    sel.careerContentKeys.add(`${r.careerId}::${r.templateId}`);
  }

  // Wipe UI-only ordering and remembered selections.
  try {
    localStorage.removeItem(UI_SORT_STORAGE_KEY);
    localStorage.removeItem('mivida_current_user_id');
    localStorage.removeItem('mivida_current_career_id');
    localStorage.removeItem('mivida_prompt_career_id');
  } catch {}

  await importSnapshotSelectionReplace(snap, sel);

  // Restore Setup list order if provided by the snapshot.
  if (snap.uiSort && typeof snap.uiSort === 'object') {
    applyUiSortFromSnapshot(snap.uiSort, 'replace');
  }

  toast('Imported. Local data replaced with JSON snapshot.');
  await refreshAll();
  finalizeOnlineImportMeta();
}

function normalizeSnapshotForImport(s) {
  const tNow = nowISO();
  const mkId = () => uid();

  // Personal: prefer v3; fall back to legacy personalItems
  let personalTemplates = Array.isArray(s.personalTemplates) ? s.personalTemplates : [];
  let personalContent = Array.isArray(s.personalContent) ? s.personalContent : [];
  const legacyPersonalItems = Array.isArray(s.personalItems) ? s.personalItems : [];

  if ((!personalTemplates || personalTemplates.length === 0) && legacyPersonalItems.length) {
    const titleToTpl = new Map();
    legacyPersonalItems.forEach(r => {
      const title = (r.title || '').trim();
      if (!title) return;
      if (!titleToTpl.has(title)) {
        titleToTpl.set(title, { id: mkId(), title, createdAt: r.createdAt || tNow, updatedAt: r.updatedAt || r.createdAt || tNow });
      }
    });
    personalTemplates = [...titleToTpl.values()];
    personalContent = legacyPersonalItems.map(r => ({
      userId: r.userId,
      templateId: (titleToTpl.get((r.title || '').trim()) || {}).id,
      content: r.content || '',
      createdAt: r.createdAt || tNow,
      updatedAt: r.updatedAt || r.createdAt || tNow
    })).filter(r => r.userId && r.templateId);
  }

  // Career: prefer v3; fall back to legacy careerBlocks
  let careerTemplates = Array.isArray(s.careerTemplates) ? s.careerTemplates : [];
  let careerContent = Array.isArray(s.careerContent) ? s.careerContent : [];
  const legacyCareerBlocks = Array.isArray(s.careerBlocks) ? s.careerBlocks : [];

  if ((!careerTemplates || careerTemplates.length === 0) && legacyCareerBlocks.length) {
    const titleToTpl = new Map();
    legacyCareerBlocks.forEach(r => {
      const title = (r.title || '').trim();
      if (!title) return;
      if (!titleToTpl.has(title)) {
        titleToTpl.set(title, { id: mkId(), title, createdAt: r.createdAt || tNow, updatedAt: r.updatedAt || r.createdAt || tNow });
      }
    });
    careerTemplates = [...titleToTpl.values()];
    careerContent = legacyCareerBlocks.map(r => ({
      careerId: r.careerId,
      templateId: (titleToTpl.get((r.title || '').trim()) || {}).id,
      content: r.content || '',
      createdAt: r.createdAt || tNow,
      updatedAt: r.updatedAt || r.createdAt || tNow
    })).filter(r => r.careerId && r.templateId);
  }

  return {
    version: s.version || null,
    exportedAt: s.exportedAt || null,
    users: Array.isArray(s.users) ? s.users : [],
    careers: Array.isArray(s.careers) ? s.careers : [],
    userCareer: Array.isArray(s.userCareer) ? s.userCareer : [],
    promptItems: Array.isArray(s.promptItems) ? s.promptItems : [],
    personalTemplates,
    personalContent,
    careerTemplates,
    careerContent,
    connections: Array.isArray(s.connections) ? s.connections : [],
    setupCategories: Array.isArray(s.setupCategories) ? s.setupCategories : [],
    uiSort: (s.uiSort && typeof s.uiSort === 'object') ? s.uiSort : null,
  };
}

function normTitle(t) {
  return (t || '').trim().toLowerCase();
}

async function openImportWizard(snap) {
  // Existing titles for duplicate warnings
  const existing = {
    users: await getAll('users'),
    careers: await getAll('careers'),
    promptItems: await getAll('promptItems'),
    personalTemplates: await getAll('personalTemplates'),
    careerTemplates: await getAll('careerTemplates'),
    connections: await getAll('connections')
  };

  const existTitles = {
    users: new Set(existing.users.map(u => normTitle(u.name))),
    careers: new Set(existing.careers.map(c => normTitle(c.title))),
    promptItems: new Set(existing.promptItems.map(p => normTitle(p.title))),
    personalTemplates: new Map(existing.personalTemplates.map(t => [normTitle(t.title), t.id])),
    careerTemplates: new Map(existing.careerTemplates.map(t => [normTitle(t.title), t.id])),
    connections: new Set(existing.connections.map(c => normTitle(c.title)))
  };

  // Local objects lookup (for duplicate time comparison)
  const localBy = {
    users: new Map(existing.users.map(u => [normTitle(u.name), u])),
    careers: new Map(existing.careers.map(c => [normTitle(c.title), c])),
    promptItems: new Map(existing.promptItems.map(p => [normTitle(p.title), p])),
    personalTemplates: new Map(existing.personalTemplates.map(t => [normTitle(t.title), t])),
    careerTemplates: new Map(existing.careerTemplates.map(t => [normTitle(t.title), t])),
    connections: new Map(existing.connections.map(c => [normTitle(c.title), c]))
  };

  // Initial selection: select nothing (user will pick what to import)
  const sel = {
    users: new Set(),
    careers: new Set(),
    promptItems: new Set(),
    connections: new Set(),

    // These are imported as needed (selected content + selected connections)
    personalTemplates: new Set(),
    careerTemplates: new Set(),

    // Content selection is per (ownerId, templateId)
    personalContentKeys: new Set(), // `${userId}::${templateId}`
    careerContentKeys: new Set(),   // `${careerId}::${templateId}`

    // Kept for backward compatibility with import functions
    includePersonalContent: false,
    includeCareerContent: false,
    includeUserCareer: true
  };

  // Default: do not preselect any content rows (user will pick what to import)
  sel.includePersonalContent = false;
  sel.includeCareerContent = false;

  const auto = {
    promptItems: new Set(),
    personalTemplates: new Set(),
    careerTemplates: new Set()
  };

  const warningsEl = document.createElement('div');
  warningsEl.className = 'hint';
  warningsEl.style.marginTop = '10px';

  function upsertBadge(slot, key, text, variant='warn'){
    if (!slot) return;
    const q = `[data-badge="${key}"]`;
    let el = slot.querySelector(q);
    if (!text) {
      if (el) el.remove();
      return;
    }
    if (!el) {
      el = document.createElement('span');
      el.className = 'pill';
      el.dataset.badge = key;
      slot.appendChild(el);
    }
    el.textContent = text;
    el.classList.remove('badgeWarn','badgeOk');
    if (variant === 'warn') el.classList.add('badgeWarn');
    if (variant === 'ok') el.classList.add('badgeOk');
  }

  function fmtTime(iso) {
    if (!iso) return '‚Äî';
    try { return formatLocal(iso); } catch { return String(iso); }
  }

  // Alias for older import UI code paths
  function fmtLocal(iso) { return fmtTime(iso); }

  function setDupTimesForGroup(group, dupIdSet, localMap, getLabel) {
    group.rowById.forEach((cell, id) => {
      if (!cell || !cell.metaSlot) return;

      if (!dupIdSet.has(id)) {
        cell.metaSlot.innerHTML = '';
        cell.row.title = '';
        return;
      }

      const it = cell.it;
      const key = normTitle(getLabel(it));
      const local = localMap.get(key);

      if (!local) {
        cell.metaSlot.innerHTML = '';
        cell.row.title = '';
        return;
      }

      const localUpdated = local.updatedAt || local.createdAt || null;
      const jsonUpdated = it.updatedAt || it.createdAt || null;

      const lu = localUpdated ? Date.parse(localUpdated) : NaN;
      const ju = jsonUpdated ? Date.parse(jsonUpdated) : NaN;

      let newer = 'same';
      if (!Number.isNaN(lu) && !Number.isNaN(ju)) {
        if (lu > ju) newer = 'local';
        else if (ju > lu) newer = 'json';
      } else if (!Number.isNaN(lu) && Number.isNaN(ju)) {
        newer = 'local';
      } else if (Number.isNaN(lu) && !Number.isNaN(ju)) {
        newer = 'json';
      }

      const statusPill = newer === 'same'
        ? '<span class="pill newerTag">Same</span>'
        : `<span class="pill badgeOk newerTag">${newer === 'local' ? 'Local newer' : 'JSON newer'}</span>`;

      cell.metaSlot.innerHTML = `
        <div>
          Updated:
          <b>Local</b> ${escapeHtml(fmtTime(localUpdated))}
          <span class="muted">¬∑</span>
          <b>JSON</b> ${escapeHtml(fmtTime(jsonUpdated))}
          ${statusPill}
        </div>
      `;

      cell.row.title = 'Duplicate title found. Replace selected will overwrite the local item with the same title or name. Add to local selected will create a new item and automatically rename it to Title (Imported), Title (Imported 2), and so on when needed.';
    });
  }

  function makeGroup(title, items, getLabel, setRef, options={}) {
    const group = document.createElement('div');
    group.className = 'importGroup';

    const head = document.createElement('div');
    head.className = 'importGroupHeader';

    const h = document.createElement('div');
    h.className = 'importGroupTitle';
    h.textContent = title;

    const controls = document.createElement('div');
    controls.className = 'importGroupControls';

    const chkAll = document.createElement('input');
    chkAll.type = 'checkbox';
    chkAll.checked = items.length > 0 && setRef.size === items.length;

    const lblAll = document.createElement('label');
    lblAll.className = 'muted';
    lblAll.style.display = 'flex';
    lblAll.style.alignItems = 'center';
    lblAll.style.gap = '8px';
    lblAll.appendChild(chkAll);
    lblAll.appendChild(document.createTextNode(`Select all (${items.length})`));
    controls.appendChild(lblAll);

    let contentToggle = null;
    let contentHint = null;

    if (options.includeContentToggle) {
      contentToggle = document.createElement('input');
      contentToggle.type = 'checkbox';
      contentToggle.checked = options.includeContentToggle.checked;

      contentToggle.onchange = () => {
        options.includeContentToggle.onChange(contentToggle.checked);
        recompute();
      };

      const lblContent = document.createElement('label');
      lblContent.className = 'muted';
      lblContent.style.display = 'flex';
      lblContent.style.alignItems = 'center';
      lblContent.style.gap = '8px';
      lblContent.appendChild(contentToggle);
      lblContent.appendChild(document.createTextNode(options.includeContentToggle.label));

      contentHint = document.createElement('span');
      contentHint.className = 'pill badgeWarn';
      contentHint.style.display = 'none';
      contentHint.textContent = 'Requires Users';
      lblContent.appendChild(contentHint);

      controls.appendChild(lblContent);
    }

    head.appendChild(h);
    head.appendChild(controls);

    const list = document.createElement('div');
    list.className = 'importRows';

    const rowById = new Map();

    if (!items.length) {
      const empty = document.createElement('div');
      empty.className = 'muted';
      empty.style.fontSize = '12px';
      empty.textContent = 'No items in this snapshot.';
      list.appendChild(empty);
    }

    items.forEach(it => {
      const row = document.createElement('div');
      row.className = 'importRow';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = setRef.has(it.id);
      cb.onchange = () => {
        if (cb.checked) setRef.add(it.id); else setRef.delete(it.id);
        recompute();
      };

      const main = document.createElement('div');
      main.className = 'importMain';

      const titleLine = document.createElement('div');
      titleLine.className = 'importTitleLine';

      const titleDiv = document.createElement('div');
      titleDiv.className = 'importItemTitle';
      titleDiv.textContent = getLabel(it);

      titleLine.appendChild(titleDiv);

      const meta = document.createElement('div');
      meta.className = 'importMeta';

      const badges = document.createElement('div');
      badges.className = 'importBadges';

      main.appendChild(titleLine);
      main.appendChild(meta);
      main.appendChild(badges);

      row.appendChild(cb);
      row.appendChild(main);
      list.appendChild(row);

      rowById.set(it.id, { row, cb, badgeSlot: badges, metaSlot: meta, it, titleDiv });
    });

    chkAll.onchange = () => {
      const v = chkAll.checked;
      items.forEach(it => {
        const cell = rowById.get(it.id);
        if (!cell) return;
        // If auto-included, checkbox may be disabled; keep it checked.
        if (cell.cb.disabled) return;
        cell.cb.checked = v;
        if (v) setRef.add(it.id); else setRef.delete(it.id);
      });
      recompute();
    };

    group.appendChild(head);
    group.appendChild(list);

    return { group, rowById, chkAll, contentToggle, contentHint };
  }




  const container = document.createElement('div');
  container.className = 'importGrid';

  // Maps for quick lookups
  const personalTplById = new Map((snap.personalTemplates || []).map(t => [t.id, t]));
  const careerTplById = new Map((snap.careerTemplates || []).map(t => [t.id, t]));

  const personalContentByUser = new Map();
  for (const r of (snap.personalContent || [])) {
    if (!r || !r.userId || !r.templateId) continue;
    if (!String(r.content || '').trim()) continue; // A mode: only rows with content
    if (!personalContentByUser.has(r.userId)) personalContentByUser.set(r.userId, []);
    personalContentByUser.get(r.userId).push(r);
  }

  const careerContentByCareer = new Map();
  for (const r of (snap.careerContent || [])) {
    if (!r || !r.careerId || !r.templateId) continue;
    if (!String(r.content || '').trim()) continue; // A mode: only rows with content
    if (!careerContentByCareer.has(r.careerId)) careerContentByCareer.set(r.careerId, []);
    careerContentByCareer.get(r.careerId).push(r);
  }

  // Prompt + Connection groups keep the existing flat list UI
  const gPrompts = makeGroup('Prompt Items', snap.promptItems, x => x.title || '(Prompt)', sel.promptItems);
  const gConnections = makeGroup('Connections', snap.connections, x => x.title || '(Connection)', sel.connections);

  function makeOwnerAccordionGroup(opts) {
    const {
      title,
      owners,
      ownerLabel,
      ownerSelectedSet,
      contentByOwner,            // Map(ownerId -> contentRows)
      contentKeyOf,              // (ownerId, templateId) => string key
      contentSelectedSet,
      templateById,
      templateSelectedSet,
      dupOwnerTitlesSet,         // Set(normTitle(...)) for owner duplicates
      dupTemplateTitlesSet       // Set(normTitle(...)) for template duplicates
    } = opts;

    const group = document.createElement('div');
    group.className = 'importGroup';

    const head = document.createElement('div');
    head.className = 'importGroupHeader';

    const t = document.createElement('div');
    t.className = 'importGroupTitle';
    t.textContent = title;

    const controls = document.createElement('div');
    controls.className = 'importGroupControls';

    const btnExpand = btn('Expand', { onClick: () => detailsEls.forEach(d => d.open = true) });
    const btnCollapse = btn('Collapse', { onClick: () => detailsEls.forEach(d => d.open = false) });
    const btnAllOwners = btn('Select all', { onClick: () => {
      owners.forEach(o => ownerSelectedSet.add(o.id));
      // Select all content rows that are visible (has content)
      owners.forEach(o => {
        const rows = contentByOwner.get(o.id) || [];
        rows.forEach(r => {
          const k = contentKeyOf(o.id, r.templateId);
          contentSelectedSet.add(k);
          templateSelectedSet.add(r.templateId);
        });
      });
      syncOwnerUI();
      recompute();
    }});
    const btnNoneOwners = btn('Clear', { danger:true, onClick: () => {
      owners.forEach(o => ownerSelectedSet.delete(o.id));
      // Clear only content keys that belong to these owners
      for (const o of owners) {
        const rows = contentByOwner.get(o.id) || [];
        rows.forEach(r => contentSelectedSet.delete(contentKeyOf(o.id, r.templateId)));
      }
      syncOwnerUI();
      recompute();
    }});

    controls.appendChild(btnExpand);
    controls.appendChild(btnCollapse);
    controls.appendChild(btnAllOwners);
    controls.appendChild(btnNoneOwners);

    head.appendChild(t);
    head.appendChild(controls);

    const acc = document.createElement('div');
    acc.className = 'importAccordion';

    const detailsEls = [];
    const ownerUI = new Map(); // ownerId -> {cbOwner, rowCbs: Map(key -> cb)}

    function syncOwnerUI() {
      ownerUI.forEach((ui, ownerId) => {
        ui.cbOwner.checked = ownerSelectedSet.has(ownerId);
        ui.rowCbs.forEach((cb, key) => {
          cb.checked = contentSelectedSet.has(key);
        });
      });
    }

    owners.forEach(o => {
      const det = document.createElement('details');
      detailsEls.push(det);

      const sum = document.createElement('summary');

      const left = document.createElement('div');
      left.className = 'importAccSummaryLeft';

      const cbOwner = document.createElement('input');
      cbOwner.type = 'checkbox';
      cbOwner.checked = ownerSelectedSet.has(o.id);
      cbOwner.onchange = () => {
        if (cbOwner.checked) ownerSelectedSet.add(o.id);
        else {
          ownerSelectedSet.delete(o.id);
          // If owner is unchecked, clear its selected content keys
          const rows = contentByOwner.get(o.id) || [];
          rows.forEach(r => contentSelectedSet.delete(contentKeyOf(o.id, r.templateId)));
        }
        syncOwnerUI();
        recompute();
      };

      const name = document.createElement('div');
      name.className = 'importAccName';
      name.textContent = ownerLabel(o);

      // Inline duplicate badge (owner)
      if (dupOwnerTitlesSet && dupOwnerTitlesSet.has(normTitle(ownerLabel(o)))) {
        const b = document.createElement('span');
        b.className = 'pill warn';
        b.textContent = 'Duplicate';
        name.appendChild(b);
      }

      const rows = contentByOwner.get(o.id) || [];
      const counts = document.createElement('div');
      counts.className = 'importAccCounts';
      counts.textContent = `${rows.length} item${rows.length === 1 ? '' : 's'}`;

      left.appendChild(cbOwner);
      left.appendChild(name);
      left.appendChild(counts);

      sum.appendChild(left);
      det.appendChild(sum);

      const body = document.createElement('div');
      body.className = 'importAccBody';

      const tools = document.createElement('div');
      tools.className = 'importAccTools';

      const hint = document.createElement('div');
      hint.className = 'muted';
      hint.textContent = rows.length ? 'Select the items you want to import for this owner.' : 'No content items found in JSON for this owner.';

      const toolBtns = document.createElement('div');
      toolBtns.style.display = 'flex';
      toolBtns.style.gap = '8px';
      toolBtns.style.flexWrap = 'wrap';

      const btnAll = btn('All', { onClick: () => {
        ownerSelectedSet.add(o.id);
        rows.forEach(r => {
          const k = contentKeyOf(o.id, r.templateId);
          contentSelectedSet.add(k);
          templateSelectedSet.add(r.templateId);
        });
        syncOwnerUI();
        recompute();
      }});
      const btnNone = btn('None', { onClick: () => {
        rows.forEach(r => contentSelectedSet.delete(contentKeyOf(o.id, r.templateId)));
        syncOwnerUI();
        recompute();
      }});
      toolBtns.appendChild(btnAll);
      toolBtns.appendChild(btnNone);

      tools.appendChild(hint);
      tools.appendChild(toolBtns);

      body.appendChild(tools);

      const list = document.createElement('div');
      list.className = 'importRows';

      const rowCbs = new Map();

      // Sort by template title for readability
      rows.slice().sort((a,b) => {
        const at = (templateById.get(a.templateId)?.title || '').toLowerCase();
        const bt = (templateById.get(b.templateId)?.title || '').toLowerCase();
        return at.localeCompare(bt);
      }).forEach(r => {
        const tpl = templateById.get(r.templateId);
        const row = document.createElement('div');
        row.className = 'importRow';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        const key = contentKeyOf(o.id, r.templateId);
        cb.checked = contentSelectedSet.has(key);

        cb.onchange = () => {
          if (cb.checked) {
            ownerSelectedSet.add(o.id);
            contentSelectedSet.add(key);
            templateSelectedSet.add(r.templateId);
          } else {
            contentSelectedSet.delete(key);
          }
          syncOwnerUI();
          recompute();
        };

        const main = document.createElement('div');
        main.className = 'importMain';

        const tl = document.createElement('div');
        tl.className = 'importTitleLine';

        const titleDiv = document.createElement('div');
        titleDiv.className = 'importItemTitle';
        titleDiv.textContent = tpl?.title || '(Item)';

        tl.appendChild(titleDiv);

        // Inline duplicate badge (template title)
        if (dupTemplateTitlesSet && dupTemplateTitlesSet.has(normTitle(tpl?.title || ''))) {
          const bb = document.createElement('span');
          bb.className = 'pill warn';
          bb.textContent = 'Duplicate title';
          tl.appendChild(bb);
        }

        const meta = document.createElement('div');
        meta.className = 'importMeta';
        meta.textContent = `Last updated: ${fmtLocal(r.updatedAt || r.createdAt || '')} ¬∑ JSON`;

        main.appendChild(tl);
        main.appendChild(meta);

        row.appendChild(cb);
        row.appendChild(main);
        list.appendChild(row);
        rowCbs.set(key, cb);
      });

      body.appendChild(list);
      det.appendChild(body);

      acc.appendChild(det);
      ownerUI.set(o.id, { cbOwner, rowCbs });
    });

    group.appendChild(head);
    group.appendChild(acc);

    // Expose details nodes for controls
    group._detailsEls = detailsEls;

    return { group, detailsEls, syncOwnerUI };
  }

  // Duplicate sets
  const dupUserNames = new Set(snap.users.filter(u => existTitles.users.has(normTitle(u.name))).map(u => normTitle(u.name)));
  const dupCareerTitles = new Set(snap.careers.filter(c => existTitles.careers.has(normTitle(c.title))).map(c => normTitle(c.title)));
  const dupPTitles = new Set((snap.personalTemplates || []).filter(t => existTitles.personalTemplates.has(normTitle(t.title))).map(t => normTitle(t.title)));
  const dupCTitles = new Set((snap.careerTemplates || []).filter(t => existTitles.careerTemplates.has(normTitle(t.title))).map(t => normTitle(t.title)));

  const gUsersAcc = makeOwnerAccordionGroup({
    title: 'Users',
    owners: snap.users,
    ownerLabel: o => o.name || '(Unnamed)',
    ownerSelectedSet: sel.users,
    contentByOwner: personalContentByUser,
    contentKeyOf: (userId, templateId) => `${userId}::${templateId}`,
    contentSelectedSet: sel.personalContentKeys,
    templateById: personalTplById,
    templateSelectedSet: sel.personalTemplates,
    dupOwnerTitlesSet: dupUserNames,
    dupTemplateTitlesSet: dupPTitles
  });

  const gCareersAcc = makeOwnerAccordionGroup({
    title: 'Careers',
    owners: snap.careers,
    ownerLabel: o => o.title || '(Career)',
    ownerSelectedSet: sel.careers,
    contentByOwner: careerContentByCareer,
    contentKeyOf: (careerId, templateId) => `${careerId}::${templateId}`,
    contentSelectedSet: sel.careerContentKeys,
    templateById: careerTplById,
    templateSelectedSet: sel.careerTemplates,
    dupOwnerTitlesSet: dupCareerTitles,
    dupTemplateTitlesSet: dupCTitles
  });

  // Grid order
  container.appendChild(gUsersAcc.group);
  container.appendChild(gPrompts.group);
  container.appendChild(gCareersAcc.group);
  container.appendChild(gConnections.group);

  const footer = document.createElement('div');
  footer.className = 'importFooterFull';

  const note = document.createElement('div');
  note.className = 'hint';
  note.style.marginTop = '0px';
  // Hidden by default: Connection imports only depend on titles; content is optional.
  note.textContent = '';
  note.style.display = 'none';
  footer.appendChild(note);

  const warnWrap = document.createElement('div');
  warnWrap.className = 'importGroup';
  warnWrap.style.marginTop = '12px';
  warnWrap.innerHTML = `<div style="font-weight:700;">Warnings (non-blocking)</div>`;
  warnWrap.appendChild(warningsEl);
  footer.appendChild(warnWrap);

  container.appendChild(footer);

  function recompute() {
    // Reset auto sets
    auto.promptItems.clear();
    auto.personalTemplates.clear();
    auto.careerTemplates.clear();

    // Auto include dependencies for selected connections
    const connById = new Map(snap.connections.map(c => [c.id, c]));
    sel.connections.forEach(cid => {
      const c = connById.get(cid);
      if (!c) return;
      (c.promptItemIds || []).forEach(id => { if (!sel.promptItems.has(id)) auto.promptItems.add(id); });
      // Note: Connection dependencies only auto-include prompt items.
      // Personal/Career *titles* referenced by a Connection are ensured during import; content is optional.
    });

    // Apply auto includes for prompts (UI check + disable)
    function applyAuto(group, setSel, setAuto) {
      group.rowById.forEach((cell, id) => {
        if (setAuto.has(id)) {
          cell.cb.checked = true;
          cell.cb.disabled = true;
          setSel.add(id);
          cell.row.classList.add('auto');
          cell.row.title = 'Auto-included by selected Connection(s)';
          upsertBadge(cell.badgeSlot, 'auto', 'Auto', 'ok');
        } else {
          cell.cb.disabled = false;
          cell.row.classList.remove('auto');
          cell.row.title = '';
          upsertBadge(cell.badgeSlot, 'auto', null);
        }
      });
    }
    applyAuto(gPrompts, sel.promptItems, auto.promptItems);

    // Content flags
    sel.includePersonalContent = (sel.personalContentKeys && sel.personalContentKeys.size > 0);
    sel.includeCareerContent = (sel.careerContentKeys && sel.careerContentKeys.size > 0);

    // User‚ÜîCareer mapping only makes sense if both are imported
    const usersSelected = sel.users.size > 0;
    const careersSelected = sel.careers.size > 0;
    sel.includeUserCareer = usersSelected && careersSelected;

    // Keep accordion UI synced
    gUsersAcc.syncOwnerUI();
    gCareersAcc.syncOwnerUI();

    // Inline warnings for prompts + connections
    const dupPromptsAll = new Set(snap.promptItems.filter(p => existTitles.promptItems.has(normTitle(p.title))).map(p => p.id));
    const dupConnsAll = new Set(snap.connections.filter(c => existTitles.connections.has(normTitle(c.title))).map(c => c.id));
    function markWarn(group, ids, label, variant='warn'){
      group.rowById.forEach((cell, id) => {
        upsertBadge(cell.badgeSlot, 'warn', ids.has(id) ? label : null, variant);
      });
    }
    markWarn(gPrompts, dupPromptsAll, 'Duplicate title', 'warn');
    markWarn(gConnections, dupConnsAll, 'Duplicate title', 'warn');

    // Duplicate time comparison (Local vs JSON) for duplicates
    setDupTimesForGroup(gPrompts, dupPromptsAll, localBy.promptItems, x => x.title || '');
    setDupTimesForGroup(gConnections, dupConnsAll, localBy.connections, x => x.title || '');

    // Warnings summary (non-blocking)
    const warnings = [];

    // Auto include summary
    const autoMsgs = [];
    if (auto.promptItems.size) autoMsgs.push(`Auto-included prompt items: ${auto.promptItems.size}`);
    if (autoMsgs.length) warnings.push(autoMsgs.join(' ¬∑ '));

    // Duplicate top-level entities
    const dupUsers = snap.users.filter(u => sel.users.has(u.id) && existTitles.users.has(normTitle(u.name)));
    if (dupUsers.length) warnings.push(`Users with duplicate name: ${dupUsers.map(u => u.name).slice(0,8).join(', ')}${dupUsers.length>8?'‚Ä¶':''}`);

    const dupCareers = snap.careers.filter(c => sel.careers.has(c.id) && existTitles.careers.has(normTitle(c.title)));
    if (dupCareers.length) warnings.push(`Careers with duplicate title: ${dupCareers.map(c => c.title).slice(0,8).join(', ')}${dupCareers.length>8?'‚Ä¶':''}`);

    const dupPrompts = snap.promptItems.filter(p => sel.promptItems.has(p.id) && existTitles.promptItems.has(normTitle(p.title)));
    if (dupPrompts.length) warnings.push(`Prompt items with duplicate title: ${dupPrompts.map(p => p.title).slice(0,8).join(', ')}${dupPrompts.length>8?'‚Ä¶':''}`);

    const dupConns = snap.connections.filter(c => sel.connections.has(c.id) && existTitles.connections.has(normTitle(c.title)));
    if (dupConns.length) warnings.push(`Connections with duplicate title: ${dupConns.map(c => c.title).slice(0,8).join(', ')}${dupConns.length>8?'‚Ä¶':''}`);

    // Template duplicates (selected)
    const dupPT = (snap.personalTemplates || []).filter(t => sel.personalTemplates.has(t.id) && existTitles.personalTemplates.has(normTitle(t.title)));
    if (dupPT.length) warnings.push(`Personal item titles duplicated: ${dupPT.map(t => t.title).slice(0,8).join(', ')}${dupPT.length>8?'‚Ä¶':''}`);

    const dupCT = (snap.careerTemplates || []).filter(t => sel.careerTemplates.has(t.id) && existTitles.careerTemplates.has(normTitle(t.title)));
    if (dupCT.length) warnings.push(`Career item titles duplicated: ${dupCT.map(t => t.title).slice(0,8).join(', ')}${dupCT.length>8?'‚Ä¶':''}`);

    warningsEl.innerHTML = warnings.length ? ('‚Ä¢ ' + warnings.join('<br>‚Ä¢ ')) : '<span class="muted">No warnings.</span>';
  }

  recompute();

  const headerBtns = [
    btn('Select all', { mini:true, onClick: () => {
      try {
        // Owners
        sel.users.clear(); (snap.users || []).forEach(u => sel.users.add(u.id));
        sel.careers.clear(); (snap.careers || []).forEach(c => sel.careers.add(c.id));

        // Prompts + Connections
        sel.promptItems.clear(); (snap.promptItems || []).forEach(p => sel.promptItems.add(p.id));
        sel.connections.clear(); (snap.connections || []).forEach(c => sel.connections.add(c.id));

        // Templates
        sel.personalTemplates.clear(); (snap.personalTemplates || []).forEach(t => sel.personalTemplates.add(t.id));
        sel.careerTemplates.clear(); (snap.careerTemplates || []).forEach(t => sel.careerTemplates.add(t.id));

        // Content keys
        sel.personalContentKeys.clear();
        personalContentByUser.forEach((rows, ownerId) => {
          (rows || []).forEach(r => {
            sel.personalContentKeys.add(`${ownerId}::${r.templateId}`);
            sel.personalTemplates.add(r.templateId);
          });
        });

        sel.careerContentKeys.clear();
        careerContentByCareer.forEach((rows, ownerId) => {
          (rows || []).forEach(r => {
            sel.careerContentKeys.add(`${ownerId}::${r.templateId}`);
            sel.careerTemplates.add(r.templateId);
          });
        });

        // Sync flat group UI
        gPrompts.rowById.forEach(cell => { cell.cb.checked = true; });
        gPrompts.chkAll.checked = true;
        gConnections.rowById.forEach(cell => { cell.cb.checked = true; });
        gConnections.chkAll.checked = true;

        // Sync accordion UIs
        gUsersAcc.syncOwnerUI();
        gCareersAcc.syncOwnerUI();

        recompute();
      } catch (e) {
        console.error(e);
        toast('Select all failed: ' + (e?.message || String(e)));
      }
    }}),
    btn('Unselect all', { mini:true, danger:true, onClick: () => {
      try {
        sel.users.clear();
        sel.careers.clear();
        sel.promptItems.clear();
        sel.connections.clear();
        sel.personalTemplates.clear();
        sel.careerTemplates.clear();
        sel.personalContentKeys.clear();
        sel.careerContentKeys.clear();

        gPrompts.rowById.forEach(cell => { cell.cb.checked = false; cell.cb.disabled = false; });
        gPrompts.chkAll.checked = false;
        gConnections.rowById.forEach(cell => { cell.cb.checked = false; cell.cb.disabled = false; });
        gConnections.chkAll.checked = false;

        gUsersAcc.syncOwnerUI();
        gCareersAcc.syncOwnerUI();

        recompute();
      } catch (e) {
        console.error(e);
        toast('Unselect all failed: ' + (e?.message || String(e)));
      }
    }})
  ];

  const footerButtons = [

    btn('Replace selected', { danger:true, onClick: async () => {
      const ok = confirm('Replace selected will update only the items you checked. If a local item with the same title or name exists, it will be overwritten with the JSON content. If it does not exist locally, it will be added as a new item. Unselected local items are not changed. Continue?');
      if (!ok) return;
      try {
        await importSnapshotSelectionReplaceOverwrite(snap, sel);
        closeModal();
        toast('Replace import completed');
        await refreshAll();
        finalizeOnlineImportMeta();
      } catch (e) {
        console.error(e);
        toast('Replace import failed: ' + (e?.message || String(e)));
      }
    }}),
    btn('Add to local selected', { primary:true, onClick: async () => {
      try {
        await importSnapshotSelectionAddToLocal(snap, sel);
        closeModal();
        toast('Add to local import completed');
        await refreshAll();
        finalizeOnlineImportMeta();
      } catch (e) {
        console.error(e);
        toast('Add to local import failed: ' + (e?.message || String(e)));
      }
    }})
  ];

  openModal('Import Snapshot', container, footerButtons, headerBtns, { kind: 'import' });
}



async function importSnapshotSelectionAddToLocal(snap, sel) {
  const now = nowISO();

  // Defensive defaults (older callers)
  sel = sel || {};
  sel.users = sel.users || new Set();
  sel.careers = sel.careers || new Set();
  sel.promptItems = sel.promptItems || new Set();
  sel.connections = sel.connections || new Set();
  sel.personalTemplates = sel.personalTemplates || new Set();
  sel.careerTemplates = sel.careerTemplates || new Set();
  sel.personalContentKeys = sel.personalContentKeys || new Set();
  sel.careerContentKeys = sel.careerContentKeys || new Set();

  // Setup Categories: always import if present (best effort)
  try {
    const cats = Array.isArray(snap.setupCategories) ? snap.setupCategories : [];
    if (cats.length) {
      const db = await openDB();
      if (db.objectStoreNames.contains('setupCategories')) {
        const tx = db.transaction('setupCategories', 'readwrite');
        const st = tx.objectStore('setupCategories');
        cats.forEach(c => st.put(c));
        await txComplete(tx);
      }
    }
  } catch (err) { /* best effort */ }

  // Ensure templates referenced by selected connections are included (so connections can be reconstructed)
  try {
    const needPT = new Set();
    const needCT = new Set();
    for (const c of (snap.connections || [])) {
      if (!sel.connections || !sel.connections.has(c.id)) continue;
      (c.personalTemplateIds || []).forEach(id => needPT.add(id));
      (c.careerTemplateIds || []).forEach(id => needCT.add(id));
    }
    needPT.forEach(id => sel.personalTemplates.add(id));
    needCT.forEach(id => sel.careerTemplates.add(id));
  } catch {}

  // Load local data for merge-by-title/name behavior
  const localUsers = await getAll('users');
  const localCareers = await getAll('careers');
  const localPrompts = await getAll('promptItems');
  const localPT = await getAll('personalTemplates');
  const localCT = await getAll('careerTemplates');
  const localConns = await getAll('connections');

  const by = {
    users: new Map(localUsers.map(u => [normTitle(u.name), u])),
    careers: new Map(localCareers.map(c => [normTitle(c.title), c])),
    promptItems: new Map(localPrompts.map(p => [normTitle(p.title), p])),
    personalTemplates: new Map(localPT.map(t => [normTitle(t.title), t])),
    careerTemplates: new Map(localCT.map(t => [normTitle(t.title), t])),
    connections: new Map(localConns.map(c => [normTitle(c.title), c]))
  };

  // Title sets for unique naming where we intentionally create duplicates (prompts/connections)
  const titleSets = {
    users: new Set(localUsers.map(u => normTitle(u.name))),
    careers: new Set(localCareers.map(c => normTitle(c.title))),
    promptItems: new Set(localPrompts.map(p => normTitle(p.title))),
    personalTemplates: new Set(localPT.map(t => normTitle(t.title))),
    careerTemplates: new Set(localCT.map(t => normTitle(t.title))),
    connections: new Set(localConns.map(c => normTitle(c.title)))
  };

  // Snapshot lookups
  const snapBy = {
    users: new Map((snap.users || []).map(u => [u.id, u])),
    careers: new Map((snap.careers || []).map(c => [c.id, c])),
    personalTemplates: new Map((snap.personalTemplates || []).map(t => [t.id, t])),
    careerTemplates: new Map((snap.careerTemplates || []).map(t => [t.id, t]))
  };

  // Old -> local/new IDs (merge-aware)
  const idMap = {
    users: new Map(),
    careers: new Map(),
    promptItems: new Map(),
    personalTemplates: new Map(),
    careerTemplates: new Map(),
    connections: new Map()
  };

  function makeImportedTitle(raw, set) {
    const base = (raw || '').trim() || 'Untitled';
    let i = 1;
    let cand = `${base} (Imported)`;
    while (set.has(normTitle(cand))) {
      i += 1;
      cand = `${base} (Imported ${i})`;
    }
    set.add(normTitle(cand));
    return cand;
  }

  
  async function ensurePromptItemForConnection(oldPromptId) {
    if (!oldPromptId) return null;
    if (idMap.promptItems.has(oldPromptId)) return idMap.promptItems.get(oldPromptId);

    const p = snapBy.promptItems.get(oldPromptId);
    if (!p) return null;

    const key = normTitle(p.title);
    const existing = by.promptItems.get(key);
    if (existing) {
      idMap.promptItems.set(oldPromptId, existing.id);
      return existing.id;
    }

    // Create only if it truly doesn't exist locally
    const newId = uid();
    const titleRaw = (p.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.promptItems.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.promptItems)
      : (titleSets.promptItems.add(normTitle(titleRaw)), titleRaw);

    const row = { ...p, id: newId, title: finalTitle, createdAt: p.createdAt || now, updatedAt: p.updatedAt || p.createdAt || now };
    await putOne('promptItems', row);
    by.promptItems.set(normTitle(finalTitle), row);
    idMap.promptItems.set(oldPromptId, newId);
    return newId;
  }

async function ensurePersonalTemplate(oldTplId) {
    if (!oldTplId) return null;
    if (idMap.personalTemplates.has(oldTplId)) return idMap.personalTemplates.get(oldTplId);

    const tpl = snapBy.personalTemplates.get(oldTplId);
    if (!tpl) return null;

    const key = normTitle(tpl.title);
    const existing = by.personalTemplates.get(key);
    if (existing) {
      idMap.personalTemplates.set(oldTplId, existing.id);
      return existing.id;
    }

    // Create only if it truly doesn't exist locally
    const newId = uid();
    const titleRaw = (tpl.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.personalTemplates.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.personalTemplates)
      : (titleSets.personalTemplates.add(normTitle(titleRaw)), titleRaw);

    const row = { ...tpl, id: newId, title: finalTitle, createdAt: tpl.createdAt || now, updatedAt: tpl.updatedAt || tpl.createdAt || now };
    await putOne('personalTemplates', row);
    by.personalTemplates.set(normTitle(finalTitle), row);
    idMap.personalTemplates.set(oldTplId, newId);
    return newId;
  }

  async function ensureCareerTemplate(oldTplId) {
    if (!oldTplId) return null;
    if (idMap.careerTemplates.has(oldTplId)) return idMap.careerTemplates.get(oldTplId);

    const tpl = snapBy.careerTemplates.get(oldTplId);
    if (!tpl) return null;

    const key = normTitle(tpl.title);
    const existing = by.careerTemplates.get(key);
    if (existing) {
      idMap.careerTemplates.set(oldTplId, existing.id);
      return existing.id;
    }

    const newId = uid();
    const titleRaw = (tpl.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.careerTemplates.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.careerTemplates)
      : (titleSets.careerTemplates.add(normTitle(titleRaw)), titleRaw);

    const row = { ...tpl, id: newId, title: finalTitle, createdAt: tpl.createdAt || now, updatedAt: tpl.updatedAt || tpl.createdAt || now };
    await putOne('careerTemplates', row);
    by.careerTemplates.set(normTitle(finalTitle), row);
    idMap.careerTemplates.set(oldTplId, newId);
    return newId;
  }

  function mapUserId(oldUserId) {
    if (!oldUserId) return null;
    const m = idMap.users.get(oldUserId);
    if (m) return m;
    const u = snapBy.users.get(oldUserId);
    if (!u) return null;
    const ex = by.users.get(normTitle(u.name));
    return ex ? ex.id : null;
  }

  function mapCareerId(oldCareerId) {
    if (!oldCareerId) return null;
    const m = idMap.careers.get(oldCareerId);
    if (m) return m;
    const c = snapBy.careers.get(oldCareerId);
    if (!c) return null;
    const ex = by.careers.get(normTitle(c.title));
    return ex ? ex.id : null;
  }

  // 1) Users (merge by name; avoid duplicates)
  for (const u of (snap.users || [])) {
    if (!sel.users || !sel.users.has(u.id)) continue;
    const key = normTitle(u.name);
    const existing = by.users.get(key);
    if (existing) {
      idMap.users.set(u.id, existing.id);
      continue;
    }
    const newId = uid();
    idMap.users.set(u.id, newId);
    const nameRaw = (u.name || '').trim() || 'Untitled';
    const finalName = titleSets.users.has(normTitle(nameRaw))
      ? makeImportedTitle(nameRaw, titleSets.users)
      : (titleSets.users.add(normTitle(nameRaw)), nameRaw);
    const row = { ...u, id: newId, name: finalName, createdAt: u.createdAt || now, updatedAt: u.updatedAt || u.createdAt || now };
    await putOne('users', row);
    by.users.set(normTitle(finalName), row);
  }

  // 2) Careers (merge by title; avoid duplicates)
  for (const c of (snap.careers || [])) {
    if (!sel.careers || !sel.careers.has(c.id)) continue;
    const key = normTitle(c.title);
    const existing = by.careers.get(key);
    if (existing) {
      idMap.careers.set(c.id, existing.id);
      continue;
    }
    const newId = uid();
    idMap.careers.set(c.id, newId);
    const titleRaw = (c.title || '').trim() || 'Untitled';
    const finalTitle = titleSets.careers.has(normTitle(titleRaw))
      ? makeImportedTitle(titleRaw, titleSets.careers)
      : (titleSets.careers.add(normTitle(titleRaw)), titleRaw);
    const row = { ...c, id: newId, title: finalTitle, createdAt: c.createdAt || now, updatedAt: c.updatedAt || c.createdAt || now };
    await putOne('careers', row);
    by.careers.set(normTitle(finalTitle), row);
  }

  // 3) Prompt items (allow duplicates by renaming)
  for (const p of (snap.promptItems || [])) {
    if (!sel.promptItems || !sel.promptItems.has(p.id)) continue;
    const newId = uid();
    idMap.promptItems.set(p.id, newId);
    const title = titleSets.promptItems.has(normTitle(p.title))
      ? makeImportedTitle(p.title, titleSets.promptItems)
      : (titleSets.promptItems.add(normTitle(p.title)), (p.title || '').trim() || 'Untitled');
    await putOne('promptItems', { ...p, id: newId, title, createdAt: p.createdAt || now, updatedAt: p.updatedAt || p.createdAt || now });
  }

  // 4) Personal templates (merge by title; avoid duplicates)
  for (const t of (snap.personalTemplates || [])) {
    if (!sel.personalTemplates || !sel.personalTemplates.has(t.id)) continue;
    await ensurePersonalTemplate(t.id);
  }

  // 5) Career templates (merge by title; avoid duplicates)
  for (const t of (snap.careerTemplates || [])) {
    if (!sel.careerTemplates || !sel.careerTemplates.has(t.id)) continue;
    await ensureCareerTemplate(t.id);
  }

  // 6) Personal content (map to merged users/templates; overwrite same key)
  if (sel.personalContentKeys && sel.personalContentKeys.size) {
    for (const r of (snap.personalContent || [])) {
      const _k = `${r.userId}::${r.templateId}`;
      if (!sel.personalContentKeys.has(_k)) continue;

      const userNew = mapUserId(r.userId);
      if (!userNew) continue;

      const tplNew = await ensurePersonalTemplate(r.templateId);
      if (!tplNew) continue;

      await putOne('personalContent', {
        ...r,
        userId: userNew,
        templateId: tplNew,
        content: r.content || '',
        createdAt: r.createdAt || now,
        updatedAt: r.updatedAt || r.createdAt || now
      });
    }
  }

  // 7) Career content (map to merged careers/templates; overwrite same key)
  if (sel.careerContentKeys && sel.careerContentKeys.size) {
    for (const r of (snap.careerContent || [])) {
      const _k = `${r.careerId}::${r.templateId}`;
      if (!sel.careerContentKeys.has(_k)) continue;

      const careerNew = mapCareerId(r.careerId);
      if (!careerNew) continue;

      const tplNew = await ensureCareerTemplate(r.templateId);
      if (!tplNew) continue;

      await putOne('careerContent', {
        ...r,
        careerId: careerNew,
        templateId: tplNew,
        content: r.content || '',
        createdAt: r.createdAt || now,
        updatedAt: r.updatedAt || r.createdAt || now
      });
    }
  }

  // 8) User -> Career mapping (optional, merge-aware)
  if (sel.includeUserCareer) {
    for (const r of (snap.userCareer || [])) {
      const userNew = mapUserId(r.userId);
      const careerNew = mapCareerId(r.careerId);
      if (!userNew || !careerNew) continue;
      await putOne('userCareer', { ...r, userId: userNew, careerId: careerNew });
    }
  }

  // 9) Connections (allow duplicates by renaming; map referenced IDs)
  for (const c of (snap.connections || [])) {
    if (!sel.connections || !sel.connections.has(c.id)) continue;
    const newId = uid();
    idMap.connections.set(c.id, newId);

    const title = titleSets.connections.has(normTitle(c.title))
      ? makeImportedTitle(c.title, titleSets.connections)
      : (titleSets.connections.add(normTitle(c.title)), (c.title || '').trim() || 'Untitled');

        const promptItemIds = [];
    for (const pid of (c.promptItemIds || [])) {
      const mapped = await ensurePromptItemForConnection(pid);
      if (mapped) promptItemIds.push(mapped);
    }

    const personalTemplateIds = [];
    for (const tid of (c.personalTemplateIds || [])) {
      const mapped = await ensurePersonalTemplate(tid);
      if (mapped) personalTemplateIds.push(mapped);
    }

    const careerTemplateIds = [];
    for (const tid of (c.careerTemplateIds || [])) {
      const mapped = await ensureCareerTemplate(tid);
      if (mapped) careerTemplateIds.push(mapped);
    }

    await putOne('connections', {
      ...c,
      id: newId,
      title,
      promptItemIds,
      personalTemplateIds,
      careerTemplateIds,
      createdAt: c.createdAt || now,
      updatedAt: c.updatedAt || c.createdAt || now
    });
  }
  // Fix template output‚Üîconnection links when imported connections get new IDs.
  // We first try id remapping via idMap.connections (best for Add mode), then fall back to title matching.
  const _connsNow = await getAll('connections');
  const _connByTitleNow = new Map((_connsNow || []).map(c => [normTitle(c.title), c]));

  async function _fixTemplateOutputLinks(storeName, snapArr, selSet, tplIdMap) {
    for (const t of (snapArr || [])) {
      if (!selSet || !selSet.has(t.id)) continue;
      const newTplId = tplIdMap.get(t.id);
      if (!newTplId) continue;

      const rec = await getOne(storeName, newTplId);
      if (!rec) continue;
      if (rec.isOutput === false) continue;

      const oldConnId = String(rec.outputConnectionId || '');
      let resolved = '';

      if (oldConnId && idMap.connections && idMap.connections.has(oldConnId)) {
        resolved = idMap.connections.get(oldConnId);
      }

      if (!resolved) {
        const title = String(rec.outputConnectionTitle || t.outputConnectionTitle || '');
        if (title) {
          const hit = _connByTitleNow.get(normTitle(title));
          if (hit) resolved = hit.id;
        }
      }

      if (resolved && resolved !== rec.outputConnectionId) {
        await putOne(storeName, { ...rec, outputConnectionId: resolved, updatedAt: nowISO() });
      }
    }
  }

  await _fixTemplateOutputLinks('personalTemplates', snap.personalTemplates, sel.personalTemplates, idMap.personalTemplates);
  await _fixTemplateOutputLinks('careerTemplates', snap.careerTemplates, sel.careerTemplates, idMap.careerTemplates);

}
async function importSnapshotSelectionReplaceOverwrite(snap, sel) {
  const now = nowISO();
  const idMap = {
    users: new Map(),
    careers: new Map(),
    promptItems: new Map(),
    personalTemplates: new Map(),
    careerTemplates: new Map(),
    connections: new Map()
  };

  // Local lookups by title/name (normalized)
  const localUsers = await getAll('users');
  const localCareers = await getAll('careers');
  const localPrompts = await getAll('promptItems');
  const localPT = await getAll('personalTemplates');
  const localCT = await getAll('careerTemplates');
  const localConns = await getAll('connections');

  const by = {
    users: new Map(localUsers.map(u => [normTitle(u.name), u])),
    careers: new Map(localCareers.map(c => [normTitle(c.title), c])),
    promptItems: new Map(localPrompts.map(p => [normTitle(p.title), p])),
    personalTemplates: new Map(localPT.map(t => [normTitle(t.title), t])),
    careerTemplates: new Map(localCT.map(t => [normTitle(t.title), t])),
    connections: new Map(localConns.map(c => [normTitle(c.title), c])),
  };

  async function ensureUniqueId(storeName, proposedId) {
    const found = await getOne(storeName, proposedId);
    if (!found) return proposedId;
    return uid();
  }

  function keepCreated(local, incoming) {
    return local?.createdAt || incoming?.createdAt || now;
  }

  // 1) Users (match by name)
  for (const u of snap.users) {
    if (!sel.users.has(u.id)) continue;
    const key = normTitle(u.name);
    const local = by.users.get(key);
    if (local) {
      const id = local.id;
      idMap.users.set(u.id, id);
      await putOne('users', { ...local, ...u, id, name: u.name, createdAt: keepCreated(local, u), updatedAt: u.updatedAt || now });
    } else {
      const id = await ensureUniqueId('users', u.id);
      idMap.users.set(u.id, id);
      await putOne('users', { ...u, id, createdAt: u.createdAt || now, updatedAt: u.updatedAt || now });
      by.users.set(key, { ...u, id });
    }
  }

  // 2) Careers (match by title)
  for (const c of snap.careers) {
    if (!sel.careers.has(c.id)) continue;
    const key = normTitle(c.title);
    const local = by.careers.get(key);
    if (local) {
      const id = local.id;
      idMap.careers.set(c.id, id);
      await putOne('careers', { ...local, ...c, id, title: c.title, createdAt: keepCreated(local, c), updatedAt: c.updatedAt || now });
    } else {
      const id = await ensureUniqueId('careers', c.id);
      idMap.careers.set(c.id, id);
      await putOne('careers', { ...c, id, createdAt: c.createdAt || now, updatedAt: c.updatedAt || now });
      by.careers.set(key, { ...c, id });
    }
  }

  // 3) Prompt items (match by title)
  for (const p of snap.promptItems) {
    if (!sel.promptItems.has(p.id)) continue;
    const key = normTitle(p.title);
    const local = by.promptItems.get(key);
    if (local) {
      const id = local.id;
      idMap.promptItems.set(p.id, id);
      await putOne('promptItems', { ...local, ...p, id, title: p.title, createdAt: keepCreated(local, p), updatedAt: p.updatedAt || now });
    } else {
      const id = await ensureUniqueId('promptItems', p.id);
      idMap.promptItems.set(p.id, id);
      await putOne('promptItems', { ...p, id, createdAt: p.createdAt || now, updatedAt: p.updatedAt || now });
      by.promptItems.set(key, { ...p, id });
    }
  }

  // 4) Personal templates (match by title)
  for (const t of snap.personalTemplates) {
    if (!sel.personalTemplates.has(t.id)) continue;
    const key = normTitle(t.title);
    const local = by.personalTemplates.get(key);
    if (local) {
      const id = local.id;
      idMap.personalTemplates.set(t.id, id);
      await putOne('personalTemplates', { ...local, ...t, id, title: t.title, createdAt: keepCreated(local, t), updatedAt: t.updatedAt || now });
    } else {
      const id = await ensureUniqueId('personalTemplates', t.id);
      idMap.personalTemplates.set(t.id, id);
      await putOne('personalTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || now });
      by.personalTemplates.set(key, { ...t, id });
    }
  }

  // 5) Career templates (match by title)
  for (const t of snap.careerTemplates) {
    if (!sel.careerTemplates.has(t.id)) continue;
    const key = normTitle(t.title);
    const local = by.careerTemplates.get(key);
    if (local) {
      const id = local.id;
      idMap.careerTemplates.set(t.id, id);
      await putOne('careerTemplates', { ...local, ...t, id, title: t.title, createdAt: keepCreated(local, t), updatedAt: t.updatedAt || now });
    } else {
      const id = await ensureUniqueId('careerTemplates', t.id);
      idMap.careerTemplates.set(t.id, id);
      await putOne('careerTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || now });
      by.careerTemplates.set(key, { ...t, id });
    }
  }

  // 6) Personal content (only selected rows, and only for imported users + imported templates)
  if (sel.personalContentKeys && sel.personalContentKeys.size) {
    for (const r of snap.personalContent) {
      const _k = `${r.userId}::${r.templateId}`;
      if (!sel.personalContentKeys.has(_k)) continue;
      const userNew = idMap.users.get(r.userId);
      if (!userNew) continue;
      const tplNew = idMap.personalTemplates.get(r.templateId);
      if (!tplNew) continue;
      await putOne('personalContent', { ...r, userId: userNew, templateId: tplNew, createdAt: r.createdAt || now, updatedAt: r.updatedAt || now });
    }
  }

  // 7) Career content (only selected rows, and only for imported careers + imported templates)
  if (sel.careerContentKeys && sel.careerContentKeys.size) {
    for (const r of snap.careerContent) {
      const _k = `${r.careerId}::${r.templateId}`;
      if (!sel.careerContentKeys.has(_k)) continue;
      const careerNew = idMap.careers.get(r.careerId);
      if (!careerNew) continue;
      const tplNew = idMap.careerTemplates.get(r.templateId);
      if (!tplNew) continue;
      await putOne('careerContent', { ...r, careerId: careerNew, templateId: tplNew, createdAt: r.createdAt || now, updatedAt: r.updatedAt || now });
    }
  }

  // 8) User -> Career mapping (optional)
  if (sel.includeUserCareer) {
    for (const r of snap.userCareer || []) {
      const userNew = idMap.users.get(r.userId);
      const careerNew = idMap.careers.get(r.careerId);
      if (!userNew || !careerNew) continue;
      await putOne('userCareer', { ...r, userId: userNew, careerId: careerNew, updatedAt: r.updatedAt || now });
    }
  }

  
  // Snapshot lookups for dependency resolution (Connections)
  const snapBy = {
    promptItems: new Map((snap.promptItems || []).map(p => [p.id, p])),
    personalTemplates: new Map((snap.personalTemplates || []).map(t => [t.id, t])),
    careerTemplates: new Map((snap.careerTemplates || []).map(t => [t.id, t])),
  };

  async function ensurePromptItemForConnection(oldId) {
    if (!oldId) return null;
    if (idMap.promptItems.has(oldId)) return idMap.promptItems.get(oldId);

    const p = snapBy.promptItems.get(oldId);
    if (!p) return null;

    const key = normTitle(p.title);
    const local = by.promptItems.get(key);
    if (local) {
      idMap.promptItems.set(oldId, local.id);
      return local.id;
    }

    const id = await ensureUniqueId('promptItems', p.id);
    idMap.promptItems.set(oldId, id);
    await putOne('promptItems', { ...p, id, createdAt: p.createdAt || now, updatedAt: p.updatedAt || p.createdAt || now });
    by.promptItems.set(key, { ...p, id });
    return id;
  }

  async function ensurePersonalTemplateForConnection(oldId) {
    if (!oldId) return null;
    if (idMap.personalTemplates.has(oldId)) return idMap.personalTemplates.get(oldId);

    const t = snapBy.personalTemplates.get(oldId);
    if (!t) return null;

    const key = normTitle(t.title);
    const local = by.personalTemplates.get(key);
    if (local) {
      idMap.personalTemplates.set(oldId, local.id);
      return local.id;
    }

    const id = await ensureUniqueId('personalTemplates', t.id);
    idMap.personalTemplates.set(oldId, id);
    await putOne('personalTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || t.createdAt || now });
    by.personalTemplates.set(key, { ...t, id });
    return id;
  }

  async function ensureCareerTemplateForConnection(oldId) {
    if (!oldId) return null;
    if (idMap.careerTemplates.has(oldId)) return idMap.careerTemplates.get(oldId);

    const t = snapBy.careerTemplates.get(oldId);
    if (!t) return null;

    const key = normTitle(t.title);
    const local = by.careerTemplates.get(key);
    if (local) {
      idMap.careerTemplates.set(oldId, local.id);
      return local.id;
    }

    const id = await ensureUniqueId('careerTemplates', t.id);
    idMap.careerTemplates.set(oldId, id);
    await putOne('careerTemplates', { ...t, id, createdAt: t.createdAt || now, updatedAt: t.updatedAt || t.createdAt || now });
    by.careerTemplates.set(key, { ...t, id });
    return id;
  }

// 9) Connections (match by title, rewrite referenced IDs)
  for (const c of snap.connections) {
    if (!sel.connections.has(c.id)) continue;

    const promptItemIds = [];
    for (const pid of (c.promptItemIds || [])) {
      const mapped = await ensurePromptItemForConnection(pid);
      if (mapped) promptItemIds.push(mapped);
    }

    const personalTemplateIds = [];
    for (const tid of (c.personalTemplateIds || [])) {
      const mapped = await ensurePersonalTemplateForConnection(tid);
      if (mapped) personalTemplateIds.push(mapped);
    }

    const careerTemplateIds = [];
    for (const tid of (c.careerTemplateIds || [])) {
      const mapped = await ensureCareerTemplateForConnection(tid);
      if (mapped) careerTemplateIds.push(mapped);
    }

    const key = normTitle(c.title);
    const local = by.connections.get(key);

    if (local) {
      const id = local.id;
      idMap.connections.set(c.id, id);
      await putOne('connections', {
        ...local,
        ...c,
        id,
        title: c.title,
        promptItemIds,
        personalTemplateIds,
        careerTemplateIds,
        createdAt: keepCreated(local, c),
        updatedAt: c.updatedAt || now
      });
    } else {
      const id = await ensureUniqueId('connections', c.id);
      idMap.connections.set(c.id, id);
      await putOne('connections', {
        ...c,
        id,
        title: c.title,
        promptItemIds,
        personalTemplateIds,
        careerTemplateIds,
        createdAt: c.createdAt || now,
        updatedAt: c.updatedAt || now
      });
      by.connections.set(key, { ...c, id });
    }
  }
  // Fix template output‚Üîconnection links when imported connections get new IDs.
  // We first try id remapping via idMap.connections (best for Add mode), then fall back to title matching.
  const _connsNow = await getAll('connections');
  const _connByTitleNow = new Map((_connsNow || []).map(c => [normTitle(c.title), c]));

  async function _fixTemplateOutputLinks(storeName, snapArr, selSet, tplIdMap) {
    for (const t of (snapArr || [])) {
      if (!selSet || !selSet.has(t.id)) continue;
      const newTplId = tplIdMap.get(t.id);
      if (!newTplId) continue;

      const rec = await getOne(storeName, newTplId);
      if (!rec) continue;
      if (rec.isOutput === false) continue;

      const oldConnId = String(rec.outputConnectionId || '');
      let resolved = '';

      if (oldConnId && idMap.connections && idMap.connections.has(oldConnId)) {
        resolved = idMap.connections.get(oldConnId);
      }

      if (!resolved) {
        const title = String(rec.outputConnectionTitle || t.outputConnectionTitle || '');
        if (title) {
          const hit = _connByTitleNow.get(normTitle(title));
          if (hit) resolved = hit.id;
        }
      }

      if (resolved && resolved !== rec.outputConnectionId) {
        await putOne(storeName, { ...rec, outputConnectionId: resolved, updatedAt: nowISO() });
      }
    }
  }

  await _fixTemplateOutputLinks('personalTemplates', snap.personalTemplates, sel.personalTemplates, idMap.personalTemplates);
  await _fixTemplateOutputLinks('careerTemplates', snap.careerTemplates, sel.careerTemplates, idMap.careerTemplates);

}


/** Legacy destructive replace (unused): clears existing local data first, then imports selected snapshot parts. */
/** Legacy destructive replace (unused): clears existing local data first, then imports selected snapshot parts. */
async function clearAllLocalData() {
  // NOTE: This app no longer uses a global `db` handle.
  // Always open the DB via openDB() so import flows never fail with "db is not defined".
  const db = await openDB();
  const allStores = ['users','promptItems','personalItems','personalTemplates','personalContent','careers','careerBlocks','careerTemplates','careerContent','userCareer','connections','setupCategories','changeLogs'];
  const stores = allStores.filter(n => db.objectStoreNames.contains(n));
  if (!stores.length) return;
  const tx = db.transaction(stores, 'readwrite');
  stores.forEach(n => tx.objectStore(n).clear());
  await txComplete(tx);
  try { markLocalModified(); } catch {}
}

async function importSnapshotSelectionReplace(snap, sel) {
  await clearAllLocalData();

  // Reset remembered selections (they may no longer exist after replace)
  try {
    localStorage.removeItem('mivida_current_user_id');
    localStorage.removeItem('mivida_current_career_id');
    localStorage.removeItem('mivida_prompt_career_id');
  } catch {}
  state.currentUserId = '';
  state.currentCareerId = '';

  const emptyExistTitles = {
    users: new Set(),
    careers: new Set(),
    promptItems: new Set(),
    personalTemplates: new Map(),
    careerTemplates: new Map(),
    connections: new Set()
  };

  await importSnapshotSelectionAddToLocal(snap, sel);
}


async function refreshAll() {
  // 1) Top filters first (so downstream renders can rely on state + selects)
  await loadUsersIntoSelect();
  await loadCareerFilterSelect();
  await renderPersonalCareerPick();

  // 2) Setup page sections
  await renderPrompts();
  await renderPersonal();
  await renderCareerBlocks();
  await renderConnections();

  // 3) Prompt page
  await renderPromptPickers();
  await renderPromptPage();
}

/** ========= Wire Events ========= */
function wireEvents() {
  $('#btnCloseModal').addEventListener('click', closeModal);
  const overlay = $('#modalOverlay');
  let downOnOverlay = false;
  overlay.addEventListener('pointerdown', (e) => { downOnOverlay = (e.target === overlay); });
  overlay.addEventListener('pointerup', (e) => {
    if (e.target === overlay && downOnOverlay) closeModal();
    downOnOverlay = false;
  });
  overlay.addEventListener('pointercancel', () => { downOnOverlay = false; });

  $('#tabSetup').addEventListener('click', () => setTab('setup'));
  $('#tabPrompt').addEventListener('click', () => setTab('prompt'));

  $('#btnAddUser').addEventListener('click', addUserFlow);
  $('#btnRenameUser').addEventListener('click', renameUserFlow);
  $('#btnDeleteUser').addEventListener('click', deleteUserFlow);


  // Careers (top filter + management)
  $('#btnAddCareerTop').addEventListener('click', addCareerFlow);
  $('#btnRenameCareer').addEventListener('click', renameCareerFlow);
  $('#btnDeleteCareer').addEventListener('click', deleteCareerFlow);

  $('#btnAddPrompt').addEventListener('click', () => openEditItemModal({
    title: 'Edit ¬∑ Prompt Item',
    initial: { title:'', content:'' },
    onSave: savePromptItem,
    onDelete: deletePromptItem
  }));
  $('#btnAddPersonal').addEventListener('click', () => openEditItemModal({
    title: 'Edit ¬∑ Personal Info Item',
    initial: { title:'', content:'', isOutput: true, outputConnectionId: '' },
    outputMeta: { connections: null },
    onSave: savePersonalTemplateAndContent,
    onDelete: deletePersonalTemplate
  }));


  $('#btnAddCareerBlock').addEventListener('click', () => openEditItemModal({
    title: 'Edit ¬∑ Career Item',
    initial: { title:'', content:'', isOutput: true, outputConnectionId: '' },
    outputMeta: { connections: null },
    onSave: saveCareerTemplateAndContentByFilter,
    onDelete: deleteCareerTemplate
  }));

$('#btnAddConnection').addEventListener('click', () => openConnectionModal({
    mode:'create',
    initial:{ title:'', promptItemIds:[], personalTemplateIds:[], careerTemplateIds:[] }
  }));

  // Manage Categories (per Setup section)
  const _mcp = document.getElementById('btnManageCatsPrompts');
  if (_mcp) _mcp.addEventListener('click', () => openCategoryManager('promptItems'));

  const _mcs = document.getElementById('btnManageCatsPersonal');
  if (_mcs) _mcs.addEventListener('click', () => openCategoryManager('personalTemplates'));

  const _mcc = document.getElementById('btnManageCatsCareer');
  if (_mcc) _mcc.addEventListener('click', () => openCategoryManager('careerTemplates'));

  const _mcn = document.getElementById('btnManageCatsConnections');
  if (_mcn) _mcn.addEventListener('click', () => openCategoryManager('connections'));

  $('#btnExportLogs').addEventListener('click', exportLogsCsv);
  $('#btnExportSnapshot').addEventListener('click', openExportWizard);

  const fileInput = $('#fileImportSnapshot');
  $('#btnImportSnapshot').addEventListener('click', async () => {
    const s = getSyncUiState();
    if (s.provider === 'github') {
      await githubImportFlow({ wipe: false });
      return;
    }
    fileInput.click();
  });
  fileInput.addEventListener('change', async () => {
  const f = fileInput.files && fileInput.files[0];
  if (!f) return;
  try {
    const text = await f.text();
    await openImportWizardFromText(text);
  } catch (err) {
    console.error(err);
    toast('Import failed: ' + (err?.message || String(err)));
  } finally {
    fileInput.value = '';
  }
});

  // One-click wipe local data then import JSON (destructive)
  const wipeInput = $('#fileImportSnapshotWipe');
  const btnWipeImport = $('#btnWipeImportSnapshot');
  if (btnWipeImport && wipeInput) {
    btnWipeImport.addEventListener('click', async () => {
      const s = getSyncUiState();
      if (s.provider === 'github') {
        await githubImportFlow({ wipe: true });
        return;
      }
      wipeInput.click();
    });
    wipeInput.addEventListener('change', async () => {
      const f = wipeInput.files && wipeInput.files[0];
      if (!f) return;
      const ok = confirm('This will delete all local data and replace it with the selected JSON snapshot. Continue?');
      if (!ok) { wipeInput.value = ''; return; }
      try {
        const text = await f.text();
        pendingOnlineImportMeta = null;
        await wipeLocalAndImportAllFromText(text);
      } catch (err) {
        console.error(err);
        toast('Import failed: ' + (err?.message || String(err)));
      } finally {
        wipeInput.value = '';
      }
    });
  }
  // Prompt page: Expand/Collapse all (default collapsed)
  const btnExpandAll = $('#btnExpandAllPrompt');
  const btnCollapseAll = $('#btnCollapseAllPrompt');
  if (btnExpandAll) btnExpandAll.addEventListener('click', () => {
    document.querySelectorAll('[data-prompt-content="1"]').forEach(el => { el.style.display = 'block'; });
    // also update per-card toggle buttons
    document.querySelectorAll('#promptConnections .btn').forEach(b => {
      if (b.textContent === 'Expand') b.textContent = 'Collapse';
    });
  });
  if (btnCollapseAll) btnCollapseAll.addEventListener('click', () => {
    document.querySelectorAll('[data-prompt-content="1"]').forEach(el => { el.style.display = 'none'; });
    document.querySelectorAll('#promptConnections .btn').forEach(b => {
      if (b.textContent === 'Collapse') b.textContent = 'Expand';
    });
  });
  // Prompt page: Current User / User Career / Current Career pickers
  const promptUserSel = $('#promptUserSelect');
  const promptUserCareerSel = $('#promptUserCareerSelect');
  const promptCurrentCareerSel = $('#promptCurrentCareerSelect');

  if (promptUserSel) promptUserSel.addEventListener('change', async () => {
    state.currentUserId = promptUserSel.value || '';
    try { localStorage.setItem('mivida_current_user_id', state.currentUserId); } catch {}

    // Sync Setup tab selector (selection only)
    const setupUserSel = $('#userSelect');
    if (setupUserSel) setupUserSel.value = state.currentUserId || '';

    await renderPersonalCareerPick();
    await renderPersonal();
    await renderPromptPickers();
    await renderPromptPage();
  });

  if (promptUserCareerSel) promptUserCareerSel.addEventListener('change', async () => {
    const userId = state.currentUserId || '';
    if (!userId) return;

    const v = promptUserCareerSel.value || '';
    const t = nowISO();
    const before = await getOne('userCareer', userId);
    const after = { userId, careerId: v || null, updatedAt: t, createdAt: before?.createdAt || t };
    await putOne('userCareer', after);
    await logChange({ entityType:'userCareer', entityId:userId, action: before ? 'update' : 'create', after, before });

    // Sync Setup tab User Career selector
    const setupUcSel = $('#personalCareerPick');
    if (setupUcSel) setupUcSel.value = v || '';

    await renderPersonalCareerPick();
    await renderPromptPickers();
    await renderPromptPage();
  });

  if (promptCurrentCareerSel) promptCurrentCareerSel.addEventListener('change', async () => {
    await setCurrentCareer(promptCurrentCareerSel.value || '');
  });


  // Theme toggle (Dark/Light)
  const btnTheme = $('#btnToggleTheme');
  if (btnTheme) btnTheme.addEventListener('click', () => {
    const cur = document.documentElement.dataset.theme || 'dark';
    const next = (cur === 'light') ? 'dark' : 'light';
    setTheme(next);
  });

}




/** ========= GitHub Online Manual (Read only) ========= */
const GITHUB_CFG_KEY = 'mivida_github_cfg';

/** ========= Secrets (token storage) =========
 * We store the GitHub token in IndexedDB (not localStorage) so it persists across refresh/restart
 * while avoiding accidental exposure in plain localStorage dumps.
 * Note: In a pure front-end app, this is still accessible to anyone with browser access/devtools.
 */
const SecretStore = (() => {
  const DB_NAME = 'mivida_prompt_builder_secrets';
  const STORE = 'kv';
  const KEY_GH = 'github_token';
  let _tokenCache = '';

  const openDb = () => new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });

  const get = async (key) => {
    const db = await openDb();
    return new Promise((resolve) => {
      const tx = db.transaction(STORE, 'readonly');
      const os = tx.objectStore(STORE);
      const r = os.get(key);
      r.onsuccess = () => resolve(r.result || '');
      r.onerror = () => resolve('');
    });
  };

  const set = async (key, val) => {
    const db = await openDb();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, 'readwrite');
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
      tx.objectStore(STORE).put(String(val || ''), key);
    });
  };

  const del = async (key) => {
    const db = await openDb();
    return new Promise((resolve) => {
      const tx = db.transaction(STORE, 'readwrite');
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => resolve(false);
      tx.objectStore(STORE).delete(key);
    });
  };

  const init = async () => {
    // Migrate legacy token from localStorage into IDB once.
    let legacy = '';
    try {
      const cfg = JSON.parse(localStorage.getItem(GITHUB_CFG_KEY) || '{}') || {};
      legacy = String(cfg.token || '').trim();
      if (legacy) {
        cfg.token = ''; // scrub
        localStorage.setItem(GITHUB_CFG_KEY, JSON.stringify(cfg));
      }
    } catch {}
    const stored = (await get(KEY_GH)) || '';
    _tokenCache = stored || legacy || '';
    if (legacy && !stored) {
      await set(KEY_GH, legacy);
    }
  };

  const getGitHubToken = () => _tokenCache || '';
  const setGitHubToken = async (t) => { _tokenCache = String(t || '').trim(); await set(KEY_GH, _tokenCache); };
  const clearGitHubToken = async () => { _tokenCache = ''; await del(KEY_GH); };

  return { init, getGitHubToken, setGitHubToken, clearGitHubToken };
})();


const GitHubSync = (() => {
  const getConfig = () => {
    let v = {};
    try { v = JSON.parse(localStorage.getItem(GITHUB_CFG_KEY) || '{}') || {}; } catch { v = {}; }
    return {
      owner: (v.owner || '').trim(),
      repo: (v.repo || '').trim(),
      branch: (v.branch || 'main').trim(),
      folder: (v.folder || '').trim().replace(/^\/+|\/+$/g,''),
      token: (SecretStore.getGitHubToken() || '').trim(),
      uploader: (v.uploader || '').trim()
    };
  };

  const setConfig = async (cfg) => {
    const cur = getConfig();
    const incoming = { ...(cfg || {}) };

    // Token is stored in IndexedDB secrets. If input is blank, keep existing.
    if (Object.prototype.hasOwnProperty.call(incoming, 'token')) {
      const t = String(incoming.token || '').trim();
      if (t) await SecretStore.setGitHubToken(t);
      delete incoming.token;
    }

    const next = { ...cur, ...incoming, token: '' }; // never persist token in localStorage
    localStorage.setItem(GITHUB_CFG_KEY, JSON.stringify(next));
  };

  const isConfigured = () => {
    const c = getConfig();
    return !!(c.owner && c.repo && c.branch && c.folder && c.token);
  };

  const authHeaders = (token, useTokenPrefix=false) => {
    const t = String(token || '').trim();
    const h = {
      'Accept': 'application/vnd.github+json'
    };
    if (t) h['Authorization'] = (useTokenPrefix ? `token ${t}` : `Bearer ${t}`);
    return h;
  };

  const ghFetch = async (url, token) => {
    // Try Bearer first; some tokens prefer token prefix.
    let r = await fetch(url, { headers: authHeaders(token, false) });
    if (r.status === 401) {
      r = await fetch(url, { headers: authHeaders(token, true) });
    }
    return r;
  };

  const testConnection = async () => {
    const c = getConfig();
    if (!c.token) throw new Error('Missing GitHub token');
    const r = await ghFetch('https://api.github.com/user', c.token);
    if (!r.ok) {
      const t = await r.text().catch(()=> '');
      throw new Error(`Auth failed (${r.status}). ${t || ''}`.trim());
    }
    const me = await r.json();

    const repoUrl = `https://api.github.com/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}`;
    const rr = await ghFetch(repoUrl, c.token);
    if (!rr.ok) {
      const t = await rr.text().catch(()=> '');
      throw new Error(`Repo access failed (${rr.status}). ${t || ''}`.trim());
    }

    // Verify folder exists (required for Online import/export)
    const folderPath = c.folder ? ('/' + c.folder.split('/').map(encodeURIComponent).join('/')) : '';
    const folderUrl = `https://api.github.com/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}/contents${folderPath}?ref=${encodeURIComponent(c.branch)}`;
    const fr = await ghFetch(folderUrl, c.token);
    if (!fr.ok) {
      const t = await fr.text().catch(()=> '');
      throw new Error(`Folder access failed (${fr.status}). ${t || ''}`.trim());
    }

    return { login: me.login || '', ok: true };
  };

  const listJsonFiles = async () => {
    const c = getConfig();
    const folderPath = c.folder ? ('/' + c.folder.split('/').map(encodeURIComponent).join('/')) : '';
    const url = `https://api.github.com/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}/contents${folderPath}?ref=${encodeURIComponent(c.branch)}`;
    const r = await ghFetch(url, c.token);
    if (!r.ok) {
      const t = await r.text().catch(()=> '');
      throw new Error(`List folder failed (${r.status}). ${t || ''}`.trim());
    }
    const data = await r.json();
    const arr = Array.isArray(data) ? data : [];
    return arr
      .filter(x => x && x.type === 'file' && typeof x.name === 'string' && x.name.toLowerCase().endsWith('.json'))
      .map(x => ({ name: x.name, path: x.path, sha: x.sha, size: x.size || 0 }));
  };

    const parseSnapshotFilenameMeta = (name) => {
    const original = String(name || '');
    const base = original.replace(/\.json$/i, '');
    const parts = base.split('__');
    const stampRaw = parts[0] || base;
    const uploaderRaw = (parts.length > 1 ? parts.slice(1).join('__') : '');
    const uploader = uploaderRaw ? uploaderRaw.replace(/_/g, ' ').trim() : '';

    const cleaned = stampRaw
      .replace(/^mivida_snapshot_/i, '')
      .replace(/^mivida_snapshot-/i, '')
      .replace(/^snapshot_/i, '')
      .replace(/^snapshot-/i, '')
      .trim();

    // Accept patterns like:
    // 20260204_131245_123
    // 2026-02-04_13-12-45-123
    // 2026-02-04T13-12-45-123
    let m = cleaned.match(/(20\d{2})[-_]?([01]\d)[-_]?([0-3]\d)[T_ -]?([0-2]\d)[-_]?([0-5]\d)[-_]?([0-5]\d)(?:[-_]?([0-9]{3}))?/);
    if (!m) m = cleaned.match(/(20\d{2})([01]\d)([0-3]\d)[-_]?([0-2]\d)([0-5]\d)([0-5]\d)(?:[-_]?([0-9]{3}))?/);

    let ts = 0;
    let datetime = '';
    if (m) {
      const Y = +m[1], Mo = +m[2], D = +m[3];
      const h = +m[4], mi = +m[5], se = +m[6], ms = +(m[7] || 0);
      const dt = new Date(Y, Mo - 1, D, h, mi, se, ms); // local time
      ts = dt.getTime();

      const pad2 = (n) => String(n).padStart(2, '0');
      const pad3 = (n) => String(n).padStart(3, '0');
      datetime = `${String(Y).padStart(4, '0')}-${pad2(Mo)}-${pad2(D)} ${pad2(h)}:${pad2(mi)}:${pad2(se)}.${pad3(ms)}`;
    }

    return { ts, datetime, uploader };
  };

  const parseStamp = (name) => {
    return parseSnapshotFilenameMeta(name).ts || 0;
  };

  const getLatestFile = async () => {
    const files = await listJsonFiles();
    if (!files.length) return null;
    files.sort((a,b) => (parseStamp(b.name)-parseStamp(a.name)) || b.name.localeCompare(a.name));
    return files[0];
  };

  const downloadFileText = async (path) => {
    const c = getConfig();
    const safePath = String(path || '').split('/').map(encodeURIComponent).join('/');
    const url = `https://api.github.com/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}/contents/${safePath}?ref=${encodeURIComponent(c.branch)}`;
    const r = await ghFetch(url, c.token);
    if (!r.ok) {
      const t = await r.text().catch(()=> '');
      throw new Error(`Download failed (${r.status}). ${t || ''}`.trim());
    }
    const data = await r.json();
    const content = data && data.content ? String(data.content) : '';
    const enc = data && data.encoding ? String(data.encoding) : 'base64';
    if (enc !== 'base64') {
      throw new Error('Unsupported file encoding: ' + enc);
    }
    const raw = atob(content.replace(/\s/g,''));
    return raw;
  };
  const toBase64Utf8 = (str) => {
    // Safe base64 for unicode
    const bytes = new TextEncoder().encode(String(str || ''));
    let bin = '';
    bytes.forEach(b => { bin += String.fromCharCode(b); });
    return btoa(bin);
  };

  const ensureFolderExists = async () => {
    const c = getConfig();
    const folderPath = c.folder ? ('/' + c.folder.split('/').map(encodeURIComponent).join('/')) : '';
    const url = `https://api.github.com/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}/contents${folderPath}?ref=${encodeURIComponent(c.branch)}`;
    const r = await ghFetch(url, c.token);
    if (!r.ok) {
      const t = await r.text().catch(()=> '');
      throw new Error(`Folder access failed (${r.status}). ${t || ''}`.trim());
    }
    const data = await r.json().catch(()=>null);
    if (!Array.isArray(data) && !(data && data.type === 'dir')) {
      // GitHub returns array for a folder, object for a file.
      throw new Error('Folder path is not a directory: ' + (c.folder || '(root)'));
    }
    return true;
  };

  const uploadNewFile = async (path, contentText, message) => {
    const c = getConfig();
    if (!c.token) throw new Error('Missing GitHub token');
    await ensureFolderExists();

    const safePath = String(path || '').split('/').map(encodeURIComponent).join('/');
    const url = `https://api.github.com/repos/${encodeURIComponent(c.owner)}/${encodeURIComponent(c.repo)}/contents/${safePath}`;
    const payload = {
      message: message || ('Add snapshot ' + path),
      content: toBase64Utf8(contentText),
      branch: c.branch
    };
    // For PUT we need fetch with method and body.
    const doPut = async (useTokenPrefix=false) => fetch(url, {
      method: 'PUT',
      headers: { ...authHeaders(c.token, useTokenPrefix), 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    let pr = await doPut(false);
    if (pr.status === 401) pr = await doPut(true);

    if (!pr.ok) {
      const t = await pr.text().catch(()=> '');
      throw new Error(`Upload failed (${pr.status}). ${t || ''}`.trim());
    }
    return pr.json().catch(()=> ({}));
  };

  const makeLocalStamp = () => {
    const d = new Date();
    const pad = (n, w=2) => String(n).padStart(w,'0');
    return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}_${pad(d.getMilliseconds(),3)}`;
  };

  const sanitizeFilePart = (s) => String(s || '').trim()
    .replace(/[\s]+/g,'_')
    .replace(/[^a-zA-Z0-9._-]+/g,'')
    .replace(/^_+|_+$/g,'') || 'unknown';

  const uploadSnapshotJsonText = async (jsonText) => {
    const c = getConfig();
    const stamp = makeLocalStamp();
    const uploader = sanitizeFilePart(c.uploader || 'unknown');
    const filename = `${stamp}__${uploader}.json`;
    const relPath = (c.folder ? (c.folder.replace(/^\/+|\/+$/g,'') + '/') : '') + filename;
    await uploadNewFile(relPath, jsonText, `Add snapshot ${filename}`);
    return { filename, path: relPath };
  };


  return {
    getConfig, setConfig, isConfigured,
    testConnection, listJsonFiles, getLatestFile, downloadFileText, uploadSnapshotJsonText, ensureFolderExists,
    parseFilenameMeta: parseSnapshotFilenameMeta
  };
})();

async function githubImportFlow({ wipe }){
  try {
    const s = getSyncUiState();
    if (!GitHubSync.isConfigured()) {
      toast('Set GitHub sync settings first');
      openSyncSettingsModal();
      return;
    }

    const doImport = async (file) => {
      if (!file || !file.path) {
        toast('No snapshot selected');
        return;
      }
      const raw = await GitHubSync.downloadFileText(file.path);
      // Capture metadata for the top bar (applied only after a successful import)
      try {
        let s = JSON.parse(raw);
        if (s && typeof s === 'object' && (s.snapshot || s.data)) s = s.snapshot || s.data;

        const looksLikeSnapshot = s && typeof s === 'object' &&
          (Array.isArray(s.users) || Array.isArray(s.promptItems) || Array.isArray(s.connections) ||
           Array.isArray(s.careers) || Array.isArray(s.personalTemplates) || Array.isArray(s.careerTemplates) ||
           Array.isArray(s.personalItems) || Array.isArray(s.careerBlocks));

        if (looksLikeSnapshot) {
          pendingOnlineImportMeta = {
            uploadedAtLocal: String(s.uploadedAtLocal || parseLocalStampFromFilename(file.name) || '').trim(),
            uploadedBy: String(s.uploadedBy || parseUploaderFromFilename(file.name) || '').trim(),
            toolVersion: String(s.toolVersion || '').trim(),
            sourceName: String(file.name || '').trim(),
            sourcePath: String(file.path || '').trim()
          };
        } else {
          pendingOnlineImportMeta = null;
        }
      } catch {
        pendingOnlineImportMeta = null;
      }

      if (wipe) {
        // Confirm destructive wipe with a clear snapshot version (no milliseconds).
        const dtForPrompt = fmtLocalStampVersion((pendingOnlineImportMeta && pendingOnlineImportMeta.uploadedAtLocal) || parseLocalStampFromFilename(file.name) || '');
        const byForPrompt = ((pendingOnlineImportMeta && pendingOnlineImportMeta.uploadedBy) || parseUploaderFromFilename(file.name) || 'Unknown').trim();
        const ok = confirm(`Wipe local data and import this snapshot?\n\nVersion: ${dtForPrompt || '‚Äî'} ¬∑ ${byForPrompt || '‚Äî'}\n\nThis will delete all local data on this device. Continue?`);
        if (!ok) { pendingOnlineImportMeta = null; return; }
        await wipeLocalAndImportAllFromText(raw);
      } else {
        await openImportWizardFromText(raw);
      }

    };

    if (s.mode === 'auto') {
      const latest = await GitHubSync.getLatestFile();
      if (!latest) { toast('No JSON found in the configured folder'); return; }
      await doImport(latest);
      return;
    }

    // Manual: choose file
    const files = await GitHubSync.listJsonFiles();
    if (!files.length) { toast('No JSON found in the configured folder'); return; }

    openGitHubSnapshotPicker({
      title: wipe ? 'GitHub ¬∑ Choose a snapshot to Wipe & Import' : 'GitHub ¬∑ Choose a snapshot to Import',
      files,
      onPick: doImport
    });
  } catch (e) {
    console.error(e);
    toast('GitHub import failed');
    alert('GitHub import failed.\n\n' + (e && e.message ? e.message : e));
  }
}

function openGitHubSnapshotPicker({ title, files, onPick }){
  const wrap = document.createElement('div');
  wrap.className = 'form';

  const c = GitHubSync.getConfig();
  const header = document.createElement('div');
  header.className = 'muted';
  header.style.marginBottom = '10px';
  header.textContent = `${c.owner}/${c.repo} ¬∑ ${c.branch} ¬∑ /${c.folder}`;

  const list = document.createElement('div');
  list.style.display = 'flex';
  list.style.flexDirection = 'column';
  list.style.gap = '8px';

  const rows = (files || []).slice();
    rows.sort((a,b) => {
    const ma = (GitHubSync.parseFilenameMeta ? GitHubSync.parseFilenameMeta(a.name) : { ts: 0 });
    const mb = (GitHubSync.parseFilenameMeta ? GitHubSync.parseFilenameMeta(b.name) : { ts: 0 });
    return (mb.ts - ma.ts) || b.name.localeCompare(a.name);
  });

  rows.forEach(f => {
    const row = document.createElement('button');
    row.className = 'item';
    row.style.cursor = 'pointer';
    row.style.width = '100%';
    row.style.textAlign = 'left';
        const meta = (GitHubSync.parseFilenameMeta ? GitHubSync.parseFilenameMeta(f.name) : { datetime: '', uploader: '' });
    const dtText = fmtLocalStampVersion(meta.datetime || '') || 'Unknown datetime';
    const upText = meta.uploader || 'Unknown';
    row.innerHTML = `<div class="meta"><div class="name">${escapeHtml(dtText)}</div><div class="small">Uploaded by ${escapeHtml(upText)}</div></div>`;
    row.addEventListener('click', (e) => {
      e.preventDefault();
      closeModal();
      try { onPick && onPick(f); } catch (err) { console.error(err); }
    });
    list.appendChild(row);
  });

  wrap.appendChild(header);
  wrap.appendChild(list);

  openModal(title || 'GitHub snapshots', wrap, [
    btn('Close', { onClick: () => closeModal() })
  ]);
}

/** ========= Sync UI (Offline, Online Auto, Online Manual) ========= */
const SYNC_UI_PROVIDER_KEY = 'mivida_sync_provider'; // 'local' | 'github'
const SYNC_UI_MODE_KEY = 'mivida_sync_mode'; // 'auto' | 'manual'

const SYNC_LAST_ONLINE_IMPORT_KEY = 'mivida_sync_last_online_import_v1'; // stores last imported snapshot metadata (online only)
const LOCAL_LAST_MOD_KEY = 'mivida_local_last_modified_at_v1';           // stores last local edit timestamp
let pendingOnlineImportMeta = null;

function _parseLocalStampToDate(s){
  const str = String(s || '').trim();
  if (!str) return null;

  // If ISO-like, let Date parse.
  if (str.includes('T')) {
    const d = new Date(str);
    if (!isNaN(d.getTime())) return d;
  }

  // Accept: YYYY-MM-DD HH:mm[:ss][.mmm]
  let m = str.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?(?:\.(\d{1,3}))?$/);
  if (m){
    const Y=+m[1], Mo=+m[2], D=+m[3], h=+m[4], mi=+m[5], se=+(m[6]||0), ms=+(m[7]||0);
    const d = new Date(Y, Mo-1, D, h, mi, se, ms);
    if (!isNaN(d.getTime())) return d;
  }

  // Fallback: try Date parse
  const d = new Date(str);
  if (!isNaN(d.getTime())) return d;
  return null;
}
function _fmtLocal(d, { seconds=false } = {}){
  if (!d || isNaN(d.getTime())) return '';
  const pad = (n,w=2)=>String(n).padStart(w,'0');
  const base = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  if (!seconds) return base;
  return `${base}:${pad(d.getSeconds())}`;
}
function fmtLocalStampVersion(isoOrStr){
  const d = _parseLocalStampToDate(isoOrStr);
  if (d) return _fmtLocal(d, { seconds:false });
  // If already looks like YYYY-MM-DD HH:mm..., keep only minutes.
  const s = String(isoOrStr || '').trim();
  const m = s.match(/^(\d{4}-\d{2}-\d{2} \d{2}:\d{2})/);
  return m ? m[1] : (s ? s : '');
}
function fmtLocalStampFull(isoOrStr){
  const d = _parseLocalStampToDate(isoOrStr);
  if (d) return _fmtLocal(d, { seconds:true });
  const s = String(isoOrStr || '').trim();
  const m = s.match(/^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/);
  return m ? m[1] : (s ? s : '');
}
// Backward compatibility
function fmtLocalStampFromIso(isoOrStr){
  return fmtLocalStampFull(isoOrStr);
}
function fmtStampForBadge(stampOrIso){
  if (!stampOrIso) return '';
  const s = String(stampOrIso).trim();
  // Already a local stamp: YYYY-MM-DD HH:mm:ss.mmm or YYYY-MM-DD HH:mm...
  if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}/.test(s)) return s.slice(0,16); // drop seconds/ms for a cleaner badge
  const d = new Date(s);
  if (isNaN(d.getTime())) return s;
  const pad = (n)=>String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
}
function fmtStampForTooltip(stampOrIso){
  if (!stampOrIso) return '';
  const s = String(stampOrIso).trim();
  // If it already looks like a local stamp, remove milliseconds if present.
  if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}/.test(s)) return s.replace(/\.\d{3}\b/,'');
  const d = new Date(s);
  if (isNaN(d.getTime())) return s;
  const pad = (n)=>String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function isEditedSinceImport(localIso, importedAtIso){
  if (!localIso || !importedAtIso) return false;
  const a = new Date(localIso).getTime();
  const b = new Date(importedAtIso).getTime();
  if (isNaN(a) || isNaN(b)) return false;
  // Tolerance to avoid flicker around import completion time.
  return a > (b + 2500);
}

function parseLocalStampFromFilename(name){
  const n = String(name || '');
  // Expected local stamp: YYYYMMDD_HHMMSS_mmm
  const m = n.match(/(20\d{2})([01]\d)([0-3]\d)_([0-2]\d)([0-5]\d)([0-5]\d)_([0-9]{3})/);
  if (!m) return '';
  const [,Y,Mo,D,HH,MM,SS,MS] = m;
  return `${Y}-${Mo}-${D} ${HH}:${MM}:${SS}.${MS}`;
}
function parseUploaderFromFilename(name){
  const base = String(name || '').replace(/\.json$/i,'');
  const parts = base.split('__');
  if (parts.length < 2) return '';
  return parts.slice(1).join('__').replace(/_/g,' ').trim();
}
function getLastOnlineImportInfo(){
  try {
    const raw = localStorage.getItem(SYNC_LAST_ONLINE_IMPORT_KEY);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    return (obj && typeof obj === 'object') ? obj : null;
  } catch {
    return null;
  }
}
function setLastOnlineImportInfo(info){
  try { localStorage.setItem(SYNC_LAST_ONLINE_IMPORT_KEY, JSON.stringify(info || null)); } catch {}
  applySyncInfoUI();
}
function getLocalLastModifiedIso(){
  try { return localStorage.getItem(LOCAL_LAST_MOD_KEY) || ''; } catch { return ''; }
}

// Debounced so bulk imports do not spam localStorage.
let _localModT = null;
let _localModLatest = 0;
function markLocalModified(){
  _localModLatest = Date.now();
  if (_localModT) return;
  _localModT = setTimeout(() => {
    _localModT = null;
    try { localStorage.setItem(LOCAL_LAST_MOD_KEY, new Date(_localModLatest).toISOString()); } catch {}
    applySyncInfoUI();
  }, 250);
}

function applySyncInfoUI(){
  const s = getSyncUiState();
  const badge = document.getElementById('syncInfoBadge');
  const valueEl = document.getElementById('syncVersionValue');
  const editedEl = document.getElementById('syncEditedTag');
  if (!badge || !valueEl || !editedEl) return;

  if (s.provider !== 'github') {
    badge.style.display = 'none';
    return;
  }
  badge.style.display = 'flex';

  const info = getLastOnlineImportInfo();
  if (!info) {
    valueEl.textContent = '‚Äî';
    editedEl.style.display = 'none';
    badge.title = '';
    return;
  }

  const dtRaw = (info.uploadedAtLocal || info.uploadedAt || info.importedAtLocal || '') || '';
  const dt = fmtLocalStampVersion(dtRaw) || '‚Äî';
  const by = String(info.uploadedBy || info.uploader || '').trim() || '‚Äî';
  // UI shows the JSON "version" as (datetime ¬∑ uploader). Do not show tool/app version here.
  valueEl.textContent = `${dt} ¬∑ ${by}`;

  // Edited detection: compare local last modified vs baseline captured at import.
  const baselineIso = String(info.localBaselineIso || '').trim();
  const localIso = String(getLocalLastModifiedIso() || '').trim();
  const baselineT = baselineIso ? (new Date(baselineIso)).getTime() : 0;
  const localT = localIso ? (new Date(localIso)).getTime() : 0;
  const isEdited = (!!baselineT && !!localT && localT > baselineT + 500); // small buffer

  if (isEdited) {
    editedEl.style.display = '';
    const tip = fmtLocalStampFull(localIso) || '';
    badge.title = tip ? (`Last local edit: ${tip}`) : 'Last local edit: ‚Äî';
  } else {
    editedEl.style.display = 'none';
    badge.title = '';
  }
}

function finalizeOnlineImportMeta(){
  if (!pendingOnlineImportMeta) return;

  // Treat the just-imported local state as the baseline (not edited).
  const baselineIso = new Date().toISOString();
  try { localStorage.setItem(LOCAL_LAST_MOD_KEY, baselineIso); } catch {}

  // Cancel any pending debounced local-mod writes from the import burst.
  try { if (_localModT) { clearTimeout(_localModT); _localModT = null; } } catch {}

  const meta = { ...(pendingOnlineImportMeta || {}) };
  meta.localBaselineIso = baselineIso;

  setLastOnlineImportInfo(meta);
  pendingOnlineImportMeta = null;
}


function getSyncUiState(){
  const provider = (localStorage.getItem(SYNC_UI_PROVIDER_KEY) || 'local').toLowerCase();
  const mode = (localStorage.getItem(SYNC_UI_MODE_KEY) || 'manual').toLowerCase();
  return {
    provider: (provider === 'github') ? 'github' : 'local',
    mode: (mode === 'auto') ? 'auto' : 'manual'
  };
}
function setSyncUiState(provider, mode){
  localStorage.setItem(SYNC_UI_PROVIDER_KEY, provider);
  localStorage.setItem(SYNC_UI_MODE_KEY, mode);
  applySyncUiState();
}

function applySyncUiState(){
  const s = getSyncUiState();

  const btnProvider = document.getElementById('btnSyncProvider');
  const modeGroup = document.getElementById('onlineModeGroup');
  const btnMode = document.getElementById('btnSyncOnlineMode');
  const subEl = document.getElementById('syncSubText');

  if (btnProvider){
    btnProvider.dataset.provider = s.provider;
    const label = btnProvider.querySelector('.label');
    if (label) label.textContent = (s.provider === 'local') ? 'Offline' : 'Online';
  }

  if (modeGroup) modeGroup.style.display = (s.provider === 'github') ? '' : 'none';

  if (btnMode){
    btnMode.dataset.provider = 'github';
    const label = btnMode.querySelector('.label');
    if (label) label.textContent = (s.mode === 'auto') ? 'Auto' : 'Manual';
  }

  if (subEl){
    if (s.provider === 'local') subEl.textContent = 'Offline ¬∑ Local cache';
    else subEl.textContent = (s.mode === 'auto') ? 'Online ¬∑ Auto: import latest snapshot' : 'Online ¬∑ Manual: choose snapshot on import';
  }

  applySyncInfoUI();

  // Title hint
  document.title = 'Prompt Builder';

  // Keep Import/Export button labels stable but reflect provider
  const btnImp = document.getElementById('btnImportSnapshot');
  const btnWip = document.getElementById('btnWipeImportSnapshot');
  if (btnImp) btnImp.textContent = (s.provider === 'github') ? 'Import Snapshot (GitHub)' : 'Import Snapshot (JSON)';
  if (btnWip) btnWip.textContent = (s.provider === 'github') ? 'Wipe Local and Import (GitHub)' : 'Wipe Local and Import JSON';
}

function openSyncSettingsModal(){
  const cfg = GitHubSync.getConfig();

  const wrap = document.createElement('div');
  wrap.className = 'form';
  wrap.innerHTML = `
    <div class="row">
      <label style="min-width:120px;">Owner</label>
      <input id="ghOwner" type="text" placeholder="Repo owner (username or org)" value="${escapeHtml(cfg.owner)}" style="flex:1;" />
    </div>
    <div class="row">
      <label style="min-width:120px;">Repo</label>
      <input id="ghRepo" type="text" placeholder="e.g. MiVidaPromptData" value="${escapeHtml(cfg.repo)}" style="flex:1;" />
    </div>
    <div class="row">
      <label style="min-width:120px;">Branch</label>
      <input id="ghBranch" type="text" placeholder="main" value="${escapeHtml(cfg.branch)}" style="flex:1;" />
    </div>
    <div class="row">
      <label style="min-width:120px;">Folder</label>
      <input id="ghFolder" type="text" placeholder="e.g. snapshots" value="${escapeHtml(cfg.folder)}" style="flex:1;" />
    </div>
    <div class="row">
      <label style="min-width:120px;">Uploader name</label>
      <input id="ghUploader" type="text" placeholder="Your name" value="${escapeHtml(cfg.uploader)}" style="flex:1;" />
    </div>
    <div class="row">
      <label style="min-width:120px;">Token</label>
      <input id="ghToken" type="password" placeholder="${cfg.token ? 'Token saved (leave blank to keep)' : 'GitHub token'}" value="" style="flex:1;" />
    </div>
    <div class="row">
      <label style="min-width:120px;"></label>
      <div style="flex:1; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <div class="hint" style="margin:0;">Token is saved on this device. Leave blank to keep it.</div>
        <button class="btn mini danger" id="ghClearToken" type="button">Clear Token</button>
      </div>
    </div>
    <div class="row">
      <label style="min-width:120px;">Status</label>
      <div style="flex:1;">
        <div id="ghStatus" class="muted">Not tested</div>
        <div style="display:flex; gap:10px; margin-top:8px; flex-wrap:wrap;">
          <button class="btn mini" id="btnGhTest">Test connection</button>
        </div>
      </div>
    </div>
    <div class="muted" style="margin-top:10px;">This stores settings locally in your browser. Token is required for private repos. Read only support is implemented (import only).</div>
  `;

  const statusEl = wrap.querySelector('#ghStatus');

  const readInputs = () => ({
    owner: wrap.querySelector('#ghOwner')?.value || '',
    repo: wrap.querySelector('#ghRepo')?.value || '',
    branch: wrap.querySelector('#ghBranch')?.value || 'main',
    folder: wrap.querySelector('#ghFolder')?.value || '',
    uploader: wrap.querySelector('#ghUploader')?.value || '',
    token: wrap.querySelector('#ghToken')?.value || ''
  });

  const btnTest = wrap.querySelector('#btnGhTest');
  const btnClear = wrap.querySelector('#ghClearToken');
  if (btnClear) btnClear.addEventListener('click', async (e) => {
    e.preventDefault();
    await SecretStore.clearGitHubToken();
    toast('Token cleared');
  });

  if (btnTest) btnTest.addEventListener('click', async (e) => {
    e.preventDefault();
    try {
      await GitHubSync.setConfig(readInputs());
      if (statusEl) statusEl.textContent = 'Testing...';
      const res = await GitHubSync.testConnection();
      if (statusEl) statusEl.textContent = 'Connected as ' + (res.login || '');
      toast('Connected');
    } catch (err) {
      console.error(err);
      if (statusEl) statusEl.textContent = 'Failed: ' + (err?.message || String(err));
      alert('Connection test failed\n\n' + (err?.message || String(err)));
    }
  });

  openModal('Sync Settings', wrap, [
    btn('Cancel', { onClick: () => closeModal() }),
    btn('Save', { primary: true, onClick: async () => {
      await GitHubSync.setConfig(readInputs());
      closeModal();
      toast('Saved');
    }})
  ]);
}

function initSyncUi(){
  applySyncUiState();

  const btnProvider = document.getElementById('btnSyncProvider');
  const btnMode = document.getElementById('btnSyncOnlineMode');
  const btnSettings = document.getElementById('btnSyncSettings');

  if (btnProvider){
    btnProvider.addEventListener('click', async (e) => {
      e.preventDefault();
      const s = getSyncUiState();
      if (s.provider === 'local') {
        // Switch to online
        if (!GitHubSync.isConfigured()) {
          openSyncSettingsModal();
          // Keep offline until user saves
          return;
        }
        setSyncUiState('github', s.mode);
      } else {
        setSyncUiState('local', s.mode);
      }
    });
  }

  if (btnMode){
    btnMode.addEventListener('click', (e) => {
      e.preventDefault();
      const s = getSyncUiState();
      const next = (s.mode === 'auto') ? 'manual' : 'auto';
      setSyncUiState('github', next);
    });
  }

  if (btnSettings){
    btnSettings.addEventListener('click', (e) => {
      e.preventDefault();
      openSyncSettingsModal();
    });
  }

  const hr = document.getElementById('btnHardRefresh');
  if (hr){
    hr.addEventListener('click', (e)=>{
      e.preventDefault();
      const url = new URL(window.location.href);
      url.searchParams.set('v', Date.now().toString());
      window.location.replace(url.toString());
    });
  }
}


/** ========= Init ========= */
(async function init(){
  initTheme();
  wireEvents();
  await SecretStore.init();
  initSyncUi();
  await ensureSeed();
  await refreshAll();
})();
</script>
</body>
</html>
